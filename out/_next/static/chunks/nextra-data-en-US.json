{"/building-with-passport/composedb":{"title":"ComposeDB","data":{"":"ComposeDB is a decentralized graph database built on top of Ceramic.\nWhereas other databases typically store tables of information, a graph database stores relationships between nodes.\nInstead of just storing keys and values, a graph database allows connections between values to exist too.\nThis is very powerful for understanding, for example, user journeys, paths, histories and networks.In Compose DB, the nodes of the graph are accounts or documents with a globally unique ID. The relationships between these nodes are known as \"edges\". You can query nodes and edges.Being a product built on top of Ceramic, ComposeDB provides many benefits for web3 native applications including strong Ethereum integrations. There is also a rich, Graph-QL style API that helps developers to construct complex queries. These are very useful features for Human Passport.Perhaps more importantly, ComposeDB allows us to create and publish data schemas that work across different tech-stacks, meaning we can deploy apps that work identically across multiple layer-1 blockchains and their layer-2's. Data on ComposeDB is updateable allowing, for example, Stamp expiry and reverification.Read more in the ComposeDB documentation.","passport-on-composedb#Passport on ComposeDB":"The data used by Human Passport fits very well into the graph structure. There are two basic elements that Passport considers: user addresses and Stamps. These are nodes. The links between Stamps and users and edges.Let's say you want to know who owns a particular Stamp. You would identify the node for that Stamp and then query all the edges that connect the Stamp to user addresses.\nYou do not have to construct any of these queries as a Passport user! All this logic is handled by the Passport app.\nNodes can have properties associated with them, such as isDeleted or isRevoked that clarify something about it. These can be used to filter out edges in the graph (e.g. a query can be used to identify all edges connecting a node to other nodes whose isRevoked value is false).","schema#Schema":"Here's what a Stamp looks like in JSON format:\n{\n  \"type\": [\n    \"VerifiableCredential\", \"GitcoinPassportStamp\"\n  ],\n  \"@context\": [\n    \"https://www.w3.org/2018/credentials/v1\", \"https://credentials.passport.gitcoin.co/\"\n  ],\n  \"issuer\": \"...\",\n  \"issuanceDate\": \"2023-10-23T13:32:52.935Z\",\n  \"expirationDate\": \"2024-01-21T13:32:52.935Z\",\n  \"credentialSubject\": {\n    \"id\": \"did:pkh:eip155:1:0x0000000000000000000000000000000000000000\",\n    \"hash\": \"v0.0.0:12121212121212121212121212121212121212\",\n    \"provider\": \"MyProvider\",\n    \"@context\": [...]\n  },\n  \"proof\": {...}\n}\nand here is what it looks like to create this object in a ComposeDB database:\ntype GitcoinPassportStamp implements VerifiableCredential\n  @createModel(\n    accountRelation: LIST\n    description: \"A Human Passport Stamp with a provider and hash\"\n  )\n  @createIndex(fields: [{ path: \"issuer\" }])\n  @createIndex(fields: [{ path: \"issuanceDate\" }])\n  @createIndex(fields: [{ path: \"expirationDate\" }]) {\n  _context: [String!]!\n    @string(minLength: 1, maxLength: 1024)\n    @list(maxLength: 1024)\n  type: [String!]! @string(minLength: 1, maxLength: 1024) @list(maxLength: 1024)\n  issuer: String! @string(minLength: 1, maxLength: 1024)\n  issuanceDate: DateTime!\n  expirationDate: DateTime\n  credentialSubject: GitcoinPassportVcCredentialSubject!\n  proof: GitcoinPassportVcProof!\n}\nYou'll notice that the ComposeDB schema definition above uses embedded types and an interface. For brevity we've omitted those above, but you can observe the schema definitions in their entirety in our passportStamps.graphql document.The fields are as follows:\ntype: Passport Stamps are always VerifiableCredentials\ncontext: an array of strings with lengths between 1 and 1024 bytes to store links to the specifications for verifiable credentials and the Passport credential.\nissuer: a string with length 1 to 1024 bytes to store the address issuing the credential.\nissuanceDate: A datetime object referencing the time the credential was created.\nexpirationDate: A datetime object referencing the time the credential will expire.\ncredentialSubject: An object with the following subfields:\nid: A did unique identifier for this credential.\nhash: A hash of this Stamp object\nprovider: A hash corresponding to the Stamp provider\ncontext: A string of length 1 - to 1024 bytes for storing additional information about the Stamp.\nproof: A hash demonstrating that the Stamp was really attested by a provider.","syncing-passport-data-with-your-ceramic-node#Syncing Passport Data with Your Ceramic Node":"If you already have a ComposeDB node and you would like to sync and collaborate on Passport data based on the same definitions, you will need to use the same ComposeDB composite already deployed onto the Passport ComposeDB node (in order to ensure the same data model references are synced).We've put together a simple repository containing a script that automates this for you.First, clone the repository and install your dependencies:\ngit clone https://github.com/Passportxyz/passport-ceramic-deployment && cd eventual-repository-location && npm install\nThis repository has already been pre-loaded with the correct composite definition, so you do not need to edit your definition files.Next, follow step #2 in the README (which shows how to enter your node endpoint and corresponding admin seed as arguments).Finally, go ahead and deploy:\nnvm use 20\nnpm run deploy\nCongratulations! Your ComposeDB node is now indexing on the same passport data models.Finally, in order to run mutations and read queries against your node corresponding to the passport schema, don't forget to use your JavaScript Runtime Definition when casting these definitions onto your application's ComposeDB client.For more information about how this works, visit the ComposeDB examples documentation, or get in touch with the Ceramic team on their Official Forum.Here's an example of a query to retrieve 10 Passport Stamps. Users familiar with GraphQL will recognize the syntax.\n// Read some documents from compose\nconst m = `query MyQuery {\n  gitcoinPassportStampIndex(\n    last: 10\n  ) {\n    edges {\n      node {\n        credentialSubject {\n          _id\n          hash\n          metaPointer\n          provider\n        }\n        proof {\n          ...\n        }\n        expirationDate\n        id\n        issuanceDate\n        issuer\n      }\n    }\n  }\n}"}},"/building-with-passport/introduction":{"title":"Human Passport Developer Platform","data":{"":"If you’re a Human Passport user interested in setting up a Passport and connecting Stamps to it, head to our support site for more info.","what-is-passport#What is Passport?":"Passport is a tool that allows users to present evidence that they are real, unique humans and signal their trustworthiness to apps. It is a way to collect and present data without exposing it or giving up ownership.Under the hood, it is a unique decentralized identifier (a DID) associated with your Ethereum address, stored on the Ceramic network.The DID can be used to look up a user's Stamp data, which exists as a collection of Verified Credentials.Verified Credentials do not contain any personal identifying information! They simply demonstrate, using a cryptographic signature, that the user gave access to a specific app and that some criteria were met. Learn more about how Human Passport is privacy preserving.","use-cases#Use cases":"Developers can integrate Passport in a variety of different programs and apps in the web3 ecosystem, as demonstrated by the following use case examples:\nSybil resistance for faucets, bundlers and airdrops\nGating access to content, events, polls, or communities\nPriority weighting votes\nProving trustworthiness\nPassport is a versatile and valuable tool for managing access, promoting transparency, and establishing trust within different web3 environments.Learn more about Passport use cases.","available-developer-tools#Available developer tools":"Passport score and Stamp data can be retrieved in two ways:\nPassport API v2: Retrieves the Stamp-based Unique Humanity Score and associated metadata for a specified address.\nModel Based Detection API: This API is currently in beta. Retrieves the Model Based Detection Score for a specified address.\nPassport Smart Contracts: Interacts with a blockchain to retrieve Stamp-based Unique Humanity Scores associated with a specific address.","passport-api-v2#Passport API v2":"The Passport API v2 serves as a powerful tool for developers, offering access to Passport scores and Stamps via several REST endpoints.\nPlease note:In November 2024, we soft-launched Passport API v2.We have not announced any deprecation or retirement timelines for v1 yet, but do strongly recommend using v2 moving forward.You can learn more about the differences between v1 and v2 via our migration guide.","custom-passport#Custom Passport":"Custom Passport enables partners to develop a Human Passport dashboard that is customized to the unique needs of their ecosystem. This offering enables several additional features above and beyond what is offered on the standard Passport app, which can enable tailored proof of humanity solutions.","model-based-detection-api-beta#Model Based Detection API (beta)":"The Model Based Detection API enables you to retrieve the Model Based Detection Score for a specified address using a REST endpoint.","smart-contracts#Smart contracts":"Passport's smart contracts enable you to pull score and Stamp data directly from the blockchain to enable a truly decentralized integration.","composedb#ComposeDB":"ComposeDB is another available developer tool for building with Passport. It is a decentralized graph database built on top of Ceramic.Ceramic provides many benefits for web3 native applications including strong Ethereum integrations. It also provides a rich, Graph-QL style API that helps developers to construct complex queries.ComposeDB allows developers to create and publish data schemas that work across different tech-stacks, meaning you can deploy apps that work identically across multiple layer-1 blockchains and their layer-2's.\nData on ComposeDB is updateable which enables actions such as Stamp expirations and reverification.Read more on ComposeDB.","getting-started#Getting Started":"To begin your development journey with Human Passport, follow these steps:\nGet an API key and scorer ID for the APIs\nUse the API playground tool (requires API keys)\nGet to \"Hello World\" with Passport API v2\nBy following these steps, you'll be well-equipped to start integrating Passport into your platform.If you have questions or need support, you can chat with us on our developer support channel on Telegram."}},"/building-with-passport/custom-passport":{"title":"Custom Passport","data":{"":"Custom Passport enables partners to develop a Human Passport dashboard that is customized to the unique needs of their ecosystem. This offering enables several additional features above and beyond what is offered on the standard Passport app, which can enable tailored proof of humanity solutions.If you’re interested in building with Custom Passport, please reach out to our team:Contact the Passport team","whats-possible#What’s possible":"The custom Passport experience offers lots of customization options related to the look and feel of the experience, the stamp selection and even the scoring weights of stamps. Each of these options are configurable and still come with default values to guide the experience. Learn more about each feature below:\nCustomization\tDescription\tBranded dashboard and CTAs\tCreate a custom dashboard for your users to verify their humanity through. (Examples include Scroll, Shape, & Linea’s Verax)  Access this dashboard via a distinct URL, and add your branding, messaging, and a CTA (push Passport onchain or point to a domain of your choosing) to a module at the top of the page.  Display your custom Stamp weights and score threshold.\tCurate Stamps and weights\tRemove any Stamps or credentials that don’t make sense for your ecosystem, and adjust the remaining credential weights to better reflect your ecosystem’s needs.\tCreate your own Stamps:GuestList\tEnable your known humans to easily obtain a passing score based on their inclusion on a pre-vetted list.  This list could be based on POAP ownership, in-person event attendance, your own KYC, or other high-human or reputation signals.\tCreate your own Stamps:DeveloperList\tReward developers who have contributed to the development of specified GitHub repositories with points.  This Stamp could be built around a set of company-owned repositories, or around different important programming languages or tools.\tElevated rate limits\tAccess the custom score and Stamp data via the Passport API with elevated rate limits.","custom-passport-requirements#Custom Passport Requirements":"To build a custom dashboard, we need assets, messages, and CTAs that will help to inform your users around the program that is being protected. Also, if you choose to take advantage of the custom scorer or custom Stamps, we will partner with you to identify the proper weights, lists, and repos needed to set up those features on the backend.","branded-dashboard#Branded Dashboard":"The branded dashboard requires the following assets, messages, and CTAs to set it up:\nRequired element\tDescription\tExample\tCustom URL path\tThis path element will be used in your branded dashboard’s unique URL, which is where your users will access it.\thttps://app.passport.xyz/#/verax\tPartner name\tThis will be used in a few different locations throughout the dashboard.\tVerax\tScore threshold\tThe minimum score threshold that you will use to protect access to your program.\t20+\tBranded module:Logo\tThis will display in the branded module at the top of the dashboard.Should be the negative version suitable for dark backgrounds, square or vertical aspect ratio for maximum visibility.Must be SVG.\t\tBranded module:Primary description\tThis description helps your users understand the program that is being protected and how the score will be used. Must be 200 characters or less.\tVerax is a community maintained public attestation registry on Linea. Push your Passport Stamps onto Verax to gain rewards for early adopters in the Linea ecosystem.\tBranded module:Secondary description\tThis additional, optional description can help to clarify certain elements from your protected campaign. Must be 100 characters or less\tThis action requires ETH bridged to Linea Mainnet to cover network fees.\tBranded module:CTA link\tThis can be one of two things:A link to your website.A button that enables users to push onchain to your network, assuming we have also partnered to enable this\thttps://poh.linea.build\tBranded module:CTA text\tThe text that will be added to the button within the branded module.\tGet Linea’s PoH badge\tBranded module:Primary and secondary color\tThis color will be used to Must be a hex color.\t#d2dc95","custom-scorer#Custom Scorer":"If you decide that you’d like to remove any Stamps or reweight their credentials to better match your ecosystem’s needs, we will partner with you to come up with an updated set of weights.You can find the current Passport Stamp and credentialweights in the following link:Credential Map and WeightsPlease let us know the following if you’d like to customize the score:\nWhich Stamps and credentials would you like to remove\nHow you would like to reweight each of the individual Stamps\nWe can then review your request and let you know if it will still provide effective Sybil defense for your program.","guestlist-stamp#GuestList Stamp":"If you would like to create your own Stamp based on a pre-vetted allowlist, please provide us with either the NFT, POAP, or list of addresses that should be provided access to this Stamp.We will also need you to provide the points that you would like to be awarded with this Stamp.","developerlist-stamp#DeveloperList Stamp":"If you would like to create a Stamp that awards points for developer contribution, we will need you to provide the list of repos that developers will have needed to make commits to, as well as the number of commits you would like to award points for, and the number of points to assign.For example, you can build a Stamp that awards developers for having made the following level of commitments:\n1 commit – 1 point\n5 commits – 2 points (additional, on top of the earlier tier)\n10 commits – 3 points (same as the above)","elevated-rate-limits#Elevated Rate Limits":"Please let us know how many users you expect to participate in this campaign so we can help identify the right rate limit for you!","the-process#The Process":"Once you identify that you’d like to take advantage of the Custom Passport offering, we can get started on putting together the above requirements.As you provide these, we will build out your branded dashboard for you, and will provide you review sessions along the way. We can adjust and optimize your dashboard for you before your campaign goes live."}},"/building-with-passport/major-concepts/api-pagination":{"title":"API pagination","data":{"":"Some requests are likely to return a large amount of data. You can paginate it by adding ?limit=<x>, where x is the number of elements of the dataset you wish to return in each response, to the end of the request. This instructs the server to only send x \"pages\" of the response.For the Stamps endpoint, x refers to the number of Stamp objects to return in each response. The full request to the Stamp endpoint, including the pagination instruction and headers, could look as follows:\ncurl --request GET 'https://api.passport.xyz/v2/stamps/{address}?limit=3' \\\n  --header 'X-API-KEY: {API-KEY}'\nIn this example, the API will return three Stamps in each response.To help you navigate, the returned data includes values in the prev and next fields. These are endpoint URLs with pre-filled query parameters you can use to retrieve the previous or next chunk of data. Note that if you request a limit of 3, your next value is also going to have a limit of 3. For example, if the response contains Stamps 4, 5 and 6, the URL in prev will return Stamps 1, 2, and 3. The URL in next will return Stamps 7, 8, and 9.This is what a response looks like with the next and prev fields. Notice these fields values are endpoint URLs.\n{\n  \"next\": \"https://api.passport.xyz/v2/stamps/{address}?token=bmVw%4dFNQ9fM3TcxMTcD%3D&limit=3\",\n  \"prev\": \"https://api.passport.xyz/v2/stamps/{address}?token=c9fMTcHJlTcwdlxMNQ%3D%3D&limit=3\",\n  \"items\": [\n    {\n      \"version\": \"1.0.0\",\n      \"credential\": {...}\n    }\n  ]\n}\nTo retrieve the next page of results you can use the URL provided in the next field, in this case:\ncurl --request GET 'https://api.passport.xyz/v2/stamps/{address}?token=bmVw%4dFNQ9fM3TcxMTcD%3D&limit=3' \\\n  --header 'X-API-KEY: {API-key}'"}},"/building-with-passport/major-concepts/credential-map-and-weights":{"title":"Credential Map and Weights","data":{"":"The Stamp-based verification system uses a set of Stamps and underlying weighted credentials to determine the score of a Passport.","stamps-and-credentials#Stamps and credentials":"Each Stamp partner or concept has their own Stamp that users can see and interact with see in their Passport. Each Stamp can have one or multiple underlying weighted credentials, which represent an identity verification activity within the Stamp partner's ecosystem.The weights assigned to each credential represent how strong of a human signal the underlying verification activity represents. The higher the point allocation to a credential, the better the human signal.","custom-passport#Custom Passport":"If you'd like to customize these credentials -- either remove them from your community's Passport or adjust the weights -- you can do so with Custom Passport.Custom Passport enables you to customize the Passport Stamp-based offering around your ecosystem's unique needs. Choose which credentials to include at which weights, and even create your own custom Stamps.Learn more about Custom Passport.","credential-map-and-weights#Credential Map and Weights":"The following table will help you understand how to map the different available credentials to their corresponding Stamps and weights. It is sorted based on the Stamp, orderred highest points to least.These weights were last updated December 2024\nStamp\tcredential\tnew_weight\tETH Activity\ttotal\t22.541\t\tETHScore#50\t16.021\t\tETHScore#90\t2.926\t\tETHScore#75\t2.399\t\tETHDaysActive#50\t0.207\t\tETHGasSpent#0.25\t0.778\t\tETHnumTransactions#100\t0.210\tNFT\ttotal\t22.053\t\tNFTScore#50\t16.246\t\tNFTScore#90\t2.413\t\tNFTScore#75\t2.362\t\tNFT\t1.032\tHolonym\ttotal\t17.547\t\tHolonymGovIdProvider\t16.026\t\tHolonymPhone\t1.521\tGTC Staking\ttotal\t12.506\t\tTrustedCitizen\t4.009\t\tSelfStakingGold\t2.700\t\tExperiencedCommunityStaker\t2.161\t\tSelfStakingSilver\t2.066\t\tSelfStakingBronze\t0.897\t\tBeginnerCommunityStaker\t0.673\tCoinbase\tCoinbaseDualVerification\t10.042\tBinance\tBinanceBABT\t10.021\tIdena\ttotal\t9.736\t\tIdenaState#Newbie\t5.892\t\tIdenaState#Verified\t1.924\t\tIdenaState#Human\t1.921\tCivic\ttotal\t8.867\t\tCivicUniquenessPass\t5.005\t\tCivicLivenessPass\t3.038\t\tCivicCaptchaPass\t0.823\tGitcoin\ttotal\t6.237\t\tGitcoinContributorStatistics#totalContributionAmountGte#1000\t4.997\t\tGitcoinContributorStatistics#totalContributionAmountGte#100\t1.017\t\tGitcoinContributorStatistics#totalContributionAmountGte#10\t0.223\tGitHub\ttotal\t6.026\t\tgithubContributionActivityGte#120\t2.259\t\tgithubContributionActivityGte#60\t1.888\t\tgithubContributionActivityGte#30\t1.879\tLinkedin\tLinkedin\t1.531\tGuild\ttotal\t0.708\t\tGuildAdmin\t0.468\t\tGuildPassportMember\t0.240\tGoogle\tGoogle\t0.525\tDiscord\tDiscord\t0.516\tSnapshot\tSnapshotProposalsProvider\t0.239\tLens\tLens\t0.230\tSafe\tGnosisSafe\t0.222\tENS\tEns\t0.208\tBrightID\tBrightid\t0.202"}},"/building-with-passport/major-concepts/deduplicating-stamps":{"title":"Deduplicating Stamps","data":{"why-is-deduplication-necessary#Why is deduplication necessary?":"Stamp deduplication is a crucial feature that prevents users from amplifying their influence over some specific outcome by submitting the same Stamps across multiple Passports.It is important for users to be able to hold multiple Passports representing different user profiles that might be used to as identification in specific communities. However, without deduplication logic, this could allow users to repeatedly attach the same Stamps to multiple Passports, fooling an app into treating each Passport as a real, verified human.Deduplication ensures that a user can only associate an individual Stamp to one single identity within a specific context.","do-you-need-to-handle-deduplication-in-your-app#Do you need to handle deduplication in your app?":"If your app uses a Passport default Scorer, then deduplication is already handled server-side. When you request a score through the API, we calculate scores after already deduplicating Stamps, meaning you don't have to implement any deduplication logic yourself.However, if you are using your own custom scoring mechanism based on Stamp data, you will have to implement deduplication for yourself. Each Stamp has a hash field that can be used as a unique identifer. You can store hashes and compare them across all your users' Passports to ensure they are not being used multiple times. Our Scorer uses a Last-In-First-Out mechanism to handle duplicates, but you might want to use your own algorithm in your custom Scorer.","how-does-human-passport-handle-duplicate-stamps#How does Human Passport handle duplicate Stamps?":"Human Passport handles the issue of Stamp duplication by automatically identifying and eliminating duplicate Stamps. This prevents users from using the same credentials to verify their Stamps and identity across multiple Passports. This ensures that each user in an application has a unique and consistent digital identity.By default, the Human Passport API uses a Last In, First Out (LIFO) Stamp deduplication method.This means that, in a given scoring instance, if a Passport holder submits a Stamp that has already been submitted by another user, the duplicate Stamp is ignored and not counted towards the score.For example, let’s say you build an application that uses the Human Passport API to verify the unique humanity of your users. Two Passports, “Passport A” and “Passport B,” present the same Stamp based on the same Twitter account. In this scenario, the Last-in-First-out deduplication method would only count the Stamp instance that was submitted earliest, ignoring the one that was submitted later.For example, if Passport A submitted the Twitter Stamp first, followed by Passport B, your app would only count the instance of the Twitter Stamp submitted by Passport A. The same rule applies to any subsequent instances of the Stamp.This LIFO method ensures that each Passport’s score accurately reflects the unique identity of its holder. This prevents duplicate Stamps from skewing the verification process and prevents users from re-using evidence of personhood across multiple Passports within an application.","things-to-note#Things to note":"Stamps are unique to scoring instances. For example, one user uses Passport holder A with one Twitter account in an application that uses scoring instance X, and another user uses the same Twitter account in a distinct Passport in an independent scoring instance Y. In this case, both users will get scored for the Twitter account. As long as the scoring instances are independent, there is no concern for double counting or interference between instances. This allows users to create multiple personas that they use in different contexts but prevents double-counting of their credentials within a context.The scores assigned to Passports will not change once they are issued. This means that there is no need to recalculate Passport scores or synchronize them again in case of duplicate Stamp submissions. Once a score is assigned to a Passport, it remains fixed and can be relied upon for future verifications, even if a duplicate Stamp is submitted by a new Passport. This makes the scoring process more efficient and streamlined, which is particularly important for large and complex applications that score a high volume of verifiable credentials.Also note that because Stamp deduplication is achieved using a 'last in, first out' model, it is possible for Passports with identical Stamps to return different scores from different Scorers. The reason is that if the identical passports A and B are submitted to Scorer 1 in the order A,B, the returned score could be different to the same Passports submitted to Scorer 2 in the order B,A, because different instances of duplicate Stamps would be removed.","summary#Summary":"The LIFO deduplication strategy has several benefits for Passport holders and developers. It ensures that each Passport holder (in other words, Ethereum address) is assessed based on their unique set of Stamps, and that no one receives an unfair advantage due to having the same Stamp as another Passport holder within a given scoring instance. This means that for applications using the Human Passport API, there will be no double-counting of Stamps within the app, ensuring a fair and accurate assessment of each user’s unique identity."}},"/building-with-passport/major-concepts/educating-users":{"title":"Educating users","data":{"":"This page is for platforms who integrate with Human Passport and make its sybil-resisting functionality available to their ecosystem partners.On this page, you will learn what types of attacks Human Passport can protect against, see examples of existing platform integrations, understand integration best-practices and identify the key information your users need to know.","audience-definitions#Audience definitions":"First off, some audience definitions:\nPlatform Integrator: An application that integrates with Passport and makes the functionality available to their ecosystem partners.\nEcosystem partners: Organizations or apps who use the platforms built by Platform Integrators.\nEnd-users: People who are engaging with the ecosystem partner's content or programs within the platform.\nWe'll use Snapshot as an example. Snapshot is an offchain voting platform that allows DAOs, DeFi protocols, or NFT communities to participate in decentralized governance. Within the Snapshot platform, Optimism Collective allows users to vote on proposals using Snapshot's technology.In this situation, Snapshot would be a platform integrator, Optimism Collective would be an ecosystem partner, and the users submitting and voting on proposals are end-users.Here are some examples and their Human Passport use cases:\nPlatform Integrator\tEcosystem Partner\tEnd user\tWhy the Platform integrating Human Passport is a win for everyone\tSnapshot\tDAOs and other groups that need a proposal and voting system\tDAO contributors and other voters\tVoting outcomes that bias towards real democracy and less so algorithmic manipulation\tGuild\tGuild admins\tGuild members\tRewards going to unique humans instead of bots and Sybils\tGalxe\tCommunity engagement campaign creators\tPeople who want to earn rewards by participating in campaigns\tRewards going to unique humans instead of bots and Sybils","what-are-sybils-and-why-should-you-care#What are Sybils and why should you care?":"Sybil attacks describe the abuse of a digital network by creating many illegitimate virtual personas. There are several ways that users can become incentivized to create Sybil accounts, for example to receive a reward multiple times, or have additional influence over a vote. They prevent you from efficiently allocating power and/or capital among your community by capturing it for some dishonest person or group. Without some form of Sybil defense, you have no way to tell whether the users showing up to your application really represent individual human users or whether they are actually bots or fake accounts.","what-is-sybil-defense#What is Sybil defense?":"Sybil defense is a catch-all term for any actions that minimize the effect of Sybils. Typically, Sybil defense involves filtering out users that can't provide sufficient evidence that they are real human individuals. The more effective the Sybil defense, the more confident you can be that your users are real, and the more effectively you can distribute rewards, votes and other forms of capital and agency to your community.Human Passport is a Sybil defense tool. It provides everything you need to check the personhood of your users without invading their privacy.Read more about Sybil defense on the blog.","why-human-passport#Why Human Passport?":"Human Passport aggregates evidence of personhood from across web2 and web3, makes it available via a simple API, and does so while preserving user's privacy. Application developers and platform owners benefit from easy integration and flexibility to choose what evidence is most important to them, and how high their threshold for evidence should be. Users benefit from a simple UI that guides them along a simple path to collecting Passport Stamps and presenting them to apps, requiring only an Ethereum account to get started.Integrating Human Passport into an application is a powerful and flexible way to add Sybil defense to your application that is straightforward for developers and users alike. Importantly, Human Passport is flexible so you can configure your own Sybil defenses to your own specification, ensuring you get the best protection for your particular use case.Read more on why you should use Passport.","how-to-integrate-human-passport-into-your-platform#How to integrate Human Passport into your platform":"The most common way platforms use Human Passport is to use Passport scores or specific combinations of Stamps to control access to some content or function. This can be handled in just a few simple functions in your app.We have detailed guides demonstrating various Passport integrations. After you have integrated Passport into your app, your users can connect their Ethereum wallet, and the app can make an API call to the Passport server to retrieve the user's Stamps and Passport score.The score is the sum of weights assigned to the user's Stamps. It is possible to create custom algorithms for scoring Passports from raw Stamp data, but using Passport's server is considered best practice for several reasons:\nYou benefit from Stamp weights that have been assigned by Human Passport data scientists.\nYou do not have to handle complications such as Stamp deduplication - the server does this for you.\nYou can follow our simple tutorials to quickly and easily start defending your app from Sybils!\nWhile utilizing the Passport score is a best practice, you could also use Stamp data in addition to the Passport score, or just use Stamp data to gate access. For example, a few specific Stamps might be particularly important to you (maybe you decide that having a Github account for over 180 days is a hard requirement to access your platform). In this case you can access your user's Stamp collection and confirm ownership of individual Stamps.Finally, you might not necessarily want to automatically gate access based on Passport scores or Stamps. Perhaps you want to display Stamp and score information about each user so platform administrators or end users can make real-time decisions based on the user's trustworthiness or reputation. For example, you might have to determine an honest user from several impersonator accounts. Quick access to Stamp and score data would give you a strong signal about who is the genuine user. There is a guide for displaying Stamp and score data in your app's UI here!Read more on How Passport works.Start building using our Integration guides.","what-does-this-look-like-for-ecosystem-partners#What does this look like for ecosystem partners?":"It would be helpful to understand the audience definitions in the introduction of this page when reading this section.If integrated properly, ecosystem partners utilizing a platform's services will be able to utilize Human Passport functionality to ensure that their content or programs are minimally affected by Sybils.For example, an ecosystem partner runs a forum and voting platform in addition to their main application. Integrating Human Passport across all these platforms gives them confidence that your whole organization is protected to the same standard, with the same configuration.A Human Passport integration is straightforward, flexible and configurable to ecosystem partners' needs depending on how a platform integrator builds the integration. You can easily set global configurations that are standard across all platforms and partners, or you could tailor your Sybil defences to each platform, so that you can have stricter controls for more sensitive services.You can learn more about these benefits by reading our blog post about our partnership with Guild.xyz.","what-does-this-look-like-for-end-users#What does this look like for end users?":"End users benefit from a very straightforward verification process and proof of personhood they can use across web3. Human Passport is a very widely used Sybil defense tool that your users can set up once and then use to identify themselves to all kinds of apps and services.Your end users can follow this simple guide to set up their Passport:\nTo get started, you must have an Ethereum wallet.\nThen, you can visit the Passport app.\nThere, you can sign in with Ethereum and connect Stamps to your Passport in a few clicks.\nWhen they want to utilize a tool that is Passport-gated, you can sign a message and provide access to the platform provider to read your Stamp and score data.","more-customization#More customization":"Some platforms will find that they have specific needs that are not met by the standard Stamp library. In that case, you can add a new Stamp specifically for your purpose! Creating a Stamp requires some provable action to be captured in the form of a Verifiable Credential. We have created a step-by-step guide to help platforms to create new Stamps.\nThe weights assigned to individual Stamps in the Passport scoring app are also likely to change if re-weighting is likely to improve the overall Sybil defence efficacy of the Scorer. You can also implement your own scoring algorithm if the default weights aren't right for your use-case.","use-cases#Use cases":"Human Passport is already protecting many real world applications! There are several use case articles on the Gitcoin blog where you can read about how various apps have integrated Passport.Some examples include:","where-to-go-from-here#Where to go from here?":"You can explore this site!\nLearn more about the major concepts underpinning Passport\nRead more about how Passport works and why you should use it\nStart building by following our integration guides\nGet you own Passport at https://app.passport.xyz\nYou can join the Passport Developer Telegram and ask questions to the developers, users and wider community"}},"/building-with-passport/major-concepts/expirations":{"title":"Expirations","data":{"":"Stamps and scores eventually become invalid. This is a security feature that provides a degree of confidence that the Stamps and scores you query in your application are still valid.Without some mechanism for Stamp expiry, a Stamp issued once would remain valid forever, even if the evidence supporting that Stamp or score had long since changed.For example, a user could mint a Stamp using an account on some Web2 service in the small window between creating the account and it being shut down by the service's compliance team. Without expiry, you would not be able to tell, but with expiry, after some time the user would simply not be able to reverify the Stamp.The shorter the time between the issuance date and the expiration date, the more security you gain, but the trade off is that the user experience deteriorates because users are forced to reverify frequently.","offchain-stamps#Offchain Stamps":"Offchain Stamps expire after 90 days. This is handled by the Human Passport server.Users can bump the expiry date by another 90 days by reverifying your Stamps on the Passport app.","onchain-stamps#Onchain Stamps":"Like offchain Stamps, onchain Stamps also expire. For Passport attestations, there is a key in the schema called Expiration Dates. An integrator can query this field to see whether the current time is later or earlier than the expiryDate and use this to determine whether a Stamp has expired. The expiryDate is automatically set to 90 days after the issuanceDate. Reverification requires issuing a new Passport attestation.Onchain scores do not have an explicit expiry date associated with them. Integrators can use the attestation transaction time as a proxy for the issuance date. As a rule of thumb, we recommend expiring scores 90 days after it was created. Offchain Stamps also expire after 90 days.You can read more detail about onchain Samp and score expiry here."}},"/building-with-passport/major-concepts/scoring-thresholds":{"title":"Scoring thresholds","data":{"":"A very common use case for Human Passport is gating access based on Passport scores.\nIn order to do this, application owners have to determine a cutoff for users that are, and are not, allowed to access some content or function.\nTypically, this cutoff is a certain Passport score above which users are allowed access; otherwise they are blocked.\nThis is known as the threshold score.","human-passports-scorer#Human Passport's Scorer":"The Unique Humanity (binary) Scorer provided on the Passport app applies a threshold to users' Passport scores.\nThis is how the Scorer is able to return a binary Sybil/non-Sybil response.The algorithm adds up the weights of each Stamp owned by each user and compares the result to a pre-defined threshold value.\nEach users score either exceeds that threshold or it doesn't, making it possible to assign them a binary score.The threshold used by the Passport app is 20.This is designed to be an effective default threshold value for general-purpose use.Passport data scientists use datasets of known Sybils and known humans to analyze how credentials are used by good and bad actors, and what threshold most effectively separates the two groups.\nHowever, it is important to note that it is not a perfect system. Not all Sybils will be eliminated at that threshold.\nOn the other hand, higher thresholds might create excessively high barriers to entry that eliminate honest human users.","trade-offs#Trade-offs":"Choosing a threshold is always a balance between eliminating bad actors on the one hand, and making your application useable for honest humans on the other.\nA very high threshold will be more effective at eliminating Sybils because the time, effort and possibly money expended to meet the threshold are greater.\nThis means it is less economically viable for bad actors to create large numbers of fake accounts.\nHowever, your honest users also have to meet those same criteria.\nIf they are too onerous or difficult, your honest users might be unable or unwilling to participate.\nTherefore, there is always a balance to strike between widening honest participation and reducing dishonest participation.\nWhere the right balance lies will differ from project to project. The Passport default of 20 is thought to be a good all round starting point.\nUnique Humanity score\tEffectiveness at eliminating Sybils\tRisk of screening out real users\t20\tEffective\tLow\t25\tMore effective\tMedium\t30\tMost effective\tHigh\t\nBy implementing your own Scorer, you can tweak the entry requirements to your application more finely.\nNot only can you change the threshold, but you can upweight or downweight certain Stamps that are particularly strong signals for your specific use-case.\nYou could even have certain Stamps as absolute requirements, or use a combination of required Stamps and an overall score threshold.Learn more about custom Scorers in our tutorial."}},"/building-with-passport/model-based-detection/api-reference":{"title":"API reference","data":{"":"The Model Based Detection API enables developers to retrieve different model-based unique humanity scores in real-time, enabling you to score any EVM wallet address without requiring the users to create and build up a Passport score.This API is currently in beta.\nIf you need a production-ready API, please use the Stamp-based API.\nNeed more in-depth Sybil or reputation data analysis? Please fill out this quick form.\nYou can also experiment with the Model Based Detection API using our API playground tool and adding your API keys via the 'Authorize' button.","rate-limits#Rate Limits":"Tier\tRate limit\tTier 1\t[DEFAULT] 15 requests per 15 minutes\tTier 2\t350 requests per 15 minutes\tTier 3\t2000 requests per 15 minutes\t\nThese rate limits are completely separate from the existing Passport API rate limits.If you'd like to request elevated rate limits, please fill out our rate limit elevation form.","retrieve-model-based-detection-scores#Retrieve Model Based Detection scores":"Use this endpoint to request a model-based score for a specified user. You can find all of the available models and recommended score thresholds via our available models page.\nEndpoint: GET /v2/models/score/{address}\nBase URL: https://api.passport.xyz\nAuthentication: API Key – Can be the same API Key that is used with the Passport API","parameters#Parameters":"Parameter\tType\tDescription\taddress\tPath parameter\t[Required] Pass a single EVM wallet addressWhile we only allow a single address to be scored per request, we are considering expanding this to enable bulk scoring when we graduate this API from beta. If this is important to you, please let us know.\tmodel\tQuery parameter\tInclude one of the following available models to request that model's score for the specified wallet address: aggregate, ethereum_activity, nft, arbitrum, optimism, polygon, and zksyncIf you don't include this parameter, the API will return the aggregate model by default.While we only allow scoring using a single model per request, we are considering enabling requesting multiple models when we graduate this API from beta. If this is important to you, please let us know.","default-example#Default example":"","request#Request":"curl --request GET \\\n    --url 'https://api.passport.xyz/v2/models/score/{address}?model=aggregate' \\\n    --header 'Content-Type: application/json' \\\n    --header 'X-API-KEY: {API KEY}'","response#Response":"{\n    \"address\": \"string\",\n    \"details\": {\n        \"models\": {\n            \"aggregate\": {\n                \"score\": 50 \n            }\n        } \n    }\n}","arbitrum-model-example#Arbitrum model example":"","request-1#Request":"curl --request GET \\\n    --url 'https://api.passport.xyz/v2/models/score/{address}?model=arbitrum' \\\n    --header 'Content-Type: application/json' \\\n    --header 'X-API-KEY: {API KEY}'","response-1#Response":"{\n    \"address\": \"string\",\n    \"details\": {\n        \"models\": {\n            \"arbitrum\": {\n                \"score\": 50 \n            }\n        } \n    }\n}"}},"/building-with-passport/model-based-detection/available-models":{"title":"Available models and recommended scores","data":{"":"At this time, we have deployed a few different models to help verify unique humans. We plan to expand this list of models greatly, first by exploring additional Sybil detection models for several L2 partners, and then looking into other web3 verticals and reputation signals.We currently offer the following models via the Model Based Detection API:\nAggregate unique humanity score - aggregate\nEthereum (L1) unique humanity model - ethereum_activity\nNFT (L1) unique humanity model - nft\nArbitrum unique humanity model - arbitrum\nOptimism unique humanity model - optimism\nPolygon unique humanity model - polygon\nzkSync unique humanity model - zksync\nEach model will assign a score of 0 - 100 to wallet addresses that are checked against it. A score of 0 represents likely Sybil, while a score of 100 represents likely human.For each model, we will provide a table that describes the different score thresholds you can use to gate access or classify addresses. We define the columns of those tables here:\n% of qualifying verified humans - This metric represents the number of Passport users who qualified for the score threshold and scored a 20 or higher with the Stamp-based verification system.\n% of verified Sybil penetration - This metric represents the number of verified Sybils from our list that were able to qualify for the score threshold.\nPlease note that the percentages included in these tables do not necessarily translate to the percentage of participation for each individual partner.We calculate the percentage of qualifying humans and Sybils at various thresholds, derived from a curated list of collected addresses labeled as either Sybils or humans.\nIf you would like more details on the score or these thresholds, please fill out the following form:Model Based Detection interest form","aggregate-unique-humanity-model#Aggregate unique humanity model":"The aggregate unique humanity model score is the current default for the Model Based Detection API, as it is broadly relevant to a variety of different ecosystems operating within the EVM ecosystem.This model integrates individual chain model scores (Ethereum, zkSync, Optimism, Arbitrum, and Polygon) to generate the final aggregate score, assigning a score between 0 - 100, with 0 being likely Sybil or not having enough transaction history, and 100 being confidently human.Refer to the following table to identify which score threshold you might use to protect access or classify wallet addresses in your ecosystem:\nScore threshold\t% of qualifying verified humans\t% of verified Sybil penetration\t15+\t97%\t14%\t25+\t96%\t12%\t50+\t94%\t9%\t75+\t89%\t5%","eth-l1-unique-humanity-model#ETH (L1) unique humanity model":"This model looks at the specified wallet addresses' ETH mainnet transaction history, compares it against 50+ different features, and assigns it a score of 0 - 100.Refer to the following table to identify which score threshold you might use to protect access or classify wallet addresses in your ecosystem:\nScore threshold\t% of qualifying verified humans\t% of verified Sybil penetration\t15+\t97%\t14%\t25+\t96%\t12%\t50+\t94%\t9%\t75+\t89%\t5%","nft-ethereum-l1-unique-humanity-model#NFT (Ethereum L1) unique humanity model":"Similarly to the ETH (L1) unique humanity model, this model looks at the specified wallet addresses' NFT transaction history on Ethereum mainnet, compares it against different features, and assigns it a score of 0 - 100.Refer to the following table to identify which score threshold you might use to protect access or classify wallet addresses in your ecosystem:\nScore threshold\t% of qualifying verified humans\t% of verified Sybil penetration\t15+\t98%\t11%\t25+\t97%\t9%\t50+\t95%\t6%\t75+\t92%\t4%","arbitrum-unique-humanity-model#Arbitrum unique humanity model":"This model looks at the specified wallet addresses' Arbitrum transaction history, compares it against different features, and assigns it a score of 0 - 100.Refer to the following table to identify which score threshold you might use to protect access or classify wallet addresses in your ecosystem:\nScore threshold\t% of qualifying verified humans\t% of verified Sybil penetration\t15+\t99%\t21%\t25+\t98%\t14%\t50+\t94%\t7%\t75+\t92%\t6%","optimism-unique-humanity-model#Optimism unique humanity model":"This model looks at the specified wallet addresses' Optimism transaction history, compares it against different features, and assigns it a score of 0 - 100.Refer to the following table to identify which score threshold you might use to protect access or classify wallet addresses in your ecosystem:\nScore threshold\t% of qualifying verified humans\t% of verified Sybil penetration\t15+\t98%\t14%\t25+\t97%\t10%\t50+\t96%\t5%\t75+\t94%\t4%","polygon-unique-humanity-model#Polygon unique humanity model":"This model looks at the specified wallet addresses' Polygon transaction history, compares it against different features, and assigns it a score of 0 - 100.Refer to the following table to identify which score threshold you might use to protect access or classify wallet addresses in your ecosystem:\nScore threshold\t% of qualifying verified humans\t% of verified Sybil penetration\t15+\t98%\t15%\t25+\t97%\t11%\t50+\t94%\t7%\t75+\t92%\t6%","zksync-unique-humanity-model#zkSync unique humanity model":"This model looks at the specified wallet addresses' zkSync Era transaction history, compares it against different features, and assigns it a score of 0 - 100.Refer to the following table to identify which score threshold you might use to protect access or classify wallet addresses in your ecosystem:\nScore threshold\t% of qualifying verified humans\t% of verified Sybil penetration\t15+\t95%\t22%\t25+\t94%\t16%\t50+\t92%\t8%\t75+\t88%\t7%","models-coming-soon#Models coming soon":"The Passport team is also working on adding an aggregate model to this endpoint, and is considering several other models that look at unique humanity and reputation signals for different ecosystems.To request a new model, please fill out this form:\nModel Based Detection feedback form","next-steps#Next Steps":"Learn how to use these models and score thresholds by working through our tutorial, or reviewing our API reference."}},"/building-with-passport/model-based-detection/getting-access":{"title":"Getting access to the MBD API","data":{"":"The Model Based Detection API provides programmatic access to variety of different model-based Sybil detection scores.Once you have your API key, you need to include it with each request you make to the API. This allows Human Passport to identify your app and verify that you are authorized to access the API.\nPlease note:You do not need a Scorer or Scorer ID to use the MBD API.","getting-your-api-key#Getting Your API Key":"Log in to the developer portal: Go to developer.passport.xyz and log in to your account by connecting your wallet.\nNavigate to the API Keys section: After logging in, go to the \"API Keys\" section.\nGenerate an API key: Click on the \"+ Create a Key\" button to generate a unique API key for your account.\nStore your API key securely: Store your API key in a secure place, as it will be used to access the MBD API as well as the Passport API.","next-step#Next step":"Review one of the following pages to learn how you can use your API key with the Model Based Detection API.\nReview the API Reference\nReview the tutorial explaining how to use this score"}},"/building-with-passport/model-based-detection/overview":{"title":"Model Based Detection API [BETA]","data":{"introduction#Introduction":"The new Model Based Detection (MBD) API [BETA] enables partners to protect programs against Sybils in real-time, regardless of whether they have a Passport account or not.This API is designed to return the results of model-based detection methods. It can score any EVM addresses against several different models that analyze transaction history against dozens of different data features to identify if that address is likely Human or Sybil.\nNeed more in-depth analysis?We also offer custom Sybil and reputation data services.To learn more, please fill out this quick form.\nThe current available models include the following:\nAggregate unique humanity model\nEthereum (L1) unique humanity model\nNFT (L1) unique humanity model\nArbitrum unique humanity model\nOptimism unique humanity model\nPolygon unique humanity model\nzkSync unique humanity model\nThis essentially opens up Sybil detection and defense to all EVM wallet addresses, regardless of whether the user has a Passport with verified Stamps or not.This new API is the perfect compliment to the existing Passport API as it offers the following benefits:\nScore any address: Any EVM wallet address can be scored, regardless of whether they have a Passport or not.\nReduced user friction: Users don’t need to do anything to be scored by this endpoint.\nMore difficult for Sybils: When we make adjustments to our Stamp offering and weights, we are essentially providing a roadmap for Sybils, requiring us to make changes periodically which can add friction for users. The model features are hidden from the public, making it more difficult for Sybils to cheat.\nModular verification: Using the MBD API along with the Stamp-based verification approach made available via the Passport API can enable you to provide multiple verification options that reduce user friction for the majority of users while offering an additional verification tool for users who don’t pass the initial check.\nFaster and less impactful iteration cycles: Sybil behavior changes, and so should Passport. While we know updates to our Stamp-based verification are both required and help improve ease and effectiveness, those changes can cause user friction. The model-based verification enables us to tune our the models more frequently without this friction, allowing us to respond to changes in Sybil behavior more quickly.","getting-access#Getting Access":"This API is generally available to all developers today, but you will need to utilize an API key that is required to access the Stamp-based Passport API.Please visit our getting access page to learn how to generate an API key.During the initial beta phase, rate limits will be limited. You can read more in our API Reference.","use-cases#Use cases":"This new API is designed to complement the existing suite of endpoints to offer a comprehensive approach to protecting and understanding your community's constituents.Starting with the MBD API, you can quickly determine if a wallet is a suspected human or Sybil actor. If they are a suspected Sybil (or if we don't have enough data to score them), you can have them utilize our Stamp-based verification to prove their humanness.When thinking about applying this new API, there are two primary use cases that it enables:\nProtecting access: Preventing Sybils and other malicious bots from being able to participate in a variety of different web3 programs.\nData analysis: Analyzing a set of wallet addresses against the Passport Model Based Detection score to identify which wallets are likely Humans or Sybils. You can also get in contact with us to have our team perform more in-depth data analysis around a list of wallet addresses by filling out this form.","recommended-developer-flow-protect-access#Recommended developer flow: Protect access":"Protecting access is Passport’s primary use case. There are many different types of programs that can be protected with Passport, including rewards, governance, community access, marketplace, and communication programs.In this section, we will describe a few different developer flows that can be used to protect access to programs:\nSingle verification using a Model Based Detection score\nDouble verification using a Model Based Detection score and the Unique Humanity Score\nDouble verification using a Model Based Detection score and other verification methods","single-verification-using-mbd#Single verification using MBD":"This is the lightest-weight verification tool available with the current Passport developer tooling.If you’d like to quickly verify if potential participants are likely human or sybil based on the model-based evaluation, this is for you.However, this verification method does not provide a secondary verification option for users, such as crypto beginners. If this is a concern, we recommend that you explore using one of the double verification methods.Technical integration details:\nCollect the wallet address from the user\nPass the wallet address to the GET /passport/analysis/{address} endpoint, which will deliver the specified model score (0-100).\nCompare this score against a predetermined score threshold, and either grant or deny access depending on that evaluation.","double-verification-using-mbd-and-unique-humanity-score#Double verification using MBD and Unique Humanity score":"We've developed a tutorial around this offering: Double Verification with the Model Based Detection and Stamp-based APIsThis verification method will cause the least amount of user friction for the majority of users, while also providing a secondary verification check to users (especially crypto beginners) in case they want to contest an initial check’s rejection.Many users will be able pass the initial MBD check with no user friction, while a portion of them will need to go through the Stamp-based process (in other words, creating a Passport, verifying Stamps, and building up a unique humanity score).Technical integration details:\nCollect the wallet address from the user\nPass the wallet address to the GET /passport/analysis/{address} endpoint, which will deliver the specified model score (0-100).\nCompare this model score against a predetermined score threshold, and either grant access to the user or present the secondary verification method to them, depending on that evaluation.\nAssuming the user didn’t pass primary verification, retrieve the user’s Stamp-based Unique Humanity Score from the Passport API v2 using the GET /v2/stamps/{scorer_id}/score/{address} endpoint.\nEvaluate the Unique Humanity Score against a predetermined score threshold, and will either grant or deny access based on that evaluation.","double-verification-using-mbd-and-other-verification-methods#Double verification using MBD and other verification methods":"This option will look very similar to the previous double verification method, but can utilize a custom Passport scorer and set of Stamps, or a separate 1st or 3rd-party verification system to verify users who weren’t able to pass the initial MBD verification flow.","feedback#Feedback":"We decided to release this API in beta so we can collect feedback as we continue to evolve this new verification method.We are specifically interested in hearing your feedback on the following questions:\nIs this new verification process useful?\nHow might you use this data?\nWhich other models might be useful to you?\nIf we offered multiple models, would you want us to provide an aggregate score?\nIf we expanded the ways you could submit addresses beyond a single address at a time, how would you prefer to provide\nthis input?\nHow important is reducing latency with your use case?\nHow important would it be for you to have access to this data on the blockchain?\nWhich developer flows appeal to you? Did we miss any methods that should have been listed?\nHow did the documentation describe this product?\nIf you have an opinion on any of the above, please fill out the following form:\nModel Based Detection feedback form","next-steps#Next steps":"You can retrieve a model-based score with a simple API request. Try it out using our API playground tool.One of our recomended flows is to use double verification with both the MBD API and the Stamp-based Passport API. We have provided a walkthrough tutorial to show you how it's done.Review technical details within the API Reference to understand what all is available via this API.Review our page that describes all available models and recommended score thresholds."}},"/building-with-passport/model-based-detection/tutorials/double-verification":{"title":"Double Verification with the Model Based Detection and Stamp-based APIs","data":{"":"Please note:This tutorial uses the Passport API v1. We recommend using Passport API v2 for new projects.We plan to update this tutorial to use Passport API v2 shortly.\nThis tutorial will walk you through verifying an EVM account with both the ETH Activity model (model-based detection) and the Stamp-based method in your application.The ETH activity model is one of the available machine learning models trained on known Sybil and human EVM account data that examines the transaction history for a given Ethereum address and assigns it a trust score. While this tutorial explains how to use the ETH activity model score, you can easily use any of the other available models instead.Passport exposes an API endpoint that accepts an Ethereum account as a query parameter and returns scores between 0 (likely Sybil) and 100 (likely human), having run one of the model remotely on the Passport server.The model itself is a black box whose outcome is based on 50+ features. Some applications may be happy to rely on these models alone; however, it is advisable to offer the Stamp-based verification method as a fallback to support those users who might not have had the chance to build up a strong account history, such as crypto beginners or experts who utilize multiple wallets for different activities.","prerequisites#Prerequisites":"Before we delve into this, it's important to note that there are a few preliminary steps you need to complete in order to use the Model Based Detection and Passport API. Please ensure that these prerequisites are met before proceeding with the guide.\nYou have created a Passport Scorer and received a Scorer ID (for the Passport API)\nYou have an API key (for both)\nIf you haven't completed the preliminary steps above please refer to our getting access guide first. Once you're done with that, return here and continue with this walkthrough.","the-app#The app":"This tutorial will guide you through creating a very simple app using nextjs.The app will present you with three buttons:\nConnect: use this to connect your Ethereum wallet to the app.\nCheck Ethereum Activity: clicking this button will check your Ethereum activity score. If it is above a threshold then you will see a notice of success - you may proceed to access the protected content! If you do not meet the threshold you will be denied access and directed to check your Passport unique humanity score (Stamp-based) instead.\nCheck Passport score: clicking this button checks your Passport score on the Passport API. If your score is above a threshold then you will be allowed to proceed to the protected content!","getting-started#Getting started":"We'll create an app using Nextjs. We can bootstrap using create-next-app. This automatically creates all the necessary subdirectories, configuration and boilerplate code required to get us building as quickly as possible.Start by entering the following command into your terminal:\nnpx create-next-app ethereum-activity-app\nThis will create a new directory called ethereum-activity-app and populate it with several sub-directories and files that form the skeleton of our app. create-next-app will ask for yes/no responses to a series of configuration questions - answer as follows:\nnpx create-next-app ethereum-activity-app\n✔ Would you like to use TypeScript with this project? … Yes\n✔ Would you like to use ESLint with this project? … Yes\n✔ Would you like to use Tailwind CSS with this project? … No\n✔ Would you like to use `src/` directory with this project? … No\n✔ Would you like to use experimental `app/` directory with this project? …Yes\n✔ What import alias would you like configured? … @/*\nNext, change to the new ethereum-activity-app directory and install ethers:\nnpm install ethers\nThis tutorial will also use Chakra-UI for styling, so install it using npm:\nnpm i @chakra-ui/react @emotion/react @emotion/styled framer-motion\nReplace the contents of app/page.tsx with the following boilerplate code (this includes all the very basic logic to render a page and connect a wallet to the app and the logic required to check a Passport - if you need a refresher on the Passport API logic you can visit our dedicated tutorials):\n'use client'\nimport { useState, useEffect } from 'react'\nimport { ethers } from 'ethers'\nimport { ChakraProvider, Button, Flex, Heading } from '@chakra-ui/react'\nconst APIKEY = process.env.NEXT_PUBLIC_GC_API_KEY\nconst SCORERID = process.env.NEXT_PUBLIC_GC_SCORER_ID\nconst SUBMIT_PASSPORT_URI = 'https://api.scorer.gitcoin.co/registry/submit-passport'\nconst SIGNING_MESSAGE_URI = 'https://api.scorer.gitcoin.co/registry/signing-message'\nconst PASSPORT_THRESHOLD = 20\nconst headers = APIKEY ? ({\n  'Content-Type': 'application/json',\n  'X-API-Key': APIKEY\n}) : undefined\nexport default function Passport() {\n  // here we deal with any local state we need to manage\n  const [address, setAddress] = useState<string>('')\n  const [passportScore, setPassportScore] = useState<string>('')\n  const [isPassportScoreAboveThreshold, setIsPassportScoreAboveThreshold] = useState<boolean>(false)\n  const [isPassportChecked, setIsPassportChecked] = useState<boolean>(false)\n  useEffect(() => {\n    checkConnection()\n    async function checkConnection() {\n      try {\n        const provider = new ethers.BrowserProvider(window.ethereum)\n        const accounts = await provider.listAccounts()\n        // if the user is connected, set their account\n        if (accounts && accounts[0]) {\n          setAddress(accounts[0].address)\n        }\n      } catch (err) {\n        console.log('not connected...')\n      }\n    }\n  }, [])\n  async function connect() {\n    try {\n      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })\n      setAddress(accounts[0])\n    } catch (err) {\n      console.log('error connecting...')\n    }\n  }\n  async function getSigningMessage() {\n    try {\n      const response = await fetch(SIGNING_MESSAGE_URI, {\n        headers\n      })\n      const json = await response.json()\n      return json\n    } catch (err) {\n      console.log('error: ', err)\n    }\n  }\n  async function getPassportScore() {\n    setPassportScore('')\n    const GET_PASSPORT_SCORE_URI = `https://api.scorer.gitcoin.co/registry/score/${SCORERID}/${address}`\n    try {\n      const response = await fetch(GET_PASSPORT_SCORE_URI, {\n        headers\n      })\n      const passportData = await response.json()\n      if (passportData.score) {\n        // if the user has a score, round it and set it in the local state\n        const roundedScore = Math.round(passportData.score * 100) / 100\n        setPassportScore(roundedScore.toString())\n        if (roundedScore > PASSPORT_THRESHOLD) {\n          setIsPassportScoreAboveThreshold(true)\n        } else {\n          setIsPassportScoreAboveThreshold(false)\n        }\n        console.log(\"PASSPORT SCORE = \", roundedScore)\n      } else {\n        // if the user has no score, display a message letting them know to submit thier passporta\n        console.log('No score available, please add Stamps to your Passport and then resubmit.')\n      }\n    } catch (err) {\n      console.log('error: ', err)\n    }\n  }\n  const styles = {\n    main: {\n      width: '900px',\n      margin: '0 auto',\n      paddingTop: 90\n    }\n  }\n  return (\n    /* this is the UI for the app */\n    <div style={styles.main}>\n      <ChakraProvider>\n        <Flex minWidth='max-content' alignItems='center' gap='2' justifyContent='right'>\n          <Button colorScheme='teal' variant='outline' onClick={connect}>Connect Wallet</Button>\n          <Button colorScheme='teal' variant='outline' onClick={checkEthereumActivity}>Check Ethereum Activity</Button>\n          <Button colorScheme='teal' variant='outline' onClick={checkPassport}>Check Passport</Button>\n        </Flex>\n        <br />\n        <br />\n        <Heading>Welcome to Passport! </Heading>\n        <br />\n        <br />\n      </ChakraProvider >\n    </div >\n  )\n}","adding-the-etheruem-activity-scorer#Adding the Etheruem Activity scorer":"The ETH activity scorer is accessed via a public API endpoint passing the user's Ethereum address as a query parameter. To start integrating this into your app, you can add the base URL  for the API endpoint as a constant at the top of the script, just below the Passport URI definition.\nconst ETHEREUM_ACTIVITY_SCORE_URI = 'https://api.passport.xyz/v2/models/score/'\nconst ETHEREUM_SCORE_THRESHOLD = 50;\nNext, we will want to track the score, and the status of your API requests in the application state. You can add one state variable to store the score retrieved from the API (a string), one to track whether a request has been made to the Model Based Detection API (a boolean) and one to track whether the retrieved ETH activity score exceeds the threshoild (a boolean). Add the following state variable definitions beneath the existing state variable definitions in the boilerplate code:\n  const [ethereumScore, setEthereumScore] = useState<string>('')\n  const [isEthereumScoreAboveThreshold, setIsEthereumScoreAboveThreshold] = useState<boolean>(false)\n  const [isEthereumActivityChecked, setIsEthereumActivityChecked] = useState<boolean>(false)\nNext, we can write some async functions that handle the request itself. We will write one function for the API request and another that wraps the API request and updates the appropriate state variables.Start with the API request. You can call this function getEthereumScore(). Inside the function, first clear the existing ethereumScore variable, then make the API request. There is some parsing out of the score from the response object to handle. The score can be passed to setEthereumScore() to update the application state. Add some basic error handling, and the function looks as follows:\n  async function getEthereumScore() {\n    setEthereumScore('')\n    const GET_ETHEREUM_ACTIVITY_SCORE_URI = ETHEREUM_ACTIVITY_SCORE_URI + address\n    try {\n      const response = await fetch(GET_ETHEREUM_ACTIVITY_SCORE_URI, {\n        headers\n      })\n      const ethereumData = await response.json()\n      if (ethereumData.details.models.ethereum_activity.score) {\n        const score = ethereumData.details.models.ethereum_activity.score\n        console.log(\"ETHEREUM SCORE = \", score)\n        // if the user has a score, round it and set it in the local state\n        setEthereumScore(score.toString())\n      } else {\n        // if the user has no score, display a message letting them know to submit thier passporta\n        console.log('No score available, please add Stamps to your Passport and then resubmit.')\n      }\n    } catch (err) {\n      console.log('error: ', err)\n    }\n  }\nNext we can write a light wrapper around getEthereumScore() called checkEthereumActivity. This wrapper will call getEthereumScore() and once it receives a response it will check whether the returned value exceeds the threshold and update the isEthereumActivityChecked variable to true.\n  async function checkEthereumActivity() {\n    try {\n      await getEthereumScore()\n      if (parseInt(ethereumScore) > ETHEREUM_SCORE_THRESHOLD) {\n        setIsEthereumScoreAboveThreshold(true)\n      }\n      else {\n        setIsEthereumScoreAboveThreshold(false)\n      }\n      setIsEthereumActivityChecked(true)\n    }\n    catch {\n      throw new Error('error fetching Ethereum activity score')\n    }\n  }\nThat's it! All the logic required to check the user's ETH activity score has been defined in your app. All that is left to do is to call these functions from the app UI.The following code adds some conditional logic to the UI. The Ethereum activity has to be checked first. If the Ethereum activity score exceeds the threshold the app displays a success message. If the score is below the threshold it prompts the user to check their Passport score using the Passport API. If neither are successful, it displays a failure message.Add the following code as the final content inside the <div> provided in return statement in the boilerplate code.\n        {!isEthereumActivityChecked &&\n          <div>\n            <p><b>Welcome to our application!</b></p>\n            <br />\n            <p>Please check your Ethereum activity score. </p>\n            <p> If your score is above the threshold - you may proceed! </p>\n          </div>}\n        {isEthereumActivityChecked && isEthereumScoreAboveThreshold &&\n          <div>\n            <p>Congratulations! Your Ethereum score is {ethereumScore}.</p>\n            <p> This is above the threshold - you may proceed! </p>\n          </div>\n        }\n        {isEthereumActivityChecked && !isEthereumScoreAboveThreshold &&\n          <div>\n            <p>Your Ethereum score is {ethereumScore}.</p>\n            <p> Unfortunately your score is too low to proceed! </p>\n            <br />\n            <p> Please submit your Passport instead. </p>\n          </div>\n        }\n        {isEthereumActivityChecked && isPassportChecked && !isEthereumScoreAboveThreshold && !isPassportScoreAboveThreshold &&\n          <div>\n            <p>Your Passport unique humanity score is {passportScore}.</p>\n            <p> Unfortunately your score is still too low to proceed.</p>\n            <br />\n            <p> Please go to the Passport app and add Stamps to improve your score. </p>\n          </div>\n        }\n        {isEthereumActivityChecked && isPassportChecked && !isEthereumScoreAboveThreshold && isPassportScoreAboveThreshold &&\n          <div>\n            <p>Your Passport score is {passportScore}.</p>\n            <p> Unfortunately your score is still too low to proceed! </p>\n            <br />\n            <p> Please add Stamps to your Passport to improve your score. </p>\n          </div>\n        }\n        {isEthereumActivityChecked && isPassportChecked && !isEthereumScoreAboveThreshold && isPassportScoreAboveThreshold &&\n          <div>\n            <p> Your Passport score is {passportScore}.</p>\n            <p> This is above the threshold. You may proceed!</p>\n          </div>\n        }","run-and-test-the-app#Run and test the app":"You can start this app now by navigating your terminal to the project directory (passport-app) and running npm run dev. Then, navigate your browser to localhost:3000. You will see a basic app load in the browser, with buttons that enable you to connect your wallet and submit your Passport to the registry. You can go ahead and test that the Connect and Submit Passport buttons are working as expected.Your app should look like this:"}},"/building-with-passport/passport-api-v1/api-reference":{"title":"Passport API v1 -- API reference","data":{"":"Please note:In November 2024, we soft-launched Passport API v2.We have not announced any deprecation or retirement timelines for v1 yet, but do strongly recommend using v2 moving forward.You can learn more about the differences between v1 and v2 via our migration guide.\nThe Passport API enables developers to retrieve Human Passport scores and Stamp metadata for users who have created a Passport.You can also experiment with the Passport API using our API playground tool and adding your API keys via the 'Authorize' button.","authentication#Authentication":"To access the Passport API, you will need a Scorer ID and an API key.To make a successful request, you will need to include your API key in the \"Authorization\" header of each API request. The header should have the following format:\n\"X-API-KEY: {API_key}\"\nReplace {API_key} with your API key. For example, if you were using cURL, your request might look something like this:\ncurl --request GET 'https://api.scorer.gitcoin.co/registry/signing-message' \\\n    --header 'X-API-KEY: VwUi___.0yQU1HIAE4hLEMkVs___'","rate-limits#Rate limits":"Your API key will allow you to make up to a certain number of requests to any of the endpoints included on this page during a certain period of time.Requests made to the Passport API v1 and v2 count towards the same rate limit.You will start off with Tier 1, and will need to request higher rate limits if necessary.\nTier\tRate limit\tTier 1\t125 requests per 15 minutes\tTier 2\t350 requests per 15 minutes\tTier 3\t2000 requests per 15 minutes\tTier 4\t2000+ requests per 15 minutes","key-concepts#Key concepts":"There are several key concepts you should be aware of when using the Passport API:\nTimeouts: The Passport API endpoints have a timeout of 60 seconds. This means that if a request to one of these endpoints does not receive a response within 60 seconds, the request will be aborted. If your request times out, you should set up retry logic by calling the API again after a short delay, typically increasing the delay for each subsequent retry.\nPagination: Some requests return a large amount of data. To effectively retrieve this data, you will need to paginate the response. For more information, see API pagination.\nData dictionary: We have put together a data dictionary that you can use to better understand each field that delivers with the response payloads from the Passport API endpoints.","available-endpoints#Available endpoints":"To get a Passport score from an ETH address, follow these steps:\nOptional: Retrieve a signing message\nGET /registry/signing-message\nSubmit and retrieve latest score for a single address\nPOST /registry/submit-passport\nRetrieve previously submitted score for a single address\nGET /registry/score/{scorer_id}/{address}\nRetrieve previously submitted scores of all submitted addresses\nGET /registry/score/{scorer_id}\nUse the following endpoints to receive Stamps data:\nRetrieve Stamps verified by a single address\nGET /registry/stamps/{address}\nRetrieve all Stamps available in Passport\nGET /registry/stamp-metadata\nUse the following endpoint to receive staking information\nRetrieve GTC staking amounts\nGET /registry/gtc-stake/{address}","retrieve-a-signing-message#Retrieve a signing message":"This optional endpoint returns a message verifying the agreement to submit a wallet address for scoring, and a nonce that can be used to verify the authenticity of the signed message.You don't need to get a signature from this endpoint, but you do need a signature from the wallet you are scoring that proves that the user owns the wallet.\nGET /registry/signing-message\ncurl --request GET \\\n    --url https://api.scorer.gitcoin.co/registry/signing-message \\\n    --header 'X-API-KEY: {API KEY}'\n{\n    \"message\": \"I hereby agree to submit my address in order to score my associated Human Passport from Ceramic.\\n\\nNonce: {Nonce}\\n\",\n    \"nonce\": \"{Nonce}\"\n}","submit-and-retrieve-latest-score-for-a-single-address#Submit and retrieve latest score for a single address":"This is the primary endpoint that integrators should use.This endpoint will submit the Passport to the scorer, and return the latest score and Stamp data for a single address. It will always return the most updated score and Stamp data, so resubmitting a user's address will refresh their score.\nPOST /registry/submit-passport","json-body-parameters#JSON body parameters":"Name\tType\tRequired\tDescription\taddress\tText\tYes\tThe wallet address\tscorer_id\tText\tYes\tThe Scorer ID\tsignature\tText\tNo\tSignature received from the wallet\tnonce\tText\tNo\tNonce generated in the signing message. This is needed for requiring a signature before scoring.\t\ncurl --request POST \\\n  --url https://api.scorer.gitcoin.co/registry/submit-passport \\\n  --header 'X-API-KEY: {API KEY}' \\\n  --header 'Content-Type: application/json' \\\n  --data '{\n    \"address\": \"{ADDRESS}\",\n    \"scorer_id\": \"{SCORER ID}\",\n    \"signature\": \"{SIGNATURE - OPTIONAL)\",\n    \"nonce\": \"{NONCE - OPTIONAL}\"\n  }'","sample-responses#Sample responses":"The name in the parenthesis represents what type of Scorer you are using.\n{\n    \"address\": \"{address}\",\n    \"score\": \"{score}\",\n    \"status\": \"DONE\",\n    \"last_score_timestamp\": \"{last_score_time}\",\n    \"expiration_date\": \"{expiration_time}\",\n    \"evidence\": null,\n    \"error\": null,\n    \"stamp_scores\": {\n      \"Ens\": \"2.2\",\n      \"NFT\": \"0.69\",\n      \"Google\": \"2.25\"\n      ...\n    }\n}\n{\n    \"address\": \"{address}\",\n    \"score\": \"{score}\",\n    \"status\": \"DONE\",\n    \"last_score_timestamp\": \"{timestamp}\",\n    \"expiration_date\": \"{expiration_time}\",\n    \"evidence\": {\n        \"type\": \"ThresholdScoreCheck\",\n        \"success\": true,\n        \"rawScore\": \"{score}\",\n        \"threshold\": \"15.00000\"\n    },\n    \"error\": null,\n    \"stamp_scores\": {\n      \"Ens\": \"2.2\",\n      \"NFT\": \"0.69\",\n      \"Google\": \"2.25\"\n      ...\n    }\n}","retrieve-previously-submitted-score-for-a-single-address#Retrieve previously submitted score for a single address":"You must submit a Passport to be scored via the Submit for scoring endpoint before successfully receiving that score via this endpoints.Use this endpoint to retrieve the last submitted score for one Ethereum address.You can use the multiple address endpoint if you'd like to retrieve the latest submitted scores for all addresses that have been submitted to the scorer using the POST endpoint.\nGET /registry/score/{scorer_id}/{address}\ncurl --request GET \\\n    --url https://api.scorer.gitcoin.co/registry/score/{scorer_id}/{address} \\\n    --header 'X-API-KEY: {API KEY}'\n{\n  \"items\": [\n      {\n          \"address\": \"{wallet}\",\n          \"score\": \"{score}\",\n          \"status\": \"DONE\",\n          \"last_score_timestamp\": \"{timestamp}\",\n          \"expiration_date\": \"{expiration_time}\",\n          \"evidence\": null,\n          \"error\": null,\n          \"stamp_scores\": {\n            \"Ens\": \"2.2\",\n            \"NFT\": \"0.69\",\n            \"Google\": \"2.25\"\n            ...\n          }\n      }\n  ]\n}        \nAPI users may find the scores returned by registry/score sometimes differs from the score displayed in the app. If this happens, simply refresh the Passport score by making a POST request to resubmit/refresh the address's score.","retrieve-previously-submitted-scores-of-all-submitted-addresses#Retrieve previously submitted scores of all submitted addresses":"You must submit a Passport to be scored via the Submit for scoring endpoint first.Use this endpoint to retrieve the last submitted score for all Ethereum addresses that have been submitted (POST endpoint) to your scorer.\nGET /registry/score/{scorer_id}","query-parameters#Query parameters":"Name\tRequired\tText\tlast_score_timestamp_gt\tNo\tFilters response to only those scores submitted to the given Scorer instance *after* the given timestamp. Format: ISO 8601\tlast_score_timestamp_gte\tNo\tFilters response to only those scores submitted to the given Scorer instance *after or at* the given timestamp. Format: ISO 8601\tlimit\tNo\tPaginates response, providing the given number of response elements per page. Learn more about pagination.\toffset\tNo\tFor a paginated response, offset determines the Stamp object at which the response should start. Learn more about pagination.\t\ncurl --request GET \\\n    --url https://api.scorer.gitcoin.co/registry/score/{scorer_id} \\\n    --header 'X-API-KEY: {API KEY}'\n{\n    \"items\": [\n        {\n            \"address\": \"{wallet}\",\n            \"score\": \"{score}\",\n            \"status\": \"DONE\",\n            \"last_score_timestamp\": \"{timestamp}\",\n            \"expiration_date\": \"{expiration_time}\",\n            \"evidence\": null,\n            \"error\": null,\n            \"stamp_scores\": {\n              \"Ens\": \"2.2\",\n              \"NFT\": \"0.69\",\n              \"Google\": \"2.25\"\n              ...\n            }\n        },\n        {\n            \"address\": \"{wallet}\",\n            \"score\": \"{score}\",\n            \"status\": \"DONE\",\n            \"last_score_timestamp\": \"{timestamp}\",\n            \"expiration_date\": \"{expiration_time}\",\n            \"evidence\": null,\n            \"error\": null,\n            \"stamp_scores\": {\n              \"Ens\": \"2.2\",\n              \"NFT\": \"0.69\",\n              \"Google\": \"2.25\"\n              ...\n            }\n        }\n    ],\n    \"count\": 2\n}\nYou can also add a query to return all the last submitted scores for a given address based on the timeperiod that you submitted their address to the scorer.The two possible query parameters are last_score_timestamp_gt and last_score_timestamp_gte.\nlast_score_timestamp_gt (standing for 'greater than'): This parameter returns the address' last submitted scores that were submitted to your scorer instance after the specified time.\nlast_score_timestamp_gt (standing for 'greater than or equal'): This parameter returns the address' last submitted scores that were submitted to your scorer instance after or at the same time as the specified time.\nFor example:\ncurl --request GET \\\n    --url https://api.scorer.gitcoin.co/registry/score/{scorer_id}?address={address}?last_score_timestamp_get=2023-07-20T19%3A54%3A44.463335%2B00%3A00 \\\n    --header 'X-API-KEY: {API KEY}'","retrieve-stamps-verified-by-a-single-address#Retrieve Stamps verified by a single address":"Use this endpoint to request all Stamps that have been verified by the specified Ethereum address.If you would like to retrieve the metadata for all available Stamps, please use the Get Stamps metadata endpoint.\nGET /registry/stamps/{address}","query-parameters-1#Query parameters":"Name\tRequired\tText\tinclude_metadata\tNo\tReturns optional metadata object with additional details about connected Stamps.\tlimit\tNo\tPaginates response, providing the given number of Stamps per page (For example, use limit=3 to request three Stamps) Learn more about pagination.\t\ncurl --request GET \\\n    --url 'https://api.scorer.gitcoin.co/registry/stamps/{address}?include_metadata=true' \\\n    --header 'X-API-KEY: {API KEY}'\n{\n  \"next\": \"string\",\n  \"prev\": \"string\",\n  \"items\": [\n    {\n      \"version\": \"string\",\n      \"credential\": {},\n      \"metadata\": {}\n    }\n  ]\n}","retrieve-all-stamps-available-in-passport#Retrieve all Stamps available in Passport":"Use this endpoint to request all Stamps available on Passport.If you would like to retrieve just the Stamps that are connected to a specified Ethereum address, please use the Get Stamps endpoint.\nGET /registry/stamp-metadata\ncurl --request GET \\\n    --url https://api.scorer.gitcoin.co/registry/stamp-metadata \\\n    --header 'X-API-KEY: {API KEY}'\n[\n  {\n    \"id\": \"string\",\n    \"icon\": \"string\",\n    \"name\": \"string\",\n    \"description\": \"string\",\n    \"connectMessage\": \"string\",\n    \"groups\": [\n      {\n        \"name\": \"string\",\n        \"stamps\": [\n          {\n            \"name\": \"string\",\n            \"description\": \"string\",\n            \"hash\": \"string\"\n          }\n        ]\n      }\n    ]\n  }\n]","retrieve-gtc-staking-amounts#Retrieve GTC staking amounts":"This endpoint has been deprecated, as it was built around the legacy GTC staking application.We are planning on releasing a new version of the GTC staking endpoint. Please fill out the following form to help us prioritize this new endpoint in our roadmap:https://forms.gle/VbDBNTvb99emaSUV9This endpoint returns both self (stakes) and community (xstakeAggregates) staking amounts for a specified address and round. It also breaks down staking amounts based on round ID.Our round IDs correspond to the different Gitcoin Grants rounds, and can be found at the following link:\nRound IDs\nGET /registry/gtc-stake/{address}/{round_id}\ncurl --request GET \\\n    --url https://api.scorer.gitcoin.co/registry/gtc-stake/{address}/{round_id} \\\n    --header 'X-API-KEY: {API KEY}'\n{\n  \"users\": [\n    {\n      \"stakes\": [\n        {\n          \"stake\": \"string\",\n          \"round\": {\n            \"id\": \"string\"\n          }\n        },\n        {\n          \"stake\": \"string\",\n          \"round\": {\n            \"id\": \"string\"\n          }\n        }\n      ],\n      \"xstakeAggregates\": [\n        {\n          \"total\": \"string\",\n          \"round\": {\n            \"id\": \"string\"\n          }\n        }\n      ]\n    }\n  ]\n}\nIf you have questions about the API you can ask them in our developer support channel."}},"/building-with-passport/passport-api-v1/overview":{"title":"Passport API v1 overview","data":{"":"Please note:In November 2024, we soft-launched Passport API v2.We have not announced any deprecation or retirement timelines for v1 yet, but do strongly recommend using v2 moving forward.You can learn more about the differences between v1 and v2 via our migration guide.","available-v1-endpoints#Available v1 endpoints":"Endpoint action\tEndpoint\tRetrieval of signing messages\tGET /registry/signing-message\tSubmitting Passports for scoring or refresh\tPOST /registry/submit-passport\tRetrieval of scores for one address\tGET /registry/score/{scorer_id}/{address}\tRetrieval of scores for multiple addresses\tGET /registry/score/{scorer_id}\tRetrieval of Stamps linked to Passports\tGET /registry/stamps/{address}\tRetrieval of all available Stamps\tGET /registry/stamp-metadata\tRetreival of community staking amounts\tGET /registry/gtc-stake/{address}\t\nLearn more about each of these endpoints on our API Reference page.","next-steps#Next steps":"Learn more about the Passport API v1:\nAPI reference\nData dictionary"}},"/building-with-passport/passport-api-v1/tutorials":{"title":"Tutorials (v1)","data":{"":"This section includes several tutorials for integrating Human Passport into your apps with v1 of the API.\nGating access with Passport scores\nRetrieve Passport data and display it to your UI\nHow to retrieve, handle and display Stamp metadata in a simple app\nRequiring a Passport score for airdrop claim\nIntegrating onchain Stamp data using smart contracts\nPlease note:In November 2024, we soft-launched Passport API v2.We have not announced any deprecation or retirement timelines for v1 yet, but do strongly recommend using v2 moving forward.We are actively working on updating the v1 tutorials to use v2.You can learn more about the differences between v1 and v2 via our migration guide.","where-to-start#Where to start":"If you are taking your first steps into building apps with the Passport API, please make sure to use Passport API v2. All of the below tutorials are still using v1 of the API.If you need additional support or you have questions about developing with Passport, you can chat in our dedicated developer support channel on Telegram.","tutorials#Tutorials":"","gating-access-with-passport-scores#Gating access with Passport scores":"This tutorial will guide you through building a simple \"knowledge hub\" app with some specific content that can only be accessed by users with a Passport score above a threshold.\nRead more about thresholds on the scoring thresholds page.The app is built using Next.js, Chakra-ui, and ethers.","integrating-stamps-and-scores#Integrating Stamps and scores":"This tutorial will guide you through building a simple app that shows whether a user is \"trusted\" or not based upon their Passport score and ownership of specific Stamps. Multiple users can connect to the app and the Stamps they own are displayed in the app's UI.The app is built using Next.js, Chakra-ui, and ethers.","how-to-retrieve-handle-and-display-stamp-metadata-in-a-simple-app#How to retrieve, handle and display Stamp metadata in a simple app":"This tutorial will guide you through building a simple app that displays the Stamps that are connected to a specified wallet and Passport.The app is built using Next.js, Chakra-ui, and ethers.","requiring-a-passport-score-for-airdrop-claim#Requiring a Passport score for airdrop claim":"This guide demonstrates using Passport scores to shield your airdrop from airdrop farmers and other bad actors.This app is built using Next.js, RainbowKit, and wagmi.","how-to-integrate-onchain-passport-data-using-smart-contracts#How to integrate onchain Passport data using smart contracts":"Please note that this tutorial is not related to the Passport API, and instead uses the Passport smart contract stack.This tutorial will guide you how to show different content to users depending on their Passport data, all pulled from the blockchain.The app is built using Next.js, Chakra-ui, and ethers."}},"/building-with-passport/passport-api-v1/data-dictionary":{"title":"Data dictionary (v1)","data":{"":"Please note:In November 2024, we soft-launched Passport API v2.We have not announced any deprecation or retirement timelines for v1 yet, but do strongly recommend using v2 moving forward.You can learn more about the differences between v1 and v2 via our migration guide.\nOn this page you will find definitions and explanations for the data types used in the Human Passport stack. The Scorer, Stamp , Credential and Stamp-metadata objects require the most explanation so they are handled separately here. Other types found across the Passport stack are defined in \"Other data\".","the-scorer-object#The Scorer object":"Value\tType\tDescription\tHow to use\taddress\tstring\tThe string of 20 bytes that uniquely identify an Ethereum account\tIdentifies a specific account to be scored\tscore\tstring\tThe registry/score endpoint returns a string that should be parsed as a float. It represents the result of adding the weights of all a user's Stamps.\tReturned from registry/score. Can be used to gate access to content.\tstatus\tstring\tShows whether a server request is PROCESSING or DONE.\tIncluded in responses from registry/score\tlast_score_timestamp\tdatetime string\tThe date and time of the previous request made to the Scorer instance. For example, \"2023-04-28T09:35:49.159Z\"\tReturned by the registry/score and registry/submit-passport endpoint\texpiration_date\tdatetime string\tThe date and time that the next upcoming Stamp will expire, which will subsequently reduce the score. To see when each specific Stamp expires, please use the GET /stamps endpoint.\tYou might want to display this score expiration to the user to remind them to return to the Passport app to refresh their score before it expires\tevidence\tstruct\tWhen the binary Scorer is selected, this field is used to explain why the return value was 0 or 1. Specifically, the returned data shows the threshold score required to return 1, and the actual score the Passport received. The current score threshold for a passing score is 20.\tYou can use this to check the reasoning behind a binary Passport score, and understand why a Passport was decided to be Sybil (0) or non-Sybil (1).\terror\tstring\tDescribes any error returned by the server. Refer to the API status and error codes page for more information.\tUsed to understand why a request failed.\tstamp_scores\tstruct\tContains key:value pairs with stamp names as keys and their weights for the scoring algoithm as values.","the-stamp-object#The Stamp object":"Value\tType\tDescription\tHow to use\tcredential\tstruct\tMessage displayed in the Passport Scorer app alongside a button to trigger verification of a specific Stamp See Credentials table below for more details.\tThis is what a Stamp actually comprises. It is associated with an Ethereum address.\titems\tarray<stamp>\tAn array containing data for each individual Stamp.\tEach object in this array represents a specific Stamp.\tmetadata\tstruct\tMetadata is a struct containing id, icon, name, description, and connectMessage fields for each provider and then more granular data for each of the provider's Stamps\tReturned from the registry/stamps endpoint if the qualifier include-metadata=true is also passed. Returned from registry/stamp-metadata for all Stamps\tnext\tstring\tA pointer to the next page of returned data, if the returned data has been paginated.\tYou can use this is a request to access a page and the subsequent page of results for a paginated response. If the value is null you are already seeing all the available information.\tprev\tstring\tA pointer to the preceding page of returned data, if the returned data has been paginated.\tYou can use this is a request to access a page and the previous page of results for a paginated response. If the value is null you are already seeing all the available information.\tversion\tstring\tA version identifier for a Stamp\tReturned for each Stamp from registry/stamps","credentials#Credentials":"A credential is a struct returned in the Stamp object. It has its own sub-fields as follows:\nValue\tType\tDescription\tHow to use\ttype\tstring\tA descriptor that shows what type of credential is present\tCan be used to check that the returned data is of the expected structure for a given credential type. This is usually going to have the value VerifiableCredential.\tproof\tstruct\tA struct containing several fields comprising the proof that a certain action was taken, for example a signed auth token proving that an account was unlocked.\tUsed to verify ownership of a specific Stamp\tissuer\thash\tEach Stamp issuer has a specific identifying hash provided in this field.\tUsed to identify a Stamp issuer\t@context\turl\tLink to the credential definition documentation\tCan be used to access reference documentation for the credential type\tissuanceDate\tdatetime string\tThe date and time that the Stamp was minted. For example, \"2023-04-28T09:35:49.159Z\"\tCan be used to check the age of a Stamp\texpirationDate\tdatetime string\tThe date and time the Stamp should expire. For example, \"2023-04-28T09:35:49.159Z\"\tCan be used to automatically expire a Stamp\tcredentialSubject\tstruct\tContains anonymized information about the user that the Stamp is issued to. This includes a unique ID, a hash, link to the data schema and the Stamp provider name in plaintext.\tCan be used to connect Stamps to a user in a privacy preserving way","stamp-metadata#Stamp metadata":"Value\tType\tDescription\tHow to use\tconnectMessage\tstring\tMessage displayed in the Passport scorer app alongside a button to trigger verification of a specific Stamp\tMainly used in the Passport app, but could be used to provide appropriate message for verification in other contexts\tdescription\tstring\tShort description of what a specific Stamp demonstrates. For example, ownership of >0.5 ETH\tReturned in Stamp metadata, can be used to understand a specific Stamp\tgroups\tstring\tIdentifier for top-level groupings of Stamps for a given provider\tEach provider may issue many Stamps which can be grouped together by theme, for example the Passport Provider groups Stamps by Self GTC-staking and Community GTC-staking\thash\tstring\tA unique hash representing a specific instance of a credential\tUsed to prevent the same Stamp being used multiple times in a specific Scorer instance\ticon\tstring\tA URL for an image to represent each Stamp provider\tReturned in Stamp metadata, can be used to load an icon for a Stamp provider\tid\tstring\tAn identifier for a Stamp\tReturned in Stamp metadata, can be used to scrape data for a specific Stamp\tname\tstring\tName of the provider issuing a given Stamp\tReturned as part of the Stamp metadata, can be used to scrape information for specific providers\tstamps\tarray\tArray containing Stamp structs for each individual Stamp. Each Stamp has name, description and hash fields\tIncluded in Stamp metadata. Used to identify specific instances of individual Stamps","gtc-staking#GTC staking":"Value\tType\tDescription\tusers\tarray\tContains the specified address's staking data, including a stakes object that contains data on how much and when a user staked GTC on themselves, and the xstakeAggregate, which contains data on how much a user has staked on other community members and when.\tstakes\tarray\tContains one or multiple stake objects, which includes data on how much GTC the specified user has staked on themselves. This array will include a different object for each round the user had staked any GTC on themselves.\tstake\tstring\tRepresents the number of GTC the user has staked on themselves in a specified round.\tround\tobject\tContains the ID of the round in which the associated stake amount was staked.\tid\tnumber\tRepresents the round in which the associated stake amount was staked.\txstakeAggregates\tarray\tContains one or multiple stake objects, which includes data on how much GTC the specified user has staked on themselves. This array will include a different object for each round the user had staked any GTC on themselves.\ttotal\tstring\tRepresents the total number of GTC the user staked on community members in a specified round.","other-data#Other data":"Value\tType\tDescription\tHow to use\tAPI-Key\tstring\tAn authorization token generated by the Scorer app giving you access to a Scorer instance on the Passport server.\tInclude this API key as part of your request headers.\tnonce\tint\tA transaction counter for an address that is used in signing to prevent certain types of attack\tThis is an optional field that can be provided to submit-passport for additional verification. Today access to Scorers is controlled using API keys only by default.\tscorer_id\tstring\tScorers are instantiated with unique IDs known as scorer_ids.\tCreate a Scorer in the Scorer app to receive a scorer_id. Then this value links your API requests to a specific Scorer instance matching your API key\tsignature\tstring\tSome workflows require a Scorer owner to demonstrate their ownership by signing a message with the Scorer owner's private key.\tThis is an optional field that can be provided to submit-passport for additional verification. Today access to Scorers is controlled using API keys only by default."}},"/building-with-passport/passport-api-v1/tutorials/client-side-scoring":{"title":"Client-side scoring tutorial","data":{"":"Please note:In November 2024, we soft-launched Passport API v2.We have not announced any deprecation or retirement timelines for v1 yet, but do strongly recommend using v2 moving forward.We are actively working on updating the v1 tutorials to use v2.You can learn more about the differences between v1 and v2 via our migration guide.\nHuman Passport offers several scoring algorithms that can be executed on the Passport servers, such that a numeric score for a Passport can be requested from the Passport API. However, this means you are restricted to Passport's algorithm and Passport's opinion about the relative weighting assigned to each individual Stamp. This might not be appropriate for all use cases.For example, you might have a string preference for certain Stamps that are particularly relevant to your community that you want to weight more strongly in the scoring, or perhaps you have a great idea for a completely new algorithm that you want to implement to gate your app.This tutorial will walk you through developing a custom scorer for your app.","prerequisites#Prerequisites":"Before we delve into this, it's important to note that there are a few preliminary steps you need to complete. Please ensure that these prerequisites are met before proceeding with the guide.\nYou have created a Passport Scorer and received a Scorer ID\nYou have an API key\nIf you haven't completed the preliminary steps above please refer to our getting access guide first. Once you're done with that, return here and continue with this walkthrough.","creating-a-scorer#Creating a Scorer":"","setting-up-a-basic-app#Setting up a basic app":"This tutorial will build on the Stamp Collector app tutorial. You should revisit that tutorial to build the foundations upon which this tutorial will build. You will use that app as a starting point and add scoring functionality on top. Follow the instructions in that tutorial to get the app up and running.You can start the app now by navigating your terminal to the project root directory and running npm run dev. Then, navigate your browser to localhost:3000. You will see the app load in the browser, with buttons that enable you to connect your wallet and check your Stamps. You can go ahead and test that the Connect Wallet and Show Stamps buttons are working as expected.The rest of the tutorial will build upon this basic app by adding functions and UI code to app/page.tsx.","stamps#Stamps":"The app queries the Passport APIs registry/stamps endpoint to retrieve all the Stamps owned by the connected user. The getStamps() function parses the full response and extracts the icon, id, and stamp data into a Stamp object with the following structure:\ninterface Stamp {\n  id: number\n  stamp: string\n  icon: string\n}\nThis information is stored in a state variable, stampArray. This is all the information you need from the Passport API.","scorers#Scorers":"The Human Passport scoring algorithm is a simple sum of weights assigned to each Stamp. The weights are provided in a file on the Passport Github.\nEach weight is a decimal number associated with a specific Stamp name. The scoring algorithm simply iterates over the Stamp names for the Stamps owned by an address, retrieves the associated weights, and adds them together. The result is the user's Passport score.","the-passport-scorer#The Passport Scorer":"You can re-implement the Passport scoring algorithm easily in your app. Start by adding a file containing the Human Passport Stamp weights to your app directory. Copy the contents of this file and paste it into a new file app/stamp-weights.ts.Now, import the data into your app by adding the following import statement to app.ts:\nimport { GITCOIN_PASSPORT_WEIGHTS } from './stamp-weights';\nYou can also add two state variables: one to store the Passport score and one to toggle displaying the score in the UI:\nconst [score, setScore] = useState<number>()\nconst [showScore, setShowScore] = useState<boolean>(false)\nNow, you can create a function to calculate the score. Name the function calculateGitcoinScore() to differentiate from a custom scorer you will create later. Inside, iterate over the Stamps in stampArray. Extract the name (the stamp field) from each Stamp and use it to look up the weight in GITCOIN_PASSPORT_WEIGHTS. Then add those together and log it to the console.\n  function calculateGitcoinScore() {\n    let i = 0\n    var scores: Array<number> = []\n    var score = 0;\n    while (i < stampArray.length) {\n      let id = stampArray[i].stamp\n      if (GITCOIN_PASSPORT_WEIGHTS.hasOwnProperty(id)) {\n        try {\n          let temp_score = GITCOIN_PASSPORT_WEIGHTS[id]\n          scores.push(parseFloat(temp_score))\n        } catch {\n          console.log(\"element cannot be added to cumulative score\")\n        }\n      }\n      i++;\n    }\n    for (let i = 0; i < scores.length; i++) {\n      score += scores[i]\n    }\n    setShowScore(true)\n    setScore(score)\n  }\nAlso add a button to invoke the new function (this can be added immediately after the current button definitions in the UI code, near line 127):\n<Button colorScheme='teal' variant='outline' onClick={calculateGitcoinScore}>Get Score</Button>\nNow add a simple Score component:\nconst Score = () => {\nreturn (\n    <>\n    <p> Your score is {score}</p>\n    </>\n)\n}\nFinally, conditionally render your Score component if showScore is toggled ON. Add the following immediately below {showStamps && <StampCollection />} near line 144.\n<br />\n<br />\n<br />\n{showScore && <Score />}\nNow when you click the Get Score button in your UI, the sentence Your score is X is displayed under your Stamp collection! You can check this against the score given to you by the Human Passport app!","custom-weights#Custom weights":"You can experiment with different weights simply by updating the values in stamp-weights.ts. As a simple demonstration, choose one of the Stamps you own and increase its value in stamp-weights.ts by 10. Next time you click Get Score your Passport Score will have increased by 10 too. You can experiment with weighting models that best serve your app. For example if you value web3 Stamps most strongly, you might increase their weighting relative to web2 Stamps. You can even set some Stamps to zero if you feel they are not relevant for controlling access to your content.","custom-algorithms#Custom algorithms":"You can also implement your own scoring algorithm. To do this, simply create a new function similar to calculateGitcoinScore but implement some new logic in the function body. In this tutorial you will siumply replace the summation of weights with the mean. Later, you might design some complex model to implement.You will repeat the steps from the calculateGitcoinScore(). Start by adding new state variables:\nconst [customScore, setCustomScore] = useState<number>()\nconst [showCustomScore, setShowCustomScore] = useState<boolean>(false)\nNext create a new function, getCustomScore. To update the score from a sum to a mean, you just need to divide the sum by the number of Stamps. You can just add a line to do this at the end of the function. Remember to update the newly created state variables!\n  function calculateCustomScore() {\n    let i = 0\n    var scores: Array<number> = []\n    var score = 0;\n    while (i < stampArray.length) {\n      let id = stampArray[i].stamp\n      if (GITCOIN_PASSPORT_WEIGHTS.hasOwnProperty(id)) {\n        try {\n          let temp_score = GITCOIN_PASSPORT_WEIGHTS[id]\n          scores.push(parseFloat(temp_score))\n        } catch {\n          console.log(\"element cannot be added to cumulative score\")\n        }\n      }\n      i++;\n    }\n    for (let i = 0; i < scores.length; i++) {\n      score += scores[i]\n    }\n    const mean = score / stampArray.length\n    setShowCustomScore(true)\n    setCustomScore(mean)\n  }\nNow create a CustomScore component:\nconst CustomScore = () => {\nreturn (\n    <>\n    <p> Your custom score is {customScore}</p>\n    </>\n)\n}\nAnd a button:\n<Button colorScheme='teal' variant='outline' onClick={calculateCustomScore}>Get Custom Score</Button>\nAnd finally add the conditional rendering to the UI code:\n<br />\n<br />\n<br />\n{showCustomScore && <CustomScore />}\nNow your app has buttons to show the Stamps, get a Passport score and get your custom score. All this information will be displayed in the app's UI.","deduplication#Deduplication":"Please note that scoring on the Passport server includes Stamp deduplication. This means the server automatically detects when the same instance of a Stamp has been submitted more than once to a specific Scorer instance and ignores any duplicates.While it is out of scope for this tutorial, you should implement your own deduplication to accompany a custom scorer.This requires logging the hashes of Stamps and checking that each hash is unique to each individual user.","next-steps#Next Steps":"Now you know how Passport calculates its scores and have seen how to update the logic, you can be creative in implementing algorithms that best serve your community's needs."}},"/building-with-passport/passport-api-v1/tutorials/gating-access-with-passport-scores":{"title":"Protecting access with Passport scores","data":{"":"Please note:In November 2024, we soft-launched Passport API v2.We have not announced any deprecation or retirement timelines for v1 yet, but do strongly recommend using v2 moving forward.We are actively working on updating the v1 tutorials to use v2.You can learn more about the differences between v1 and v2 via our migration guide.\nIn this guide, you'll learn how to protect access to an application using Human Passport. Specifically, you will:\nFetch a score using the Passport API\nExamine best practices for retrieving Passport scores\nImplement protection so that some content is only available to users with scores above a threshold\nRedirect users to instructions for improving their Passport scores\nThis tutorial is a more detailed version of a video tutorial put together by Nader Dabit.\nCheck out his video and related sample code at the following links:","prerequisites#Prerequisites":"To follow this tutorial, you'll need Next.js, Node, and Chakra-UI installed on your machine. We will also be using the Passport API.Before we delve into this, it's important to note that there are a few preliminary steps you need to complete. Please ensure that these prerequisites are met before proceeding with the guide.\nYou have created a Passport Scorer and received a Scorer ID\nYou have an API key\nIf you haven't completed the preliminary steps above please refer to our getting access guide first. Once you're done with that, return here and continue with this walkthrough.","app-outline#App outline":"The app we will build will be an educational site where users can learn about web3 and DAOs, and then if - and only if - their Passport score is above a threshold, they can uncover the secret information required to join our example Passport DAO.You can find the code from this tutorial in this GitHub repo.The app will work as follows:\nWhen the user visits the sample app, they have access to three tabs - one to welcome them and two containing learning material about Web3 and DAOs.\nA fourth tab will contain information about how the user can join your DAO.\nThe user will connect their wallet and Human Passport to the app. Their score will be calculated automatically.\nIf their score meets a threshold, the fourth tab will contain instructions and links that will enable them to join the DAO.\nIf the score does not meet the threshold, we'll withold the instructions and instead the tab will contain instructions for increasing their Passport score.\nThis simple example demonstrates the principles you would use to protect a real app using Human Passport.The app will be built using Next.js and will make use of several of the Scorer API endpoints.","setting-up-the-app#Setting up the app":"We'll create an app using Next.js. We can bootstrap using create-next-app. This automatically creates all the necessary subdirectories, configuration and boilerplate code required to get us building as quickly as possible.Start by entering the following command into your terminal:\nnpx create-next-app passport-app\nThis will create a new directory called passport-app and populate it with several sub-directories and files that form the skeleton of our app. create-next-app will ask for yes/no responses to a series of configuration questions - answer as follows:\nnpx create-next-app my-passport-app\n✔ Would you like to use TypeScript with this project? … Yes\n✔ Would you like to use ESLint with this project? … Yes\n✔ Would you like to use Tailwind CSS with this project? … No\n✔ Would you like to use `src/` directory with this project? … No\n✔ Would you like to use experimental `app/` directory with this project? …Yes\n✔ What import alias would you like configured? … @/*\nNext, change to the new my-passport-app directory and install ethers:\nnpm install ethers\nThis tutorial will also use Chakra-UI for styling, so install it using npm:\nnpm i @chakra-ui/react @emotion/react @emotion/styled framer-motion\nNow, create a new file in my-passport-app and add the following to set the Passport API Key and Scorer ID values (if you need a reminder of how to get the API key and Scorer ID, revisit the Quick Start guide):\nNEXT_PUBLIC_GC_API_KEY=<your-api-key>\nNEXT_PUBLIC_GC_SCORER_ID=<your-scorer-id>\nSave this file as .env.local.","building-the-app#Building the App":"Now that the app is set up, you can begin building. The code that controls what is rendered in the browser is contained in src/app/page.tsx. When you created your project, create-next-app saved a version of page.tsx with some default code. You can delete all the code in page.tsx and replace it with this boilerplate:\n//page.tsx\n'use client'\nimport { useState, useEffect } from 'react'\nimport { ethers } from 'ethers'\nimport { ChakraProvider, Button, Flex, Heading} from '@chakra-ui/react'\nimport { TabLayout } from '../../tab-contents'\nconst APIKEY = process.env.NEXT_PUBLIC_GC_API_KEY\nconst SCORERID = process.env.NEXT_PUBLIC_GC_SCORER_ID\n// endpoint for submitting passport\nconst SUBMIT_PASSPORT_URI = 'https://api.scorer.gitcoin.co/registry/submit-passport'\n// endpoint for getting the signing message\nconst SIGNING_MESSAGE_URI = 'https://api.scorer.gitcoin.co/registry/signing-message'\n// score needed to see hidden message\nconst thresholdNumber = 20\nconst headers = APIKEY ? ({\n  'Content-Type': 'application/json',\n  'X-API-Key': APIKEY\n}) : undefined\ndeclare global {\n  interface Window {\n    ethereum?: any\n  }\n}\nexport default function Passport() {\n  const styles = {\n    main: {\n      width: '900px',\n      margin: '0 auto',\n      paddingTop: 90\n    }\n  }\n  return (\n    /* this is the UI for the app */\n    <div style={styles.main}>\n      <ChakraProvider>\n        <Flex minWidth='max-content' alignItems='right' gap='2' justifyContent='right'>\n        </Flex>\n        <br />\n        <br />\n        <Heading as='h1' size='4xl' noOfLines={2}>Welcome to the decentralized web</Heading>\n        <br />\n        <TabLayout />\n      </ChakraProvider >\n    </div >\n  )\n}\nNotice that you are importing components from three sources: ethers, @chakra-ui/react and a local file 'tab-contents'. The local file does not exist yet so you'll need to create it. Create a file called tab-contents.tsx in src/app. This is where you define the layout of four tabs on your web page and write the content that each tab should contain. You can paste the following code into your tab-contents.tsx and save the file.\n//tab-contents.tsx\nimport React from \"react\"\nimport { Tabs, TabList, TabPanels, Tab, TabPanel } from '@chakra-ui/react'\nconst TabLayout = () => {\n    return (\n        <Tabs>\n            <TabList>\n                <Tab>Home</Tab>\n                <Tab>Learn about Web3</Tab>\n                <Tab>Learn about DAOs</Tab>\n                <Tab>Join the DAO</Tab>\n            </TabList>\n            <TabPanels>\n                <TabPanel>\n                    <Welcome />\n                </TabPanel>\n                <TabPanel>\n                    <WhatIsWeb3 />\n                </TabPanel>\n                <TabPanel>\n                    <WhatAreDaos />\n                </TabPanel>\n                <TabPanel>\n                    <JoinTheDao />\n                </TabPanel>\n            </TabPanels>\n        </Tabs>\n    )\n}\nconst Welcome = () => {\n    return (\n        <>\n            <br />\n            <br />\n            <p>Welcome!!</p>\n            <br />\n            <p>You have arrived at our DAO portal.</p>\n            <p>On this site you can learn some of the fundamentals about Web3 and DAOs.</p>\n            <p>If you are inspired, you can join our DAO!</p>\n            <br />\n            <p>However, DAO membership is only open to people whose Passport score is greater than 20.</p>\n            <p>A Passport score is calculated from the stamps held in your Passport. The more stamps, the higher the score.</p>\n            <br />\n            <p><b>Get started by connecting your wallet and then connecting your Passport</b></p>\n            <p>To add stamps to your Passport, visit the <Link href=\"https://app.passport.xyz\" color='teal.500' isExternal>Passport App</Link>.</p>\n        </>\n    )\n}\nconst WhatIsWeb3 = () => {\n    return (\n        <>\n            <br />\n            <br />\n            <p>There are many definitions of Web3, but they all share some core principles:</p>\n            <br />\n            <li>Decentralization: ownership gets distributed across builders and users, instead of being owned by a few corporations.</li>\n            <li>Permissionlessness: everyone has equal access to participate in Web3, and no one gets excluded.</li>\n            <li>Ownership and Payments: crypto assets are used for transferring value, instead of outdated payment processors.</li>\n            <li>Trustlessness: it operates using incentives and economic mechanisms instead of relying on trusted third-parties.</li>\n            <br />\n            <p>Read more about <Link href=\"https://ethereum.org/web3/\" color='teal.500' isExternal>Web3</Link></p>\n        </>\n    )\n}\nconst WhatAreDaos = () => {\n    return (\n        <>\n            <br />\n            <br />\n            <p>A DAO is a collectively-owned, blockchain-governed organization with a shared mission.</p>\n            <br />\n            <p>DAOs allow us to work with like-minded folks around the globe, sharing responsibility for funds and operations.</p>\n            <p>Instead, blockchain-based rules define how the organization works and how funds are spent.</p>\n            <br />\n            <p>They have built-in treasuries that no one has the authority to access without the approval of the group.</p>\n            <p>Decisions are governed by proposals and voting to ensure everyone in the organization has a voice, and everything happens transparently on-chain.</p>\n            <br />\n            <p> If this sounds good to you, and your Human Passport score is above 20, you can join our DAO!</p>\n        </>\n    )\n}\nconst JoinTheDao = () => {\n    return (\n        <>\n            <br />\n            <p>Hello world!</p>\n            <br />\n        </>\n    )\n}\nexport { TabLayout, WhatIsWeb3, WhatAreDaos, JoinTheDao };\nYou can now run the app to see what the bare bones of your project look like in the browser. Run the following command in your terminal:\nnpm run dev\nNavigate your browser to localhost:3000 to see the app up and running. You should see a welcome message on the Home tab and be able to click through the other tabs to read about Web3 and DAOs. However, notice that this is currently a straightforward static site with no opportunities for connecting an Ethereum wallet or interacting with Human Passport. These are the areas we will focus on for the remainder of the tutorial.","connecting-a-wallet#Connecting a Wallet":"Ethereum wallet connections are handled using ethers. In this section you will call some functions from ethers that allow your users to connect to the app using their Ethereum wallet. This is essential because this allows users to sign messages to approve the use of their address in Passport API requests.First, you already know that the user address is going to be an important piece of data that will be passed in several requests using the Passport API. This means you probably want to keep track of it in the app's state. To do this, you can add the following state variable definition immediately below export default function Passport () {\nconst [address, setAddress] = useState<string>('')\nThis creates a variable address and a function setAddress you can use to update the value of address.Next, you can create a function, connect, that will ask a user to open their wallet and allow the app to connect. In this context, \"connecting\" means that the app can see the user's address, account balance, and suggest transactions to approve.The way MetaMask enables connections to Ethereum is by injecting a provider into the website. The provider exposes an API with methods for relaying information to and from Ethereum. The default behavior is for MetaMask to route requests made using the provider API to Ethereum through its RPC service, Infura, although you can configure it to use any Ethereum node exposing an RPC port (consider using your own node!). To connect a wallet to an app, you need to detect the provider and get the user's accounts.The provider is injected at window.ethereum. API requests can be sent to this provider by calling the request method on the provider and passing the API method you want to use. This is an asynchronous action, so you need to await the result. The following single-line of code detects the provider and requests the user accounts using the eth_requestAccounts method, saving them to the variable accounts:\nconst accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })\nThis is all that is required to connect a wallet to the app, because a lot of complexity is abstracted away behind the provider API call. To turn this into a connect() function suitable for your app, you can wrap the provider API call in try/catch so you can handle any errors. You also want to pull the returned data into your app's state. The API method returns the address in an array. You can pull the address out of the array as a string by specifying accounts[0] and then pass it to the setAddress function you defined earlier. Add the following function to page.tsx immediately below your state variable (const [address, setAddress]) definition.\n  async function connect() {\n    try {\n      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })\n      setAddress(accounts[0])\n    } catch (err) {\n      console.log('error connecting...')\n    }\n  }\nNext, we need to add a button to the UI that a user can use to trigger the connection between the app and their wallet. Near the bottom of the page, in the return statement, you will find a set of <Flex> tags that have nothing between them, immediately following the opening ChakraProvider tag. Insert the following code between the opening and closing <Flex> tags to add a button to the UI:\n<Button colorScheme='teal' variant='outline' onClick={connect}>Connect</Button>\nYou can check this is working by running the app (npm run dev) and clicking connect. This calls your new connect() function. You should see your MetaMask pop open and ask you to connect to the site.Well done! You now have a function that can connect an Ethereum wallet to your app and store the user's address in a state variable!","checking-for-existing-connections#Checking for existing connections":"Your user might have opened your app with their wallet already connected. In this case, the process is slightly different. You do not need the pop-up window in MetaMask for the user to approve the connection, but you do need to grab the address and add it to the app's state. Since the user has already connected, this process does not require any user action - it can be automatic. To make it automatic, you need to use a useEffect hook. useEffect allows you to execute the connection logic when the Passport() component is added to the page. The logic you want to execute is:\nconnect to the provider\ngrab the user address\nadd the user address to the app state\nhandle any errors\nYou can achieve this by adding the following function to your app, next to your connect() function.\n  useEffect(() => {\n    checkConnection()\n    async function checkConnection() {\n      try {\n        const provider = new ethers.BrowserProvider(window.ethereum)\n        const accounts = await provider.listAccounts()\n        // if the user is connected, set their account\n        if (accounts && accounts[0]) {\n          setAddress(accounts[0].address)\n        }\n      } catch (err) {\n        console.log('not connected...')\n      }\n    }\n  }, [])\nWell done - your users can now connect their Ethereum wallet to your app. If they are already connected, their address will be added to your app's state automatically when the app is started. You can check that this is all working properly by running the app (npm run dev) and connecting your wallet.","connecting-to-human-passport#Connecting to Human Passport":"To use Human Passport, a user has to submit their Passport to the registry. This is a database of Passports linked to an Ethereum address that have been submitted for scoring. Part of the data that is passed along with a request to add a Passport to the registry is the Scorer-Id which is used to link your app to a specific instance of the Scorer you created earlier. This data together links your user's address to a specific collection of Stamps and an instance of a Scorer to use to calculate a Passport score. Therefore, this is a necessary step for integrating Passport into your app if you want to use Human Passport's default Scorer and calculate the score server-side. The weights applied to each Stamp can be found in the Passport Github.You can skip the Passport submission and retrieve the raw Stamp data to apply your own scoring algorithm.The way Passport submission works is to first retrieve a message using the Passport API's signing-message method. The user then signs this message using their Ethereum wallet, and sends the signed message back to the server using the Passport API's submit-passport method.The boilerplate code already assigns the necessary API endpoints to the variables SIGNING_MESSAGE_URI and SUBMIT_PASSPORT_URI. The following code snippet shows how to write two functions: one to grab the message to sign (getSigningMessage), and one to take that message, sign it, and return it (submitPassport). Successfully executing this logic adds the user's address to the Passport registry and triggers the server to calculate a score based on the Stamps present in the owner's Passport. A step-by-step explanation of each function is provided in comments in the code snippet.Paste the following code into your application below your checkConnection() function.\nasync function getSigningMessage() {\ntry {\n    // fetch the message to sign from the server\n    const response = await fetch(SIGNING_MESSAGE_URI, {\n    headers\n    })\n    // convert the response data to a json object\n    const json = await response.json()\n    return json\n} catch (err) {\n    console.log('error: ', err)\n}\n}\nasync function submitPassport() {\ntry {\n    // GET request to the Passport API to get the signing message and the nonce\n    const { message, nonce } = await getSigningMessage()\n    // instantiate a new provider instance\n    const provider = new ethers.BrowserProvider(window.ethereum)\n    // call the provider's `getSigner` API method to start the signing process\n    const signer = await provider.getSigner()\n    // ask the user to sign the message\n    const signature = await signer.signMessage(message)\n    // POST request to the Passport API, sending the signing message, the signature, and the nonce\n    const response = await fetch(SUBMIT_PASSPORT_URI, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify({\n        address,\n        scorer_id: SCORERID,\n        signature,\n        nonce\n    })\n    })\n    // assign the response data to `data` as a json object\n    const data = await response.json()\n    console.log('data:', data)\n} catch (err) {\n    console.log('error: ', err)\n}\n}\nThese functions contain all the logic required for a user to submit their Passport to the registry. However, this is an action that needs to be triggered by the user. We can add another button to the UI that executes the Passport submission when it is clicked. Add the following code to the UI, immediately below the connect button, inside the <Flex> tags:\n<Button colorScheme='teal' variant='outline' onClick={submitPassport}>Submit Passport</Button>\nYou can run the app and check that this works by connecting and submitting your Passport.","getting-a-passport-score#Getting a Passport score":"Your app will show different content depending on the user's Passport score. This means you need to retrieve the user's score and keep track of it in your app's state. First, create a new state variable for tracking your user's score. You can place this immediately below your existing state variable, address:\nconst [score, setScore] = useState<string>('')\nThe Passport score is retrieved from the /registry/score/ API endpoint, passing the SCORER_ID you set earlier and the user's address. The SCORER_ID is already loaded from the environment variables, and the user's address is in the app's state as address. You also need to pass your API key in the request header. The boilerplate code already handled formatting the headers and assigning them to the constant headers. This means all the ingredients are available for retrieving the Passport score. The function below puts the ingredients together and wraps in some error handling code. You can paste this new checkPassport() function into page.tsx immediately below your submitPassport() function.\nasync function getScore() {\n  setScore('')\n  const GET_PASSPORT_SCORE_URI = `https://api.scorer.gitcoin.co/registry/score/${SCORERID}/${address}`\n  try {\n    const response = await fetch(GET_PASSPORT_SCORE_URI, {\n      headers\n    })\n    const passportData = await response.json()\n      if (passportData.score) {\n      // if the user has a score, round it and set it in the local state\n        const roundedScore = Math.round(passportData.score * 100) / 100\n        setScore(roundedScore.toString())\n        console.log(\"PASSPORT SCORE = \", roundedScore)\n      } else {\n      // if the user has no score, display a message letting them know to submit thier passporta\n       console.log('No score available, please add Stamps to your passport and then resubmit.')\n      }\n    } catch (err) {\n      console.log('error: ', err)\n    }\n}\nNotice that there is some additional code included in this snippet for rounding the score to two decimal place precision and converting it to a string type before passing it to setScore so that it is captured in the app state.Great! Now you have coded all the logic required to connect a wallet, submit a Passport to the registry and retrieve a Passport score. The getScore() function isn't actually invoked anywhere yet, though. If you want to check this function works correctly, you can add the following button immediately below the other two buttons you added earlier:\n<Button colorScheme='teal' variant='outline' onClick={getScore}>get score</Button>\nClicking this button, after connecting a wallet and submitting a Passport to the registry, will print the following to the console (you can access your console by pressing CTRL + SHIFT + I):\nPASSPORT SCORE = 26.57","notes-on-best-practices-for-scoring#Notes on best practices for scoring":"It is recommended to use the Human Passport default Scorer. For now, this is the only option for server-side score calculations, but you can choose whether you wish the server to return an integer value (0-100) or return a Boolean (0 or 1). This is selected when you create the instance of the Scorer at developer.passport.xyz.If you choose to return an integer value, you can make your own choice about what threshold score to use to gate your content. In this tutorial, you are receiving an integer value from the Scorer API and thresholding it in the app. The threshold is hardcoded into the app with a value of 20. This is thought to be a pretty good general purpose threshold, but you can choose to raise the threshold if you want to be more stringent, or lower it to be more lenient. Picking the right threshold is application-specific and might require some experimentation to get it just right.If you choose to return a binary value, the Passport server will still calculate the Passport score using the exact same algorithm, but it will threshold it server-side and return a 0 if the user's score is below the built-in threshold of 15, or a 1 if the user's score exceeds this threshold.You can also choose to calculate your own Passport score by retrieving raw Stamp data and applying some custom algorithm on them. This provides a lot of flexibility to app builders. However, the major reason server-side calculation is recommended is because Stamp deduplication is included in the score calculation. This means the Passport server ensures that each specific user tamp can only be counted once by your Scorer instance. If you implement your own scoring algorithm, you need to account for Stamp deduplication yourself.","gating-access-using-the-score#Gating access using the score":"Now that you have a way to retrieve the user's Passport score you can use it to adjust the content they can access on your site. Specifically, you want to show different content in the \"Join the DAO\" tab depending on whether the user's Passport score is above some threshold.To start, let's take a look at the content we want to differentiate. Earlier you created a file called tab-contents.tsx that contains all the content that renders inside each tab, and a TabLayout component that controls where that content is displayed. We can update this code so that TabLayout renders a different component depending on the user's Passport score. As a first step, update the JoinTheDao component so that it takes an argument isAboveThreshold. This will be a Boolean (true/false) that will be set to true if the user's score is above some threshold, and false otherwise. You can use this as a signal to render one set of content or another. To start, use the following code to render a new component Content AboveThreshold if isAboveThreshold evaluates to true and ContentBelowThreshold if isAboveThreshold evaluates to false (you will define these new components in the next step).Update the JoinTheDao component in tab-contents.tsx as follows:\nconst JoinTheDao = ({ isAboveThreshold }) => {\n    if (isAboveThreshold) {\n        return (\n            <ContentAboveThreshold />\n        )\n    }\n    else {\n      return (\n            <ContentBelowThreshold />\n        )\n    }\n}\nNow you have a component, JoinTheDao that conditionally renders one of two content types depending on the value of isAboveThreshold which you will tie to the value of the user's Passport later. You now need to define two components that define the content to render in each isAboveThreshold case.Add the following to tab-contents.tsx:\nconst ContentAboveThreshold = () => {\n    return (\n        <>\n            <br />\n            <br />\n            <p>🎉🎉🎉</p>\n            <p><b>Welcome to Passport DAO!</b></p>\n            <br />\n            <p>Passport DAO is a fictional DAO for Passport builders.</p>\n            <p>Passport DAO does not really exist, it is just an example made up for the purposes of this tutorial!</p>\n            <p>However, since you have a Passport with a score > 20 and you have built this demo app, </p>\n            <p>you might enjoy the Passport Developer Telegram, where other Passport builders hang out.</p>\n            <br />\n            <p>Join fellow builders on the <Link href=\"https://t.me/+Mcp9RsRV7tVmYjZh\" color='teal.500' isExternal>Passport Developer Telegram</Link></p >\n            <p></p>\n            <br />\n        </>\n    )\n}\nconst ContentBelowThreshold = () => {\n  return (\n        <>\n            <br />\n            <p>😭😭😭</p>\n            <br />\n            <p>We would love you to join our DAO.</p>\n            <br />\n            <p>Unfortunately, you do not quite meet the eligibility criteria.</p>\n            <p>You can go to the <Link href=\"https://app.passport.xyz\" color='teal.500' isExternal>Passport App </Link> and add more Stamps to your Passport.</p>\n            <p>When you have enough Stamps to generate a score above 20, you can come back and join our DAO!</p>\n            <br />\n            <p>In the meantime you can read our <Link href=\"https://docs.passport.xyz\" color='teal.500' isExternal> awesome documentation </Link> to learn more about Human Passport</p>\n        </>\n    )\n}\nAt this point you have implemented conditional rendering of two components depending on the value of a Boolean whose value switches based on the user's Passport score. There are a few remaining steps to implement in page.tsx to connect up these content components with the user's Passport. First, you are passing isAboveThreshold as an argument to the JoinTheDao component, but it does not exist yet in your app.In page.tsx, add another state variable below setScore as follows:\nconst [isAboveThreshold, setIsAboveThreshold] = useState<Boolean>(false)\nNow this state variable exists, you need to pass it to the JoinTheDao component. You can do this by updating the <TabLayout> tag in the UI code. The tag can be updated so that it looks as follows:\n<TabLayout isAboveThreshold={isAboveThreshold} />\nNow, back in tab-contents.tsx, update the TabLayout component definition so that it takes isAboveThreshold and propagates it into the JoinTheDao sub-component. The TabLayout definition should look as follows:\nconst TabLayout = ({ isAboveThreshold }) => {\n    return (\n        <Tabs>\n            <TabList>\n                <Tab>Home</Tab>\n                <Tab>Learn about Web3</Tab>\n                <Tab>Learn about DAOs</Tab>\n                <Tab>Join the DAO</Tab>\n            </TabList>\n            <TabPanels>\n                <TabPanel>\n                    <Welcome />\n                </TabPanel>\n                <TabPanel>\n                    <WhatIsWeb3 />\n                </TabPanel>\n                <TabPanel>\n                    <WhatAreDaos />\n                </TabPanel>\n                <TabPanel>\n                    <JoinTheDao isAboveThreshold={isAboveThreshold} />\n                </TabPanel>\n            </TabPanels>\n        </Tabs>\n    )\n}\nNext, you need to call the setIsAboveThreshold function to update the value of isAboveThreshold when a Passport score is retrieved. You can do this by invoking setIsAboveThreshold inside getScore, wrapped in an if statement that sets the value to true if the score is greater than the thresholdNumber defined at the top of the script, and false if the score is less than or equal to thresholdNumber. The following conditional statement can be added inside getScore() immediately after setScore(roundedScore.toString()):\nif (roundedScore > thresholdNumber) {\n    setIsAboveThreshold(true)\n} else {\n    setIsAboveThreshold(false)\n}\nCurrently, user scores are only retrieved when the user clicks the \"get score\" button, but really we would like it to be automatic. Delete the get score button from the UI. Now, you can invoke the getScore() function inside the submitPassport() function so that when a user submits their Passport, the score is calculated and the values of score and isAboveThreshold are all updated in the app's state in a single click.Simply add getScore() to submitPassport() immediately after console.log('data:', data) and before the catch statement. Since your Submit Passport button is now doing more than just submitting the Passport, it might be better to give it a more general name. For consistency with the \"Connect Wallet\" button, you can update the button text to \"Connect Passport\".","displaying-the-score#Displaying the score":"Almost there! One final thing - it would be helpful for the user to know their current score so they know how much more progress they need to make to get access to the gated content. To do this, you need to render the score from your app's state in the browser. In this example, you will only show the user their score if it is below the threshold. This helps the user to determine how much they need to improve their score to access your gated content.First, lets add the score as an argument to pass to TabLayout and propagate it from there into the JoinTheDao component and then from there into the ContentBelowThreshold component. Your TabLayout in tab-contents.tsx should look as follows:\nconst TabLayout = ({ isAboveThreshold, score }) => {\n    return (\n        <Tabs>\n            <TabList>\n                <Tab>Home</Tab>\n                <Tab>Learn about Web3</Tab>\n                <Tab>Learn about DAOs</Tab>\n                <Tab>Join the DAO</Tab>\n            </TabList>\n            <TabPanels>\n                <TabPanel>\n                    <Welcome />\n                </TabPanel>\n                <TabPanel>\n                    <WhatIsWeb3 />\n                </TabPanel>\n                <TabPanel>\n                    <WhatAreDaos />\n                </TabPanel>\n                <TabPanel>\n                    <JoinTheDao isAboveThreshold={isAboveThreshold} score={score} />\n                </TabPanel>\n            </TabPanels>\n        </Tabs>\n    )\n}\nThen you need to pass score to JoinTheDao so that the first line of the JoinTheDao definition looks as follows:\nconst JoinTheDao = ({ isAboveThreshold, score }) => {\n...\n}\nThen update the ContentBelowThreshold component so that it takes score as an argument. Then you can add some simple Typescript before the return statement that creates a default string that will be used to warn the user that they don't have a Passport yet if the value of score is equal to its unset value. However, if score has had a value set, it warns the user that their score is not high enough, reporting the actual score in the text. Your final ContentBelowThreshold component should look as follows:\nconst ContentBelowThreshold = ({ score }) => {\n    let text: string = 'Your current Passport score is ${score}'\n    if (score == '') {\n        text = \"You do not yet have a Passport score. Maybe you haven't created or connected your Passport?\"\n    }\n    return (\n        <>\n            <br />\n            <p>😭😭😭</p>\n            <br />\n            <p>We would love you to join our DAO.</p>\n            <br />\n            <p>Unfortunately, you do not quite meet the eligibility criteria.</p>\n            <p> {text} </p>\n            <p>You can go to the <Link href=\"https://app.passport.xyz\" color='teal.500' isExternal>Passport App </Link> and add more Stamps to your Passport.</p>\n            <p>When you have enough Stamps to generate a score above 20, you can come back and join our DAO!</p>\n            <br />\n            <p>In the meantime you can read our <Link href=\"https://docs.passport.xyz\" color='teal.500' isExternal> awesome documentation </Link> to learn more about Human Passport</p>\n        </>\n    )\n}\nFinally, you need to pass the value of score to the TabLayout component in the UI. Back in page,tsx, update <TabLayout ...> as follows:\n<TabLayout isAboveThreshold={isAboveThreshold} score={score} />\n🎉🎉🎉 Congratulations! 🎉🎉🎉You now have a fully functional app! Your user can enter the app, connect their wallet and Passport. If their Passport score is above a threshold, they can see some secret content that shows them how to join a special DAO. If their Passport score is below the threshold they are shown their score and instructed to go get more Stamps.Time to test out your app - start the app using npm run dev and click to connect your wallet and Passport!Here's what your user sees if their Passport score is greater than 20:Here is what your user sees if their Passport Score is lower than 20:","summary#Summary":"This tutorial walked you through building a basic Passport-gated application. You used Next.js to create a simple educational page about Web3 and DAOs, with a special section that invited users to join a secret Passport DAO - but only if their Passport score is above your threshold! By following this tutorial you learned:\nHow to create a Scorer instance and a Passport API key\nHow to use instantiate a provider and call its API\nHow to connect a user's Ethereum wallet to your application and store their address in your app's state\nHow to submit a Passport to the Human Passport registry using the Passport API\nHow to retrieve a user's Passport score using the Passport API\nHow to use the score to conditionally render some content (\"Passport gating\")","further-reading#Further Reading":"For more on Human Passport, you can keep browsing this website, or you can join the Passport Developer Telegram. Having completed this tutorial, a great next step would be to try our \"Integrating Stamps and Scorers\" tutorial where you can learn how to handle individual Stamp data as well as Passport scores."}},"/building-with-passport/passport-api-v1/tutorials/integrating-stamps-and-scorers":{"title":"Integrating Stamps and Scores","data":{"":"Please note:In November 2024, we soft-launched Passport API v2.We have not announced any deprecation or retirement timelines for v1 yet, but do strongly recommend using v2 moving forward.We are actively working on updating the v1 tutorials to use v2.You can learn more about the differences between v1 and v2 via our migration guide.\nHuman Passport can be used to automatically gate applications, but it can also be used as a powerful tool for supporting human decision makers by providing trust information in the app's UI. Instead of blocking access using a score threshold, Human Passport can display trust information about users connected to an app to other users, enabling better informed interactions.","why-would-you-want-a-scorer-integration#Why would you want a Scorer integration?":"There are several apps designed for allocating funding within DAOs. A common model is to divide contributors into teams. The team is funded with a certain budget, and the funds are later distributed to the participants according to the number of reward tokens they are allocated. Individual team members come together to perform some task and later allocate tokens to each other to determine how the funds are released.However, there have been examples of impersonators joining teams, pretending to be one of the legitimate contributors and getting allocated tokens. This is a way attackers can steal from honest participants. Without some additional information, it is hard to know that you are allocating tokens to a real contributor and not an impersonator.A Human Passport Scorer integration is a solution to this problem. By showing the Passport score and Stamps for each user in the app, it is easier to identify the honest participant from their dishonest double. When faced with two instances of one contributor that you want to allocate tokens to, you might check to see which one has a certain community-specific Stamp in their Passport as evidence that they are the real team member.Note, however, that it is possible for someone to be an impersonator and also have a high Passport score. This is why a Scorer integration is more about giving additional evidence, or context, to choices than it is about automated, binary decision making.You can find the code from this tutorial in this GitHub repo:Let's see how an integration like this is built using the Passport API.","prerequisites#Prerequisites":"Before we delve into this, it's essential to note that there are a few preliminary steps you need to complete. Please ensure that these prerequisites are met before proceeding with the guide.\nYou have created a Passport Scorer and received a Scorer ID\nYou have an API key\nIf you haven't completed the preliminary steps above please refer to our getting access guide first. Once you're done with that, return here and continue with this walkthrough.","integrating-a-scorer#Integrating a Scorer":"","setting-up-a-basic-app#Setting up a basic app":"We'll create an app using Nextjs. We can bootstrap using create-next-app. This automatically creates all the necessary subdirectories, configuration and boilerplate code required to get us building as quickly as possible.Start by entering the following command into your terminal:\nnpx create-next-app passport-app\nThis will create a new directory called passport-app and populate it with several sub-directories and files that form the skeleton of our app. create-next-app will ask for yes/no responses to a series of configuration questions - answer as follows:\nnpx create-next-app passport-app\n✔ Would you like to use TypeScript with this project? … Yes\n✔ Would you like to use ESLint with this project? … Yes\n✔ Would you like to use Tailwind CSS with this project? … No\n✔ Would you like to use `src/` directory with this project? … No\n✔ Would you like to use experimental `app/` directory with this project? …Yes\n✔ What import alias would you like configured? … @/*\nNext, change to the new passport-app directory and install ethers:\nnpm install ethers\nThis tutorial will also use Chakra-UI for styling, so install it using npm:\nnpm i @chakra-ui/react @emotion/react @emotion/styled framer-motion\nNow, create a new file in passport-app/ and add the following to set the Passport API Key and Scorer ID values (if you need a reminder of how to get the API key and Scorer values, revisit the Quick Start guide):\nNEXT_PUBLIC_GC_API_KEY=<your-api-key>\nNEXT_PUBLIC_GC_SCORER_ID=<your-scorer-id>\nSave this file as .env.local.Replace the contents of app/page.tsx with the following boilerplate code (this includes all the very basic logic to render a page and connect a wallet to the app, but none of the logic required to check a user Passport - we will add this step by step in this tutorial):\n'use client'\nimport { useState, useEffect } from 'react'\nimport { ethers } from 'ethers'\nimport { ChakraProvider, Button, Checkbox, Stack, Badge, SimpleGrid, Heading, Text } from '@chakra-ui/react'\nconst APIKEY = process.env.NEXT_PUBLIC_GC_API_KEY\nconst SCORERID = process.env.NEXT_PUBLIC_GC_SCORER_ID\n// endpoint for submitting passport\nconst SUBMIT_PASSPORT_URI = 'https://api.scorer.gitcoin.co/registry/submit-passport'\n// endpoint for getting the signing message\nconst SIGNING_MESSAGE_URI = 'https://api.scorer.gitcoin.co/registry/signing-message'\n// score needed to see hidden message\nconst thresholdNumber = 20\nconst headers = APIKEY ? ({\n  'Content-Type': 'application/json',\n  'X-API-Key': APIKEY\n}) : undefined\ndeclare global {\n  interface Window {\n    ethereum?: any\n  }\n}\n// define Stamp here\n// define UserStruct here\nexport default function Passport() {\n  // here we deal with any local state we need to manage\n  const [address, setAddress] = useState<string>('')\n  useEffect(() => {\n    checkConnection()\n    async function checkConnection() {\n      try {\n        const provider = new ethers.BrowserProvider(window.ethereum)\n        const accounts = await provider.listAccounts()\n        // if the user is connected, set their account and fetch their score\n        if (accounts && accounts[0]) {\n          setAddress(accounts[0].address)\n          checkPassport(accounts[0].address)\n        }\n      } catch (err) {\n        console.log('not connected...')\n      }\n    }\n  }, [])\n  async function connect() {\n    try {\n      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })\n      setAddress(accounts[0])\n    } catch (err) {\n      console.log('error connecting...')\n    }\n  }\n  async function getSigningMessage() {\n    try {\n      const response = await fetch(SIGNING_MESSAGE_URI, {\n        headers\n      })\n      const json = await response.json()\n      return json\n    } catch (err) {\n      console.log('error: ', err)\n    }\n  }\n  async function submitPassport() {\n    try {\n      // call the API to get the signing message and the nonce\n      const { message, nonce } = await getSigningMessage()\n      const provider = new ethers.BrowserProvider(window.ethereum)\n      const signer = await provider.getSigner()\n      // ask the user to sign the message\n      const signature = await signer.signMessage(message)\n      // call the API, sending the signing message, the signature, and the nonce\n      const response = await fetch(SUBMIT_PASSPORT_URI, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify({\n          address,\n          scorer_id: SCORERID,\n          signature,\n          nonce\n        })\n      })\n      const data = await response.json()\n      console.log('data:', data)\n    } catch (err) {\n      console.log('error: ', err)\n    }\n  }\n  \n  // add checkPassport() here\n  \n  // add getPassportScore() here\n  \n  // add getPassportStamps() here\n  // add updateShowTrusted() here\n    \n  // add updateShowStamps() here\n  \n  // add checkTrustedUsers() here\n  const styles = {\n    main: {\n      width: '900px',\n      margin: '0 auto',\n      paddingTop: 90\n    }\n  }\n  return (\n    /* this is the UI for the app */\n    <div style={styles.main}>\n      <ChakraProvider>\n        <Heading as='h1' size='4xl' noOfLines={1}>Are you a trusted user?</Heading>\n        <Text as='b'>If you have a score above 20, a Github Stamp AND a Lens Stamp, you are a trusted user!</Text>\n        <Stack spacing={3} direction='row' align='center' marginTop={30}>\n          <Button colorScheme='teal' variant='outline' onClick={connect}>Connect</Button>\n          <Button colorScheme='teal' variant='outline' onClick={submitPassport}>Submit Passport</Button>\n        </Stack>\n      </ChakraProvider >\n    </div >\n  )\n}\nYou can start this app now by navigating your terminal to the project directory (passport-app) and running npm run dev. Then, navigate your browser to localhost:3000. You will see a basic app load in the browser, with buttons that enable you to connect your wallet and submit your Passport to the registry. You can go ahead and test that the Connect and Submit Passport buttons are working as expected.Your app should look like this:The rest of the tutorial will build upon this basic app by adding functions and UI code to app/page.tsx.","checking-a-passport#Checking a Passport":"In this tutorial you will learn how to create a more advanced Scorer integration that will determine whether connected users are trusted or untrusted according to a combination of their score and ownership of specific stamps.The boilerplate code already provides buttons the users can click to connect their wallet and submit their Passport to the registry. We won't cover these functions again in this tutorial, so please note that a wallet connection and submitted Passport are required for calls to the Scorer API to return useful responses.","retrieving-a-score#Retrieving a score":"We want to display a user's trust status in the app's UI. Their trust status will be determined by their Passport score and ownership of specific Stamps. The weights applied to each Stamp can be found in the Passport Github.The first step is to retrieve their Passport score by calling the /registry/score/${SCORER_ID}/${address} API endpoint.The following function requests a user's Passport score from that endpoint. If no score exists it prints a warning to the console.\nasync function getPassportScore(currentAddress: string) {\n  console.log(\"in getScore()\")\n  const GET_PASSPORT_SCORE_URI = `https://api.scorer.gitcoin.co/registry/score/${SCORERID}/${currentAddress}`\n  try {\n    const response = await fetch(GET_PASSPORT_SCORE_URI, {\n      headers\n    })\n    const passportData = await response.json()\n    if (passportData.score) {\n      // if the user has a score, round it and set it in the local state\n      const roundedScore = Math.round(passportData.score * 100) / 100\n      return roundedScore\n    } else {\n      // if the user has no score, display a message letting them know to submit thier passport\n      console.log('No score available, please add Stamps to your passport and then resubmit.')\n    }\n  } catch (err) {\n    console.log('error: ', err)\n  }\n}","retrieving-stamps#Retrieving Stamps":"Next we want to retrieve the user's Stamps by calling the /registry/stamps endpoint. The following function requests a user's Passport Stamp data from that endpoint and prints it to the console. If no score exists it prints a warning to the console.\nasync function getPassportStamps(currentAddress: string) {\n  console.log(\"in getStamps()\")\n  const stampProviderArray = []\n  const GET_PASSPORT_STAMPS_URI = `https://api.scorer.gitcoin.co/registry/stamps/${currentAddress}`\n  try {\n    const response: Response = await fetch(GET_PASSPORT_STAMPS_URI, { headers })\n    const data = await response.json()\n    console.log(data)\n  } catch (err) {\n    console.log('error: ', err)\n  }\n}\nWe can invoke the function on the click of a button by adding the following to the UI:\n<pre class=\"language-html\"><code class=\"lang-html\"><strong>&#x3C;Button colorScheme='teal' variant='outline' onClick={() => getPassportStamps(address)}>Check Stamps&#x3C;/Button>\n</strong></code></pre>\nIf we run the app using npm run dev, connect a wallet that has some Stamps and click the Check Stamps button, the following information will be displayed in the console. In this example there are 33 credentials in the array, with one expanded as an example - the length of the items array will depend upon how many verified credentials the Passport holds.\nstamp data: \nObject { next: null, prev: null, items: (33) […] }\n  items: Array(33) [ {…}, {…}, {…}, … ]\n    0: Object { version: \"1.0.0\", credential: {…} \n      credential: Object { issuer: \"did:key:z6MkghvGHLobLEdj1bgRLhS4LPGJAvbMA1tn2zcRyqmYU5LC\", issuanceDate: \"2023-04-20T13:21:38.948Z\", expirationDate: \"2023-07-19T13:21:38.948Z\", … }\n        \"@context\": Array [ \"https://www.w3.org/2018/credentials/v1\" ]\n        credentialSubject: Object { id: \"did:pkh:eip155:1:0x1D4098C948Dc41958Bf3A745deC77AE059C3aDF6\", hash: \"v0.0.0:kWgm+E06OQrSk0M9NcEI3il5FIs9UoJQP3geH4LBuoY=\", provider: \"Google\", … }\n        expirationDate: \"2023-07-19T13:21:38.948Z\"\n        issuanceDate: \"2023-04-20T13:21:38.948Z\"\n        issuer: \"did:key:z6MkghvGHLobLEdj1bgRLhS4LPGJAvbMA1tn2zcRyqmYU5LC\"\n        proof: Object { jws: \"..sgcMRAONRMo7TfTgmMPgvfaP_MOzyiXcErIsIKap-nNpOuTNGSkhTdgxWFl5Mp6ueYnmcRDkgxBiDNCMmS5GDA\", type: \"Ed25519Signature2018\", created: \"2023-04-20T13:21:38.948Z\", … }\n        type: Array [ \"VerifiableCredential\" ]\n        <prototype>: Object { … }\n        version: \"1.0.0\"\n<prototype>: Object { … }\n1: Object { version: \"1.0.0\", credential: {…} }\n2: Object { version: \"1.0.0\", credential: {…} }\n3: Object { version: \"1.0.0\", credential: {…} }\n4: Object { version: \"1.0.0\", credential: {…} }\n5: Object { version: \"1.0.0\", credential: {…} }\n...\nnext: null\nprev: null\n<prototype>: Object { … }\nPrinting this object to the console isn't particularly useful to us, but seeing the object structure in this way demonstrates that the API call is working correctly and gives us information we can use to parse the Stamp data effectively.","handling-stamp-data#Handling Stamp data":"There is a lot of information contained in the object returned from /registry/stamps - for most use-cases only a subset of the data is useful. We might, for example, only be interested in the Stamp provider, and not the granular details of the credential expiry, proof etc. We can parse this information out of each item in the array.Let's just try to parse out the useful information first. We'll do this in a separate function, so let's replace our console.log() statement with a some simple code that parses out the provider for each of the user's stamps as a string and adds it to an Array. We'll print this array to the console to check we only have the provider strings.\nasync function getPassportStamps(currentAddress: string) {\n  console.log(\"in getStamps()\")\n  const stampProviderArray = []\n  const GET_PASSPORT_STAMPS_URI = `https://api.scorer.gitcoin.co/registry/stamps/${currentAddress}`\n  try {\n    const response: Response = await fetch(GET_PASSPORT_STAMPS_URI, { headers })\n    const data = await response.json()\n    // parse stamp data from json\n    for (const i of data.items) {\n      stampProviderArray.push(i.credential.credentialSubject.provider)\n    }\n    console.log(stampProviderArray)\n  } catch (err) {\n    console.log('error: ', err)\n  }\n}\nClicking the Check Stamps button will now display the following in the console:\n  stampProviders: Array(33) [ \"Google\", \"NFT\", \"GitPOAP\", … ]\n    0: \"Google\"\n    1: \"NFT\"\n    2: \"GitPOAP\"\n    3: \"POAP\"\n    4: \"Lens\"\n    5: \"Ens\"\n    6: \"FiftyOrMoreGithubFollowers\"\n    7: \"TenOrMoreGithubFollowers\"\n    8: \"StarredGithubRepoProvider\"\n    9: \"ForkedGithubRepoProvider\"\n    10: \"FiveOrMoreGithubRepos\"\n    11: \"Github\"\n    12: \"Discord\"\n    13: \"EthGasProvider\"\n    ...\nNow, for our actual app we want to return the array to use elsewhere instead of just printing it to the console, so replace console.log(stampProviderArray) with return stampProviderArray.*","tracking-the-stamps-and-score-in-state#Tracking the Stamps and score in state":"The two functions, getPassportScore() and getPassportStamps() return data that we want to keep track of in our app so that we can use it to make decisions about the trustworthiness of a user. This means we need a way to track this data in the app's state and functions that access that state to make some calculations.We can start by wrapping the two functions in an outer checkPassport() function that calls both getPassportScore() and getPassportStamps:\n  async function checkPassport(currentAddress = address) {\n    let score: number = await getPassportScore(currentAddress) as number\n    let stampProviders = await getPassportStamps(currentAddress) as Array<string>\n  }\nInstead of creating lots of state variables for each user, we can define an interface that can hold all the relevant information we want to track about each user. Add the following interface to the boilerplate code outside of the Passport() component:\ninterface UserStruct {\n  id: number;\n  address: string;\n  score: number;\n  stampProviders: Array<Stamp>;\n}\nThe UserStruct interface has fields for the user's address, score and Stamp providers as well as a unique identifier. Notice that we also defined the type of the stampProviders field to be an array of Stamp - this is a new struct we haven't defined yet. We need instances of Stamp to contain the name of each Stamp provider with a unique identifier. Add the following interface to the code just above the UserStruct:\ninterface Stamp {\n  id: number\n  stamp: string\n}\nIn our checkPassport() function, we can pass the responses from getPassportScore() and getPassportStamps() into a new instance of UserStruct. We can then add each instance to a state variable array. First, add a state variable userInfo as an array that will take instances of UserStruct.\nconst [userInfo, setUserInfo] = useState<Array<UserStruct>>([])\nNow, we can update checkPassport() to create a new UserStruct from the values returned from the Passport API calls, plus the user address and a unique ID calculated by adding 1 to the current length of the userInfo array. This new UserStruct is added to the userInfo array using the setUserInfo method.Remember, before constructing the UserStruct we have to parse the Stamp providers into an array of Stamps that can be passed to the UserStruct's stampProviders field.We also want to add a condition to prevent repeatedly adding the same user to the userInfo array, so we can wrap the call to setUserInfo in a simple if statement to check whether the user already exists.\nasync function checkPassport(currentAddress = address) {\n  let score: number = await getPassportScore(currentAddress) as number\n  let stampProviders = await getPassportStamps(currentAddress) as Array<string>\n  let stamps: Array<Stamp> = []\n  for (var i = 0; i < stampProviders.length; i++) {\n    let s: Stamp = { id: i, stamp: stampProviders[i] }\n    stamps.push(s)\n  }\n  const id = userInfo.length + 1\n  let user: UserStruct = { id: id, address: currentAddress, score: score, stampProviders: stamps }\n  console.log(user)\n  if (userInfo.map(user => user.address).includes(currentAddress || currentAddress.toUpperCase())) {\n    console.log(\"address already checked\")\n  } else {\n    console.log(\"adding user to state var\")\n    console.log(\"userInfo\", userInfo)\n    setUserInfo(userInfo.concat(user))\n  }\n  console.log(\"userInfo\", userInfo)\n}\nNow each user's Stamps and score are tracked in custom structs in our application's state.","using-the-stamp-and-score-data#Using the Stamp and score data":"Now we can use the state data to make decisions about each user. Maybe we just want a quick way to tell whether a connected user meets some specific requirements. Let's create a simple example where we display a list of connected addresses that are trusted because their Passport meets some requirements. This means the users of our app can see a real-time list of addresses that meet the eligibility criteria and can use this to help pick out the honest users.Let's set some arbitrary requirements. If the user has a Lens Stamp and an ENS Stamp and a Github Stamp, and their Passport score is greater than 20, then they are considered trusted and their address is displayed in the browser.So far, we have set up a state variable to collect all the connected users. We want a subset of those users that meet our eligibility requirements. We can achieve this by calling filter on the userInfo array. We'll filter on our trust criteria by checking the stampProviders and score fields of each UserStruct in userInfo and return the filtered array:\nfunction checkTrustedUsers() {\n  return userInfo.filter(user => user.stampProviders.filter(\n    provider => provider.stamp.includes('Lens')\n      && (provider.stamp.includes(\"Github\"))\n  )\n  ).filter(user => user.score > 20)\n}\nWe can now keep track of this filtered array in our app's state too. Create a new state variable, TrustedUsers. Its type should be an array of UserStructs.\nconst [trustedUsers, setTrustedUsers] = useState<Array<UserStruct>>([])\nNow we can update the app's state by passing checkTrustedUsers() to setTrustedUsers().Don't actually add this call to setTrustedUsers() to the app just yet - we'll include it inside another function in the next section.","displaying-trusted-users-in-the-ui#Displaying trusted users in the UI":"For our demo app, we simply want to display the trusted users in the UI. In real world applications the user data might be used in more complex ways. For example, you might build in a small warning pop up when you call some function passing an address that does not appear in TrustedUsers.Let's just add a button that will toggle displaying the trusted users on or off.We'll create a small function that sets a boolean to control the display that will be part of the app's state.Add the new state variable, initialized to false:\nconst [showTrusted, setShowTrusted] = useState<boolean>(false)\nNow add updateShowTrusted that resets TrustedUsers and sets ShowTrusted to true. This is where we want to call the setTrustedUsers() function.\nconst updateShowTrusted = () => {\n  setTrustedUsers(checkTrustedUsers())\n  if (showTrusted === false) {\n    setShowTrusted(true)\n  } else {\n    setShowTrusted(false)\n  }\n}\nNow, we want to make sure all this logic is executed as soon as a user connects their wallet. The API calls, data handling, and state management is all handled by a single call to our checkPassport() function. So, to make this happen automatically on connection, we can simply invoke the checkPassport() function inside our connect() and checkConnection() functions.The connect() and checkConnection() functions should end up as follows:\n<pre class=\"language-tsx\"><code class=\"lang-tsx\"><strong>useEffect(() => {\n</strong>  checkConnection()\n  async function checkConnection() {\n    try {\n      const provider = new ethers.BrowserProvider(window.ethereum)\n      const accounts = await provider.listAccounts()\n      // if the user is connected, set their account and fetch their score\n      if (accounts && accounts[0]) {\n        setAddress(accounts[0].address)\n        checkPassport(accounts[0].address)\n      }\n    } catch (err) {\n      console.log('not connected...')\n    }\n  }\n}, [])\nasync function connect() {\n  console.log(\"in connect func\")\n  try {\n    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })\n    setAddress(accounts[0])\n    checkPassport(accounts[0])\n  } catch (err) {\n    console.log('error connecting...')\n  }\n}\n</code></pre>\nNow, in our UI, we can add a button that calls this function. This button can replace the Check Stamps button we created earlier.\n<Button colorScheme='teal' variant='outline' onClick={updateShowTrusted}>Check Users</Button>\nLet's also add a way to show which specific Stamps the connected user owns. We might not always need to know this, so we'll hide it behind a checkbox - this way a user can see at a glance whether the user is trusted but also get more granular information if they need it.We can start by defining a function, just like updateShowTrusted that acts like a boolean switch, but this time it will toggle displaying the connected user's Stamps.\nconst updateShowStamps = () => {\n  if (showStamps === false) {\n    setShowStamps(true)\n    console.log(\"stamps = true\")\n  } else {\n    setShowStamps(false)\n    console.log(\"stamps = false\")\n  }\n}\nAnd, again, we need to add a new state variable to track the state of this switch:\nconst [showStamps, setShowStamps] = useState<boolean>(false)\nAnd add a checkbox to the UI that calls updateShowStamp when it is checked (you can add this after the Button elements inside the<Stack> </Stack> tags):\n<Checkbox colorScheme='telegram' onChange={updateShowStamps}>Show Stamps</Checkbox>\nThe final step is to update the UI code so that the data is actually displayed when the appropriate buttons and checkbox are activated.Immediately below the block of UI code wrapped in Stack tags, we can add the following div element:\n<div>\n  <br />\n  {showTrusted && <h3><b>Trusted users</b></h3>}\n  <br />\n  {showTrusted && trustedUsers.map(user => <ul key={user.id}> {user.address} </ul>)}\n</div>\nThis element contains two conditional rendering statements. They check whether showTrusted is true and if so, they render a title and the contents of trustedUsers (our filtered list of users that pass the trust criteria) to the browser.Immediately after that div element, we can add the following code which displays the user's Stamps if the Show Stamps checkbox is activated:\n{showStamps &&\n  <SimpleGrid columns={4} spacing='10px' marginTop={30}>\n    {showTrusted && showStamps && trustedUsers.map(user => user.stampProviders.map(s => <Badge key={s.id} colorScheme='green'>{s.stamp}:{user.address.substring(0, 5)}</Badge>))}\n  </SimpleGrid>}\nNow, if you run your app locally using npm run dev you will be able to connect your wallet, submit your Passport and check whether you pass the trust criteria. If you do, your address will be rendered to the screen. If you check the Show Stamps box, all your Stamps will be shown in the browser.","summary#Summary":"We have built a simple app that allows users to connect their wallets and trusted addresses that meet the score and Stamp criteria are displayed in the browser!Of course the app we created here has the bare minimum functionality required to demonstrate score and Stamp management, but the concepts explained here can be used to create more complex apps that use the Stamp and score criteria to support human decision making or more complex automated processes."}},"/building-with-passport/passport-api-v1/tutorials/requiring-a-passport-score-for-airdrop-claim":{"title":"Requiring a Passport score to qualify for airdrops","data":{"":"Please note:In November 2024, we soft-launched Passport API v2.We have not announced any deprecation or retirement timelines for v1 yet, but do strongly recommend using v2 moving forward.We are actively working on updating the v1 tutorials to use v2.You can learn more about the differences between v1 and v2 via our migration guide.\nAirdrops are a prevalent token distribution method, attracting 'airdrop farmers' who generate numerous accounts to amass tokens. This guide demonstrates using Passport scores to shield your airdrop from such harmful practices.This guide will cover the following topics:\nFetching Passport scores from the Passport API\nUsing Passport scores to regulate access to an airdrop\nYou can find the code from this tutorial in this GitHub repo:You can also check out a working version of this app.","prerequisites#Prerequisites":"Before we delve into this, it's important to note that there are a few preliminary steps you need to complete. Please ensure that these prerequisites are met before proceeding with the guide.\nYou have created a Passport Scorer and received a Scorer ID\nYou have an API key\nIf you haven't completed the preliminary steps above please refer to our getting access guide first. Once you're done with that, return here and continue with this walkthrough.","app-overview#App Overview":"We will be rebuilding many of the components and API endpoints of the airdrop example app.Below is a diagram showing a high-level overview of how the app functions and interacts with the Passport API.![](public/Passport Airdrop.png)The basic flow is as follows:\nDefine eligibility criteria for the airdrop, such as app interaction, Discord membership, or holding a specific token quantity. This serves as the main criteria for receiving the airdrop while a Passport score serves as an additional security measure.\nRetrieve the user's Passport score.\nConfirm the score exceeds a threshold indicative of legitimate user behavior.\nAdd the user's address into the airdrop database.\nNow that we understand what we will be building let's jump into some code.We will be building everything within the context of a Next.js app. We will also use RainbowKit and wagmi for wallet connection and blockchain helper methods.You can run one of the following commands to initialize a Next.js app with RainbowKit and wagmi preinstalled.\nnpm init @rainbow-me/rainbowkit@latest\n# or\npnpm create @rainbow-me/rainbowkit@latest\n# or\nyarn create @rainbow-me/rainbowkit\nCreate a .env.local file at the root of your directory and add your API key and Scorer ID to it. Make sure the env variable for your Scorer ID is NEXT_PUBLIC_SCORER_ID; this will ensure the variable is accessible to the frontend.\n# .env.local\nSCORER_API_KEY=\"YOUR API KEY\"\nNEXT_PUBLIC_SCORER_ID=119\nNow that we have our app scaffolded let's start building out the basic front-end and backend components we will need.","1-fetch-and-sign-a-message-and-nonce#1. Fetch and sign a message and nonce":"Passport allows a message and nonce to be submitted when scoring a Passport. This allows us to request permission from the user and send their approval along with our score request.We set up an API endpoint that our front-end can make requests to. We do this so we can keep our SCORER_API_KEY from being exposed.\n// pages/api/scorer-message.js\nconst axios = require(\"axios\");\nexport default async function handler(req, res) {\n  // This endpoint will call /registry/signing-message and return the message that needs to be signed by the user\n  //  as well as the nonce that should be submitted to /registry/submit-passport\n  \n  const messageAndNonce = await fetchMessageAndNonce();\n  res.status(200).json(messageAndNonce);\n}\nasync function fetchMessageAndNonce() {\n  const axiosSigningMessageConfig = {\n    headers: {\n      \"X-API-KEY\": process.env.SCORER_API_KEY,\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n    },\n  };\n  const { data } = await axios.get(\n    \"https://api.scorer.gitcoin.co/registry/signing-message\",\n    axiosSigningMessageConfig\n  );\n  return data;\n}\nNext our front-end can make a request to the above endpoint to fetch the message and nonce.\n// components/AirDrop.js\n// Fetch a message and nonce for the user to sign\n// This will run on the frontend whenever a user requests to be added to the airdrop.\nconst scorerMessageResponse = await axios.get(\"/api/scorer-message\");\nif (scorerMessageResponse.status !== 200) {\n  console.error(\"failed to fetch scorer message\");\n  return;\n}\n// Set the nonce on state, as we will need to use this later.\nsetNonce(scorerMessageResponse.data.nonce);\nWe now have the necessary data for the user to sign. We can leverage wagmi's useSignMessage method to prompt the user to sign.\n// components/AirDrop.js\nimport { useSignMessage } from \"wagmi\";\nconst { signMessage } = useSignMessage({\n  async onSuccess(data, variables) {\n  // Verify the message was signed properly.\n  const address = verifyMessage(variables.message, data);\n  \n  // Function continues in the next steps...\n}\nFinally, we call the signMessage function when a user requests to be added to the airdrop.\n// components/AirDrop.js\n<button onClick={() => signMessage(scorerMessageResponse.data.message)}>\n  Add to airdrop\n</button>","2-submit-a-users-address-for-scoring#2. Submit a user's address for scoring":"Before we can fetch a user's Passport score we must submit their address for scoring.We again set up an API endpoint that our front end can make requests to. We do this so we can keep our SCORER_API_KEY from being exposed.\n// pages/api/submit-passport.js\nconst axios = require(\"axios\");\nexport default async function handler(req, res) {\n  // The frontend sends in which address we should score and what Passport Scorer\n  //  we should use as well as a signature and nonce.\n  const { address, scorerId, signature, nonce } = req.body;\n  \n  // This is a good place to do some initial eligiblity checks. \n  // If the user does not meet the minimum criteria we can short circuit the process\n  // of checking their Passport score.\n  meetsMinimumEligibility(address)\n  \n  const data = await submitPassport(address, scorerId, signature, nonce);\n  res.status(200).json(data);\n}\nasync function meetsMinimumEligibility(address) {\n  // Check that this address has interacted with your protocol within the airdrop window.\n  // OR\n  // Check that the address holds a specific NFT or token\n  // Etc...\n}\nasync function submitPassport(address, scorerId, signature, nonce) {\n  const submitPassportConfig = {\n    headers: {\n      \"X-API-KEY\": process.env.SCORER_API_KEY,\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n    },\n  };\n  // This is the body that will be sent to the Passport API for scoring\n  const submitPassportData = {\n    address: address,\n    scorer_id: scorerId\n    signature: signature,\n    nonce: nonce\n  };\n  \n  const { data } = await axios.post(\n    \"https://api.scorer.gitcoin.co/registry/submit-passport\",\n    submitPassportData,\n    submitPassportConfig\n  );\n  \n  // The returned data will look like this\n  // {\n  //  \"address\": \"{address}\",\n  //  \"score\": null,\n  //  \"status\": \"PROCESSING\",\n  //  \"last_score_timestamp\": \"2023-02-03T12:08:21.735838+00:00\",\n  //  \"evidence\": null,\n  //  \"error\": null\n  // }\n  // Which we will return to the front end. The front end will then poll\n  // for the users score while the status is PROCESSING\n  \n  return data;\n}\nNow that we have a secure endpoint set up, we can make a request to it from our front-end. We do this right after we verify the signed message in the same onSuccess function from step 1.\n// components/AirDrop.js\nimport { useSignMessage } from \"wagmi\";\nconst { signMessage } = useSignMessage({\n  async onSuccess(data, variables) {\n    // Verify signature when sign message succeeds\n    const address = verifyMessage(variables.message, data);\n    \n    const submitResponse = await axios.post(\"/api/submit-passport\", {\n      address: address, // Required: The user's address you'd like to score.\n      community: process.env.NEXT_PUBLIC_SCORER_ID, // Required: get this from one of your scorers in the Scorer API dashboard https://developer.passport.xyz/\n      signature: data, // Optional: The signature of the message returned in Step #1\n      nonce: nonce, // Optional: The nonce returned in Step #1\n    });\n  \n    console.log(\"submitResponse: \", submitResponse);\n }\n}\nWe are now ready to fetch the user's Passport score.","3-fetch-a-users-passport-score#3. Fetch a user's Passport score":"Now that we've submitted the user's Passport for scoring we can poll for their score. Once again we will create an endpoint for our front-end to query to avoid exposing our SCORER_API_KEY.\n// pages/api/airdrop/add/[scorer_id]/[address].js\nconst axios = require(\"axios\");\nexport default async function handler(req, res) {\n  const { address, scorer_id: scorerId } = req.query;\n  const data = await fetchScore(address, scorerId);\n  res.status(200).json(data);\n}\nasync function fetchScore(address, scorerId) {\n  const getScoreConfig = {\n    headers: {\n      \"X-API-KEY\": process.env.SCORER_API_KEY,\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n    },\n  };\n  const { data } = await axios.get(\n    `https://api.scorer.gitcoin.co/registry/score/${scorerId}/${address}`,\n    getScoreConfig\n  );\n  \n  // Again the returned data will look like this.\n  // {\n  //  \"address\": \"{address}\",\n  //  \"score\": \"1.5272\",\n  //  \"status\": \"DONE\",\n  //  \"last_score_timestamp\": \"2023-02-03T12:08:21.735838+00:00\",\n  //  \"evidence\": null,\n  //  \"error\": null\n  // }\n  \n  // However, this time the status should be \"DONE\" and the score should be present.\n  // If the status is still \"PROCESSING\" the frontend should sleep for a few seconds\n  // and retry the request.\n  return data;\n}\nWe now have a secure endpoint for our front-end to query. We make the request to it inside the same onSuccess method.\nconst { signMessage } = useSignMessage({\n  async onSuccess(data, variables) {\n    // Verify signature when sign message succeeds\n    const address = verifyMessage(variables.message, data);\n    \n    const submitResponse = await axios.post(\"/api/submit-passport\", {\n      address: address, // Required: The user's address you'd like to score.\n      community: process.env.NEXT_PUBLIC_SCORER_ID, // Required: get this from one of your Scorers in the Passport API dashboard https://developer.passport.xyz/\n      signature: data, // Optional: The signature of the message returned in Step #1\n      nonce: nonce, // Optional: The nonce returned in Step #1\n    });\n  \n    console.log(\"submitResponse: \", submitResponse);\n    \n    const scoreResponse = await axios.get(\n        `/api/airdrop/add/${process.env.NEXT_PUBLIC_SCORER_ID}/${address}`\n      );\n    console.log(\"scoreResponse: \", scoreResponse);\n    \n    // Make sure to check the status\n    if (scoreResponse.data.status === \"ERROR\") {\n      // Handle the error and return.\n      return;\n    } else if (scoreResponse.data.status === \"PROCESSING\") {\n      // Sleep a few seconds and make the request again.\n    }\n    \n    // If we make it here the score has been successfully retrieved and we are\n    // ready to use it.\n  }\n}\nWe've completed the first three steps and have a user's Passport score. We now need to use this score to determine if they are an airdrop farmer or a legitimate user.","4-ensure-the-users-score-is-above-the-threshold#4. Ensure the user's score is above the threshold":"We want to ensure that our user's Unique Humanity score is greater than 20. This gives us the best chance of filtering out airdrop farmers while still allowing legitimate users to claim their tokens.\nfunction isUserEligible(score) {\n  if (score > 20) {\n    return true\n  }\n  return false\n}\nLeveraging Passport makes this process straightforward. We simply verify that the user's score surpasses the threshold of 20, if it does, they are permitted to claim the airdrop.","5-allow-the-user-to-claim-their-airdrop#5. Allow the user to claim their airdrop":"This can be handled in a number of ways.\nWe can add the user's address and score to a database, then after we've collected all the addresses, we can calculate the Merkle root which we set in our airdrop distribution contract.\nWe can allow the user to directly claim their tokens once we have verified they have met the minimum criteria and their Passport score is above our threshold. This would require us to distribute a unique signature for each user that allows them to call the claim function on our airdrop contract.\nWe will be using the first method.All we need to do now is store the user's address and score in our database. We can use whatever database we want, SQLite, Postgres, MongoDB, etc.Once we have our list of addresses that have met the minimum criteria for eligibility, we calculate the Merkle root of that list.\n// pages/api/admin/merkle.js\nconst merkle = require(\"merkle\");\nconst CryptoJS = require(\"crypto-js\");\nimport db from \"../../../db\";\nexport default async function handler(req, res) {\n  const rows = await db.select(\"*\").from(\"airdrop_addresses\");\n  const addresses = rows.map((r) => r.address);\n  const merkleRoot = calculateMerkleRoot(addresses);\n  res.status(200).json(merkleRoot);\n}\nfunction calculateMerkleRoot(addresses) {\n  // Hash the addresses using the SHA-256 algorithm\n  const hashedAddresses = addresses.map((address) =>\n    CryptoJS.SHA256(address).toString(CryptoJS.enc.Hex)\n  );\n  // Create a Merkle tree with the hashed addresses\n  const tree = merkle(\"sha256\").sync(hashedAddresses);\n  // Return the Merkle root\n  return tree.root();\n}\nNow we can set this root on our Merkle Distributor smart contract and eligible users can claim their token distributions.","conclusion#Conclusion":"In this guide we've done the following:\nSubmitted a user's address to the Passport API for scoring\nFetched their Passport score\nUsed their score to determine if they are eligible for the airdrop\nStored this information for later use in a Merkle distributor or other airdrop distribution method\nAdding Passport protection to your airdrop serves as a last line of defense against airdrop farmers and helps real users receive the most benefit while punishing bad actors."}},"/building-with-passport/passport-api-v1/tutorials/working-with-stamp-metadata":{"title":"Working with Stamp metadata","data":{"":"Please note:In November 2024, we soft-launched Passport API v2.We have not announced any deprecation or retirement timelines for v1 yet, but do strongly recommend using v2 moving forward.We are actively working on updating the v1 tutorials to use v2.You can learn more about the differences between v1 and v2 via our migration guide.\nHuman Passport Stamps show that a user has achieved certain milestones onchain or through some web2 service. It is common for these Stamps to be used to generate a score on the Passport server to indicate a user's trustworthiness. It is also possible to retrieve the actual Stamps instead of the score. This enables developers to use their own algorithms to generate scores, or to make decisions based on ownership of specific Stamps or groups of Stamps.In many cases app developers can serve their users better with additional information about the Stamps outside of just the verifiable credential and Stamp name. A simple example is access to a standardized icon image so that the Stamp can be displayed consistently across many applications.For this reason, there are two ways to access Stamp metadata using the Passport API.On this page, you will learn how to use the Stamp metadata API endpoints to retrieve Stamp metadata.You can follow this walk-through to build a simple app that allows a user to connect their wallet and display their Stamps to the browser, using information provided in the Stamp metadata.You can find the code from this tutorial in this GitHub repo:","prerequisites#Prerequisites":"Before we delve into this, it's important to note that there are a few preliminary steps you need to complete. Please ensure that these prerequisites are met before proceeding with the guide.\nYou have created a Passport Scorer and received a Scorer ID\nYou have an API key\nIf you haven't completed the preliminary steps above please refer to our getting access guide first. Once you're done with that, return here and continue with this walkthrough.","api-endpoints#API endpoints":"There are two API endpoints that can be used to query Stamp metadata.If you want to see the metadata for all available Stamps (the full set of possible Stamps, not only those that a user actually owns) you can use:\n/registry/stamp_metadata\nYou can also retrieve the Stamps owned by a particular address and instruct the API to return the metadata for each Stamp along with the Stamps themselves. To do this, use:\n/registry/stamps/{address}?_include_metadata=true\nYou can test this out using an HTTP tool such as curl. You will need to replace {your-api-key} with your API key in the request header, as well as {your-address} with your wallet address in order to access these endpoints.\ncurl --request GET 'https://api.scorer.gitcoin.co/registry/stamps/{your-address}?include_metadata=true' \\\n  --header 'X-API-KEY: {your-api-key}'","metadata-structure#Metadata structure":"The metadata for every Stamp follows this basic format:\n[\n  {\n    \"id\": \"string\",\n    \"icon\": \"string\",\n    \"name\": \"string\",\n    \"description\": \"string\",\n    \"connectMessage\": \"string\",\n    \"groups\": [\n      {\n        \"name\": \"string\",\n        \"stamps\": [\n          {\n            \"name\": \"string\",\n            \"description\": \"string\",\n            \"hash\": \"string\"\n          }\n        ]\n      }\n    ]\n  }\n]\nThe /registry/stamp_metadata endpoint simply returns an array of these metadata objects.For the /registry/stamps/{address}?_include_metadata=true endpoint, these metadata objects are bundled into the credential data object. For an individual Stamp, the complete data object looks as follows:\n{\n    \"version\": \"1.0.0\", \n    \"credential\": {\n        \"type\": [\"VerifiableCredential\"], \n        \"proof\": {\"jws\": \"..\", \n        \"type\": \"Ed25519Signature2018\", \n        \"created\": \"2023-04-20T13:18:05.065Z\", \n        \"proofPurpose\": \"assertionMethod\", \n        \"verificationMethod\": \"did:key:z5BkPGJAvLobLEdj1bgRLhS4YbSS1tn2zghvGHcRypNYU5LC#z6MkghvGHLobLEDj1bgRLhS4LPGJAvbMA1tn2zcRyqmPP5LC\"}, \n        \"issuer\": \"did:key:z6MkghvGHLobLEdj1bgRLhS4LPGJAvbMA1tn2zcRyqmYU5LC\", \"@context\": [\"https://www.w3.org/2018/credentials/v1\"], \n        \"issuanceDate\": \"2023-04-20T13:18:05.065Z\", \n        \"expirationDate\": \"2023-07-19T13:18:05.065Z\", \n        \"credentialSubject\": {\n            \"id\": \"did:pkh:eip155:1:0x1D4098C948Dc41958Bf3A745deC77AE059C3aDF6\", \n            \"hash\": \"v0.0.0:bTARjOAhxkfaxgJ29i/sy2tbSNaev7eGROL2Dabq6mc=\", \n            \"@context\": [{\n                \"hash\": \"https://schema.org/Text\", \n                \"provider\": \"https://schema.org/Text\"\n                }], \n            \"provider\": \"TenOrMoreGithubFollowers\"\n        }\n    }, \n    \"metadata\": {\n        \"group\": \"Followers\", \n        \"platform\": {\n            \"id\": \"Github\", \n            \"icon\": \"https://app.passport.xyzassets/githubWhiteStampIcon.svg\", \n            \"name\": \"Github\", \n            \"description\": \"Connect your existing Github account to verify.\", \n            \"connectMessage\": \"Connect Account\"\n            }, \n        \"name\": \"TenOrMoreGithubFollowers\", \n        \"description\": \"Ten or more Github followers\", \n        \"hash\": \"\"\n    }\n}\nWhen you use this Stamp object in your app, you will extract only the data you actually need.","setting-up-a-basic-app#Setting up a basic app":"We'll create an app using Nextjs. We can bootstrap using create-next-app. This automatically creates all the necessary subdirectories, configuration and boilerplate code required to get us building as quickly as possible.Start by entering the following command into your terminal:\nnpx create-next-app passport-app\nThis will create a new directory called passport-app and populate it with several sub-directories and files that form the skeleton of our app. create-next-app will ask for yes/no responses to a series of configuration questions - answer as follows:\nnpx create-next-app my-passport-app\n✔ Would you like to use TypeScript with this project? … Yes\n✔ Would you like to use ESLint with this project? … Yes\n✔ Would you like to use Tailwind CSS with this project? … No\n✔ Would you like to use `src/` directory with this project? … No\n✔ Would you like to use experimental `app/` directory with this project? …Yes\n✔ What import alias would you like configured? … @/*\nNext, change to the new my-passport-app directory and install ethers:\nnpm install ethers\nThis tutorial will also use Chakra-UI for styling, so install it using npm:\nnpm i @chakra-ui/react @emotion/react @emotion/styled framer-motion\nNow, create a new file in my-passport-app and add the following to set the Passport API Key and Scorer ID values:\nNEXT_PUBLIC_GC_API_KEY=<your-api-key>\nNEXT_PUBLIC_GC_SCORER_ID=<your-scorer-id>\nSave this file as .env.local.Now you are ready to start building your app. All the code that you will write for this app will be in the file src/app/page.tsx. You can delete everything in that file, and replace it with the following:\n'use client'\nimport { useState, useEffect } from 'react'\nimport { ethers } from 'ethers'\nimport { ChakraProvider, Button, Flex, Heading } from '@chakra-ui/react'\nimport { Image, SimpleGrid, Tooltip } from '@chakra-ui/react'\nconst APIKEY = process.env.NEXT_PUBLIC_GC_API_KEY\nconst headers = APIKEY ? ({\n  'Content-Type': 'application/json',\n  'X-API-Key': APIKEY\n}) : undefined\nexport default function Passport() {\n  // here we deal with any local state we need to manage\n  const [address, setAddress] = useState<string>('')\n  useEffect(() => {\n    // setShowStamps(false)\n    checkConnection()\n    async function checkConnection() {\n      try {\n        const provider = new ethers.BrowserProvider(window.ethereum)\n        const accounts = await provider.listAccounts()\n        // if the user is connected, set their account\n        if (accounts && accounts[0]) {\n          setAddress(accounts[0].address)\n        }\n      } catch (err) {\n        console.log('not connected...')\n      }\n    }\n  }, [])\n  async function connect() {\n    try {\n      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })\n      setAddress(accounts[0])\n    } catch (err) {\n      console.log('error connecting...')\n    }\n  }\n  const styles = {\n    main: {\n      width: '900px',\n      margin: '0 auto',\n      paddingTop: 90\n    }\n  }\n  return (\n    /* this is the UI for the app */\n    <div style={styles.main}>\n      <ChakraProvider >\n        <Flex minWidth='max-content' alignItems='right' gap='2' justifyContent='right'>\n          <Button colorScheme='teal' variant='outline' onClick={connect}>Connect Wallet</Button>\n        </Flex>\n        <br />\n        <br />\n        <Heading as='h1' size='4xl' noOfLines={2}>Gitcoin Stamp Collector</Heading>\n      </ChakraProvider >\n    </div >\n  )\n}\nThis sets up the bare bones of the app. The API key is loaded from env.local and added to a headers object that can be used to configure requests. Then a Passport() function is defined that returns a simple UI. Inside Passport() are functions that enable the user to connect their Ethereum wallets using ethers.These functions won't be explained again in detail here. If you would like to learn more about the functions that enable a user to connect a wallet, you can read the Passport scoring deep dive tutorial.","retrieving-stamps#Retrieving Stamps":"First of all, you can define an interface type that you will use to organize the useful Stamp data that you will use in your app. Paste the following type definition immediately after the definition of headers, above where you define the Passport() function.\ninterface Stamp {\n  id: number\n  name: string\n  icon: string\n}\nThis Stamp type had fields for the Stamp id (a unique number used to make arrays of this type iterable), a name which corresponds to the specific credential the Stamp relates to (not the provider, who can issue many credentials), and an icon which is a URL linking to an image to be used to represent the Stamp provider.Next, you can make a request to the registry/stamps/{address} endpoint, remembering to include the include_metadata=true qualifier. In Typescript, this can be achieved as follows:\nconst GET_PASSPORT_STAMPS_URI = `https://api.scorer.gitcoin.co/registry/stamps/${address}?include_metadata=true`\nconst response: Response = await fetch(GET_PASSPORT_STAMPS_URI, { headers })\nconst data = await response.json()\nThis will send an HTTP request to the endpoint, using the connected wallet's address in the URL. The response is received in JSON format, as shown earlier in the Metadata Structure section.However, to make use of this data you also have to parse the JSON and extract the useful pieces of information into an instance of the Stamp type. You can do this by iterating over all the Stamps. For each Stamp, you can extract the name and icon data and create a unique id using a straight-forward counter that increments in each loop. These elements can be added to a Stamp in each iteration, and each Stamp appended to an array you can call StampDataArray.\nconst stampDataArray = []\nlet counter = 0\nfor (const i of data.items) {\n    let st = { id: counter, stamp: i.credential.credentialSubject.provider, icon: i.metadata.platform.icon }\n    stampDataArray.push(st)\n    counter += 1\n}\nYou also need a way to track this in your app's state. To do this, you'll create a state variable called stampArray with an associated function setStampArray. This will allow you to add the following to your code, after looping through data.items.\nsetStampArray(stampDataArray)\nYou should also wrap this in try/catch to handle any errors. Put all this together in a single function, getStamps(), as follows:\nasync function getStamps() {\n    const stampProviderArray = []\n    const GET_PASSPORT_STAMPS_URI = `https://api.scorer.gitcoin.co/registry/stamps/${address}?include_metadata=true`\n    try {\n        const response: Response = await fetch(GET_PASSPORT_STAMPS_URI, { headers })\n        const data = await response.json()\n        // parse stamp data from json\n        let counter = 0\n        for (const i of data.items) {\n        let st = { id: counter, stamp: i.credential.credentialSubject.provider, icon: i.metadata.platform.icon }\n        stampProviderArray.push(st)\n        counter += 1\n        }\n        setStampArray(stampProviderArray)\n        return\n    } catch (err) {\n        console.log('error: ', err)\n    }\n}\nPaste the getStamps() function into page.tsx immediately below the connect() function. You also need to define the stampArray state variable - you can do this by pasting the following as the first item inside the Passport() function.\nconst [stampArray, setStampArray] = useState<Array<Stamp>>([])\nYou also need a way to execute this function, as it is not actually called anywhere in the code yet. To do this, add a button that calls getStamp() when clicked. The following can be added to page.tsx immediately below the existing connect() button near the bottom of the script.\n<Button colorScheme='teal' variant='outline' onClick={getStamps}>Show Stamps</Button>","using-the-stamp-metadata#Using the Stamp metadata":"At this point your code is able to connect a wallet and retrieve Stamp data for the connected user. However, your app is not doing anything with the data other than holding it in state. So, in this section you will write some code for displaying the Stamp data in a \"Stamp collection\" that the user can browse.Start with the simplest part - adding a simple Boolean state variable to toggle displaying the Stamps on and off. Paste the following beneath your stampArray state variable:\nconst [showStamps, setShowStamps] = useState<boolean>(false)\nWe can use this state variable to ensure that nothing is displayed until the user clicks Show Stamps and adds Stamp data from the Passport API to the app's state. Add a call to setShowStamps(true) to getStamps() immediately below setStampArray, above the return statement.Now, you an create a component that renders the Stamp data in an aesthetic way. The code snippet below uses a combination of Chakra-UI's SimpleGrid and Image components to display the icon for each Stamp. The way this is done is using map to create an instance of the Image component for each Stamp in stampArray, passing the URL from the Stamp's icon field as the image source. You can also add a fallback image that can be displayed in case a particular image fails to load.\n  const StampCollection = () => {\n    return (\n      <SimpleGrid minChildWidth='120px' spacing='40px' border='black'>\n        <>\n          {stampArray.map(s => <Image key={s.id} src={s.icon} alt={s.stamp} borderRadius='90px' boxSize='80px' fallbackSrc='gtc-logo.svg' backgroundColor='#C3D3D5' />)}\n        </>\n      </SimpleGrid >\n    )\n  }\nThere is one annoyance with this component: there is only one unique icon for each stamp provider, not every individual Stamp. This means that providers with multiple stamps will be represented by multiple instances of the same image, with no way to tell them apart.To fix this, you can wrap the new Image component in an outer Tooltip component which you import from Chakra-UI. This will allow the user to hover their cursor over the Stamps to see the Stamp name in a small text box beneath the image. The text to display comes from the Stamp's name field which was retrieved from the API.The final component should look as follows, and you can paste it into the Passport() app immediately above the definition of styles.\nconst StampCollection = () => {\nreturn (\n    <SimpleGrid minChildWidth='120px' spacing='40px' border='black'>\n    <>\n        {stampArray.map(s => <Tooltip key={s.id} label={s.stamp}><Image src={s.icon} alt={s.stamp} borderRadius='90px' boxSize='80px' fallbackSrc='gtc-logo.svg' backgroundColor='#C3D3D5' /></Tooltip>)}\n    </>\n    </SimpleGrid >\n)\n}\nThe final thing to add is a call to StampCollection in the app's UI. You can add the following to page.tsx immediately before the closing tag for ChakraProvider.\n{showStamps && <StampCollection />}\nThis renders the StampCollection component when ShowStamps evaluates to true.","run-the-app#Run the app":"You can now run the app and check that it works as expected. To do this, navigate to your project folder and run the following:\nnpm run dev\nThe app will start and you can access in your browser at http://localhost:3000.When you connect your app and click Show Stamps your app will look as follows (assuming you actually have some Stamps associated with your address). The tooltip feature is demonstrated for a Github stamp.","summary#Summary":"This walk-through guide demonstrated how to retrieve and handle Stamp metadata. You learned how to build a simple app that displays Stamp data to the browser, making use of information in the metadata. Now you understand the basics, you can incorporate Stamp metadata into your own apps!"}},"/building-with-passport/passport-api/api-reference":{"title":"Passport API v2 -- API reference","data":{"":"Please note:Passport API v2 simplifies and adds key functionality that wasn't previously available with Passport API v1. Because of this, it is recommended for you to use Passport API v2 moving forward.We have not announced any deprecation or retirement timelines for v1 yet, and plan to provide more details before the end of 2024.You can learn more about the differences between v1 and v2 via our migration guide.\nThe Passport API enables developers to retrieve Human Passport scores and Stamp metadata for users who have created a Passport.You can also experiment with the Passport API using our API playground tool and adding your API keys via the 'Authorize' button.In the examples below, replace the following placeholder values with your actual data:\n{scorer_id} - Your Scorer ID from the developer portal\n{address} - The Ethereum address you want to score\n{API_key} - Your API key from the developer portal","authentication#Authentication":"To access the Passport API, you will need a Scorer ID and an API key.To make a successful request, you will need to include your API key in the \"Authorization\" header of each API request. The header should have the following format:\n\"X-API-KEY: {API_key}\"\nReplace {API_key} with your API key. For example, if you were using cURL, your request might look something like this:\ncurl --request GET 'https://api.passport.xyz/v2/stamps/{scorer_id}/score/{address}' \\\n    --header 'X-API-KEY: VwUi___.0yQU1HIAE4hLEMkVs___'","rate-limits#Rate limits":"Your API key will allow you to make up to a certain number of requests to any of the endpoints included on this page during a certain period of time.Requests made to the Passport API v1 and v2 count towards the same rate limit.Access starts with Tier 1. If you need an elevation, please request higher rate limits.\nTier\tRate limit\tTier 1\t125 requests per 15 minutes\tTier 2\t350 requests per 15 minutes\tTier 3\t2000 requests per 15 minutes\tTier 4\t2000+ requests per 15 minutes","key-concepts#Key concepts":"There are several key concepts you should be aware of when using the Passport API:\nTimeouts: The Passport API endpoints have a timeout of 60 seconds. This means that if a request to one of these endpoints does not receive a response within 60 seconds, the request will be aborted. If your request times out, you should set up retry logic by calling the API again after a short delay, typically increasing the delay for each subsequent retry.\nPagination: Some requests return a large amount of data. To effectively retrieve this data, you will need to paginate the response. For more information, see API pagination.\nData dictionary: For definitions of the data types used in Passport API v2, see the Data dictionary page.","available-endpoints#Available endpoints":"Passport API v2 base URL: https://api.passport.xyz\nEndpoint action\tEndpoint\tRetrieve latest score for a single address\tGET /v2/stamps/{scorer_id}/score/{address}\tRetrieve historical score for a single address\tGET /v2/stamps/{scorer_id}/score/{address}/history\tRetrieve Stamps verified by a single address\tGET /v2/stamps/{address}\tRetrieve all Stamps available in Passport\tGET /v2/stamps/metadata","retrieve-latest-score-for-a-single-address#Retrieve latest score for a single address":"This is the primary endpoint that integrators should use.This endpoint will return the latest score and Stamp data for a single address.\nGET /v2/stamps/{scorer_id}/score/{address}\ncurl --request GET \\\n  --url https://api.passport.xyz/v2/stamps/{scorer_id}/score/{address} \\\n  --header 'X-API-KEY: {API KEY}'\n{\n  \"address\": \"{address}\",\n  \"score\": \"{overall_score}\",\n  \"passing_score\": true/false,\n  \"last_score_timestamp\": \"{last_score_time ISO 8601}\",\n  \"expiration_timestamp\": \"{expiration_time ISO 8601}\",\n  \"threshold\": \"20\",\n  \"error\": null,\n  \"stamps\": {\n    \"Ens\": {\n      \"score\": \"{credential_score}\",\n      \"dedup\": true/false,\n      \"expiration_date\": \"{expiration_time ISO 8601}\"\n    },\n    \"ETHDaysActive#50\": {\n      \"score\": \"{credential_score}\",\n      \"dedup\": true/false,\n      \"expiration_date\": \"{expiration_time ISO 8601}\"\n    },\n    \"ETHGasSpent#0.25\": {\n      \"score\": \"{credential_score}\",\n      \"dedup\": true/false,\n      \"expiration_date\": \"{expiration_time ISO 8601}\"\n    },\n    { ... }\n  }\n}\nLearn more about the data dictionary.","retrieve-historical-score-for-a-single-address#Retrieve historical score for a single address":"Note:To access this endpoint, you must submit your use case and be approved by the Passport team. To do so, please fill out the following form, making sure to provide a detailed description of your use case. The Passport team typically reviews and responds to form responses within 48 hours.Request access\nThis endpoint will return the last requested historical score and Stamp data for a single address before a specified time.For example, if you requested a score on 2024-12-01 using the GET /v2/stamps/{scorer_id}/score/{address} endpoint, then use this historical score endpoint to request the score for the same address on 2024-12-05, you will receive the score and Stamp data for 2024-12-01 for that address. If you have not requested a score for a specified address using the GET /v2/stamps/{scorer_id}/score/{address} endpoint, you will not be able to receive a historical score for that address.\nGET /v2/stamps/{scorer_id}/score/{address}/history","query-parameters#Query parameters":"Name\tRequired\tDescription\tcreated_at\tyes\tSpecified time that you want to retrieve the most recently submitted score for. ISO 8601 (YYYY-MM-DD or YYYY-MM-DDThh:mm:ss.sssZ)\t\ncurl --request GET \\\n    --url https://api.passport.xyz/v2/stamps/{scorer_id}/score/{address}/history?created_at={created_at} \\\n    --header 'X-API-KEY: {API KEY}'\n{\n  \"items\": [\n    {\n      \"address\": \"{address}\",\n      \"score\": \"{score}\",\n      \"passing_score\": true/false,\n      \"last_score_timestamp\": \"{last_score_time ISO 8601}\",\n      \"expiration_timestamp\": \"{expiration_time ISO 8601}\",\n      \"threshold\": \"20\",\n      \"error\": null,\n      \"stamps\": {\n        \"Ens\": {\n          \"score\": \"{credential_score}\",\n          \"dedup\": true/false,\n          \"expiration_date\": \"{expiration_time ISO 8601}\"\n        },\n        \"ETHDaysActive#50\": {\n          \"score\": \"{credential_score}\",\n          \"dedup\": true/false,\n          \"expiration_date\": \"{expiration_time ISO 8601}\"\n        },\n        \"ETHGasSpent#0.25\": {\n          \"score\": \"{credential_score}\",\n          \"dedup\": true/false,\n          \"expiration_date\": \"{expiration_time ISO 8601}\"\n        },\n        { ... }\n      }\n    }\n  ]\n}","retrieve-stamps-verified-by-a-single-address#Retrieve Stamps verified by a single address":"Use this endpoint to request all Stamps that have been verified by the specified Ethereum address.If you would like to retrieve the metadata for all available Stamps, please use the Get Stamps metadata endpoint.\nGET /v2/stamps/{address}","query-parameters-1#Query parameters":"Name\tRequired\tDescription\tinclude_metadata\tNo\tReturns optional metadata object with additional details about connected Stamps.Format: true/falseDefault: false\tlimit\tNo\tPaginates response, providing the given number of Stamps per page (For example, use limit=3 to request three Stamps) Learn more about API pagination.\ttoken\tNo\tPass the next or prev value from the previous response to get the next or previous page of results.\t\ncurl --request GET \\\n    --url 'https://api.passport.xyz/v2/stamps/{address}?include_metadata=true' \\\n    --header 'X-API-KEY: {API KEY}'\n{\n  \"next\": \"string\",\n  \"prev\": \"string\",\n  \"items\": [\n    {\n      \"version\": \"string\",\n      \"credential\": {},\n      \"metadata\": {}\n    }\n  ]\n}","retrieve-all-stamps-available-in-passport#Retrieve all Stamps available in Passport":"Use this endpoint to request all Stamps available on Passport.If you would like to retrieve just the Stamps that are connected to a specified Ethereum address, please use the Get Stamps endpoint.\nGET /v2/stamps/metadata\ncurl --request GET \\\n    --url https://api.passport.xyz/v2/stamps/metadata \\\n    --header 'X-API-KEY: {API KEY}'\n[\n  {\n    \"id\": \"string\",\n    \"icon\": \"string\",\n    \"name\": \"string\",\n    \"description\": \"string\",\n    \"connectMessage\": \"string\",\n    \"groups\": [\n      {\n        \"name\": \"string\",\n        \"stamps\": [\n          {\n            \"name\": \"string\",\n            \"description\": \"string\",\n            \"hash\": \"string\"\n          }\n        ]\n      }\n    ]\n  }\n]\nYou can also experiment with the Passport API using our API playground tool and adding your API keys via the 'Authorize' button.In the examples below, replace the following placeholder values with your actual data:\n{scorer_id} - Your Scorer ID from the developer portal\n{address} - The Ethereum address you want to score\n{API_key} - Your API key from the developer portal\nIf you have questions about the API, please reach out to us in our developer support channel."}},"/building-with-passport/passport-api/data-dictionary":{"title":"Data dictionary (v2)","data":{"":"On this page you will find definitions and explanations for the data types used in the Human Passport stack. The Scorer, Stamp , Credential and Stamp-metadata objects require the most explanation so they are handled separately here.","the-scorer-object#The Scorer object":"Value\tType\tDescription\tHow to use\taddress\tString (hexadecimal address)\tThe string of 20 bytes that uniquely identify an Ethereum account\tIdentifies a specific account to which the payload's data relates.\tscore\tString (numeric value as a string)\tThe registry/score endpoint returns a string that should be parsed as a float. It represents the result of adding the weights of all a user's Stamps.\tIf you'd like to use your own score threshold, you can compare this score against that threshold to identify which users should be provided access.\tpassing_score\tBoolean\tPassing score will return either true or false as its value, depending on whether the user's score exceeded the threshold score of 20, as recommended by the Passport team. You can also choose your own score threshold and use the score value if you'd prefer.\tIf you'd like to use the Passport recommended score threshold, you can use this value to identify which users should be provided access.\tlast_score_timestamp\tString (ISO 8601 datetime)\tThe date and time of the request.\tCan be used to identify when the snapshot of this data occured.\texpiration_timestamp\tString (ISO 8601 datetime)\tThe date and time that the next Stamp will expire, which will subsequently reduce the score. To see when each specific Stamp expires, please use the GET /v2/stamps{address} endpoint.\tYou might want to display this score expiration to the user to remind them to return to the Passport app to refresh their score before it expires\tthreshold\tString (numeric value as a string)\tThe Passport recommended score threshold that the user's score must exceed to be considered passing. The current recommended threshold is 20. You can also choose your own score threshold and use the score value if you'd prefer.\tIf you'd like to use the Passport recommended score threshold, you can use this value to identify which users should be provided access.\terror\tString\tDescribes any error returned by the server. Refer to the API status and error codes page for more information.\tCan be used to understand why a request failed.\tstamps\tObject\tContains simplified credential objects for each credential that has been validated by the specified user. This object was introduced on December 29th, 2023, and is not available via the historical score endpoint before this point.\tThe included credential objects within this object are the credentials that the user has verified.\tstamps.<credential_name>.score\tString (numeric value as a string)\tThe specific weight, or score, that this verified credential contributes to your overall unique humanity score, or score, above. If this specific credential is deduped, this score will be zero (0).\tCan be used to understand how the overall unique humanity score was calculated.\tstamps.<credential_name>.dedup\tBoolean\tIf this specific credential has been deduplicated (in other words, if this same credential has been verified by another address), this boolean will come back as true.IF true, the credential's score will be zero (0) and the credential's expiration date will represent when the credential verified by the other address will expire, rather than when this credential will expire.\tThis information can be used both to identify why a user's score is lower than expected and to publicly communicate these reasons to the user.\tstamps.<credential_name>.expiration_date\tString (ISO 8601 datetime)\tNotes when this specific credential will expire. If this specific credential is deduped, this expiration date will represent when the credential verified by the other address will expire, rather than when this credential will expire.\tThis information can be displayed to users to help them understand when their credential will expire.","the-stamp-object#The Stamp object":"Value\tType\tDescription\tHow to use\tcredential\tobject\tMessage displayed in the Passport Scorer app alongside a button to trigger verification of a specific Stamp See Credentials table below for more details.\tThis is what a Stamp actually comprises. It is associated with an Ethereum address.\titems\tarray<stamp>\tAn array containing data for each individual Stamp.\tEach object in this array represents a specific Stamp.\tmetadata\tobject\tMetadata is a object containing id, icon, name, description, and connectMessage fields for each provider and then more granular data for each of the provider's Stamps\tReturned from the GET /v2/stamps/{address} endpoint if the parameter include-metadata=true is also passed. Returned from GET v2/stamps/metadata endpoint for all Stamps\tnext\tstring\tA pointer to the next page of returned data, if the returned data has been paginated.\tYou can use this is a request to access a page and the subsequent page of results for a paginated response. If the value is null you are already seeing all the available information.\tprev\tstring\tA pointer to the preceding page of returned data, if the returned data has been paginated.\tYou can use this is a request to access a page and the previous page of results for a paginated response. If the value is null you are already seeing all the available information.\tversion\tstring\tA version identifier for a Stamp\tReturned for each Stamp from GET /v2/stamps{address}","credentials#Credentials":"A credential is a object returned in the Stamp object. Learn more about Verifiable Credentials via their w3 specification.This object has its own sub-fields as follows:\nValue\tType\tDescription\tHow to use\ttype\tstring\tA descriptor that shows what type of credential is present\tCan be used to check that the returned data is of the expected objecture for a given credential type. This is usually going to have the value VerifiableCredential.\tproof\tobject\tA object containing several fields comprising the proof that a certain action was taken, for example a signed auth token proving that an account was unlocked.\tUsed to verify ownership of a specific Stamp\tissuer\thash\tEach Stamp issuer has a specific identifying hash provided in this field.\tUsed to identify a Stamp issuer\t@context\turl\tLink to the credential definition documentation.\tCan be used to access reference documentation for the credential type\tissuanceDate\tdatetime string\tThe date and time that the Stamp was minted.ISO 8601, \"2023-04-28T09:35:49.159Z\"\tCan be used to check the age of a Stamp\texpirationDate\tdatetime string\tThe date and time the Stamp should expire.ISO 8601, \"2023-04-28T09:35:49.159Z\"\tCan be used to automatically expire a Stamp\tcredentialSubject\tobject\tContains anonymized information about the user that the Stamp is issued to. This includes a unique ID, a hash, link to the data schema and the Stamp provider name in plaintext.\tCan be used to connect Stamps to a user in a privacy preserving way","stamp-metadata#Stamp metadata":"Value\tType\tDescription\tHow to use\tconnectMessage\tstring\tMessage displayed in the Passport scorer app alongside a button to trigger verification of a specific Stamp\tMainly used in the Passport app, but could be used to provide appropriate message for verification in other contexts\tdescription\tstring\tShort description of what a specific Stamp demonstrates. For example, ownership of >0.5 ETH\tReturned in Stamp metadata, can be used to understand a specific Stamp\tgroups\tstring\tIdentifier for top-level groupings of Stamps for a given provider\tEach provider may issue many Stamps which can be grouped together by theme, for example the Passport Provider groups Stamps by Self GTC-staking and Community GTC-staking\thash\tstring\tA unique hash representing a specific instance of a credential\tUsed to prevent the same Stamp being used multiple times in a specific Scorer instance\ticon\tstring\tA URL for an image to represent each Stamp provider\tReturned in Stamp metadata, can be used to load an icon for a Stamp provider\tid\tstring\tAn identifier for a Stamp\tReturned in Stamp metadata, can be used to scrape data for a specific Stamp\tname\tstring\tName of the provider issuing a given Stamp\tReturned as part of the Stamp metadata, can be used to scrape information for specific providers\tstamps\tarray\tArray containing Stamp objects for each individual Stamp. Each Stamp has name, description and hash fields\tIncluded in Stamp metadata. Used to identify specific instances of individual Stamps"}},"/building-with-passport/passport-api/getting-access":{"title":"Getting access to the Passport API v2","data":{"":"The Passport API provides programmatic access to a wallet's Passport score. Once you have your API key, you need to include it with each request you make to the API. This allows Human Passport to identify your app and verify that you are authorized to access the API.","getting-your-api-key#Getting Your API Key":"Log in to the developer portal: Go to developer.passport.xyz and log in to your account by connecting your wallet.\nNavigate to the API Keys section: After logging in, go to the \"API Keys\" section.\nGenerate an API key: Click on the \"+ Create a Key\" button to generate a unique API key for your account.\nStore your API key securely: Store your API key in a secure place, as it will be used to access the Passport API.","getting-your-scorer-id#Getting your Scorer ID":"A Scorer is an developer element that can be used to organize different use cases. You need to create a Scorer and associated Scorer ID to be able to request user data via the Passport API. If you are using the Passport API in multiple use cases, you should set up separate Scorers for each one.\nFor the time being, please make sure you are selecting the Unique Humanity Scorer, and not the Binary Scorer. We will be deprecating these different Scorer types soon.If you have already selected the Binary Scorer, please disregard the v2 threshold and passing_score fields, as they are currently not correct. We will be updating all Binary Scorers to the new format soon.\nLog in to the Developer Portal: Go to developer.passport.xyz and log in to your account by connecting your wallet.\nNavigate to the Scorer section: After logging in, go to the \"Scorer\" section\nCreate a Scorer: Click on the \"+ Create a Scorer\" button and input a Scorer name and description. Make sure you use the Unique Humanity scorer, and not the Binary scorer.\nFind your Scorer ID: Click on the newly created Scorer and you will see the Scorer ID in the page URL.\nExample: https://developer.passport.xyz/dashboard/scorer/{scorer_id}","next-step#Next step":"Make your first API request\nReview the API Reference to learn more about the available endpoints"}},"/building-with-passport/passport-api/migrate":{"title":"Passport API migration guide","data":{"":"Migrating to Passport API V2 is designed to be straightforward. This guide outlines the key changes and provides step-by-step instructions to help you update your integration smoothly.But first, why should you migrate?\nRetrieve user scores with a single, intuitive GET request.\nUtilize new endpoints to access historical scores and Stamp data.\nGain access to more data to proactively prevent and resolve misunderstandings.\nRetrieve both binary and numeric scores within the same payload\nBenefit from a more unified API endpoint URI structure.\nIf you'd prefer to learn by doing, please visit our API playground to see the changes in action.\nIf you'd prefer to learn via our reference docs, please visit our API reference.","key-changes-to-address#Key changes to address":"The base URL\nSimplified score retrieval\nUpdated endpoint URIs\nAccessing historical data\nUnified Scorer types\nAdditional Stamp data in score payload","the-base-url#The base URL":"In August 2024, the Passport workstream spun out of Gitcoin.We have been working on separating our infrastructure from Gitcoin, and the API base URL is finally getting its update.\nPrevious Base URL: https://api.passport.gitcoin.co\nNew Base URL: https://api.passport.xyz\nAction Required: Update all instances of the base URL in your application to the new URL.","simplified-score-retrieval#Simplified score retrieval":"","background#Background":"In V1, retrieving a user's score involved:\nSubmitting the Passport for scoring using a POST request.\nRetrieving the score using a GET request.\nThis process was counterintuitive and could lead to confusion and stale scores if only the GET endpoint was used.","whats-new-in-v2#What's new in v2":"Single GET Request: Retrieve the latest score and Stamp data with one GET request.\nNo POST Required: Eliminates the need to submit the Passport for scoring.","endpoint-changes#Endpoint changes":"From V1: POST /registry/submit-passport\nTo V2: GET /v2/stamps/{scorer_id}/score/{address}\nAction Required: Replace any POST /registry/submit-passport requests with GET requests to the new endpoint.","updated-endpoint-uris#Updated endpoint URIs":"We've adopted a more consistent, object-oriented design for our API endpoints.","endpoint-mapping#Endpoint mapping":"From v1\tTo v2\tGET /registry/score/{scorer_id}/{address}\tGET /v2/stamps/{scorer_id}/score/{address}\tNew to v2\tGET /v2/stamps/{scorer_id}/score/{address}/history\tGET /registry/stamps/{address}\tGET /v2/stamps/{address}\tGET /registry/stamp-metadata\tGET /v2/stamps/metadata\tGET /passport/analysis/{address}\tGET /v2/models/score/{address}","accessing-historical-data#Accessing historical data":"","new-feature-in-v2#New Feature in V2":"Endpoint: GET /v2/stamps/{scorer_id}/score/{address}/history\nFunctionality: Retrieve a user's score and Stamp data from a specific date and time.\nNote: Access to this endpoint requires your API key to be allowlisted.Action Required for use:\nRequest Access: Fill out the access request form to have your API key allowlisted.\nUpdate Implementation: Incorporate the new endpoint into your application if you need historical data.","unified-scorer-types#Unified Scorer types":"","background-1#Background":"In V1, you had to choose between two Scorer types:\nUnique Humanity\nUnique Humanity: Binary\nThis differentiation added complexity and could lead to confusion.","whats-new-in-v2-1#What's New in V2":"Unified Scoring: Both numeric and binary scores are included in all payloads.\nSimplified Choices: No need to choose a Scorer type; you can use the score that best fits your application.","example-v2-payload#Example v2 Payload":"{\n  \"address\": \"0x9c4de275772297e8fd4c458e6844f4e92ac82b74\",\n  \"score\": \"31.885\",\n  \"passing_score\": true,\n  \"threshold\": \"20\",\n  \"last_score_timestamp\": \"2024-12-02T22:21:25.723470+00:00\",\n  \"expiration_timestamp\": \"2025-01-05T20:29:44.441000+00:00\",\n  \"error\": null,\n  \"stamps\": {\n    \"Discord\": {\n      \"score\": \"0\",\n      \"dedup\": true,\n      \"expiration_date\": \"2025-2-05T03:25:24.321000+00:00\"\n    },\n    \"Ens\": {\n      \"score\": \"0.408\",\n      \"dedup\": false,\n      \"expiration_date\": \"2025-01-05T20:29:44.441000+00:00\"\n    }\n  }\n}\nAction Required: Adjust your application's logic to handle the new payload structure and use the appropriate score type.","additional-stamp-data-in-score-payload#Additional Stamp data in score payload":"","deduplication-field#Deduplication field":"To prevent multiple Passports from verifying the same credential (enhancing security against Sybil attacks), Stamps are deduplicated across addresses.\nNew Field: dedup\nPurpose: Indicates whether a Stamp has been deduplicated and thus does not contribute to the score.","example#Example":"\"stamps\": {\n  \"Discord\": {\n    \"score\": \"0\",\n    \"dedup\": true,\n    \"expiration_date\": \"<alt_date>\"\n  },\n  \"Ens\": {\n    \"score\": \"0.408\",\n    \"dedup\": false,\n    \"expiration_date\": \"<date>\"\n  }\n}\nIn the above example, you'll notice that the Discord Stamp is deduplicated, meaning another address has also verified this same credential. As a result, the user received a 0 score for that Stamp. You will also note that a different expiration date returns when dedup=true. This date represents when the credential verified by the other address will expire, rather than when this credential will expire.You will also see that the ENS Stamp was not deduplicated, meaning the 0.408 score was included in the user's overall unique humanity score.Action Required:\nHandle Deduplication: Update your application to interpret the dedup field and inform users if their Stamps are affected.\nUser Communication: Consider displaying warnings to users about deduplicated Stamps.","stamp-expiration-date#Stamp expiration date":"New Field: expiration_date for each credential.\nPurpose: Indicates when each specific Stamp will expire.\nAction required:\nMonitor Expirations: Use the expiration_date to notify users about upcoming Stamp expirations.\nUpdate Logic: Ensure your application considers Stamp expiration dates in its functionality.","next-steps-checklist#Next Steps Checklist":"Update Base URL to https://api.passport.xyz.\nModify all API endpoint URIs to the new V2 structure.\nReplace POST requests with GET requests for score retrieval.\nUpdate your data models and logic to accommodate new fields (passing_score, dedup, expiration_date).\nIf needed, submit the access request form for the historical endpoint and build it into your integration.\nThoroughly test your application to ensure all changes work as expected.\nIf you have questions or need support, you can chat with us on our developer support channel on Telegram."}},"/building-with-passport/passport-api/overview":{"title":"Passport API v2 overview","data":{"":"Please note:Passport API v2 simplifies and adds key functionality that wasn't previously available with Passport API v1. Because of this, it is recommended for you to use Passport API v2 moving forward.We have not announced any deprecation or retirement timelines for v1 yet, and plan to provide more details before the end of 2024.You can learn more about the differences between v1 and v2 via our migration guide.\nThe Passport API serves as a powerful tool for developers, offering access to Passport's Stamp-based score metadata using REST endpoints.","why-use-the-api#Why use the API":"The API offers a simple integration; one that requires just two requests to submit and request user Human Passport data. This data is retrieved from the centralized Passport servers, meaning it is the most up-to-date data available for Passport users.","example-flow#Example flow":"An excellent use case for Passport is to protect access to a reward or governance program. To make this happen, follow these steps:\nCreating a Passport Project/Scorer and API key\nRetrieve a user's Passport score and Stamp data using the GET /v2/stamps/{scorer_id}/score/{address} endpoint.\nFind the user's Unique Humanity Score or passing_score within the returned data.\nCompare the Unique Humanity Score against a threshold that you set, or utilize the binary passing_score field that uses our recommended threshold of 20.\nIf a user was able to build up a score greater than this threshold, they've effectively proven their humanity and you can grant access to the protected program.","available-endpoints#Available endpoints":"Endpoint action\tEndpoint\tRetrieve latest score for a single address\tGET /v2/stamps/{scorer_id}/score/{address}\tRetrieve historical score for a single address\tGET /v2/stamps/{scorer_id}/score/{address}/history\tRetrieve Stamps verified by a single address\tGET /v2/stamps/{address}\tRetrieve all Stamps available in Passport\tGET /registry/stamp-metadata\t\nLearn more about each of these endpoints on our API Reference page, or experiment with them using our API playground (requires API key and Scorer/Project).","next-steps#Next steps":"Set up an API key and Scorer/Project\nMake your first API request\nReview the API Reference to get to know the available endpoints\nGet support via our Telegram channel"}},"/building-with-passport/passport-api/quick-start-guide":{"title":"Passport API v2 quick start guide","data":{"":"This page will help you make your first API request using the Passport API v2.You can also experiment with the Passport API using our API playground tool and adding your API keys via the 'Authorize' button.","api-basics#API basics":"Please make sure you have an API key and Scorer ID before working through this guide.The base URL for the API methods we'll be using is https://api.passport.xyz. There are several API endpoints that can be accessed by extending this base URL.You can browse more specific API details in the API reference.","how-to-retrieve-a-score#How to retrieve a score":"There is one basic step to retrieve a user's Passport score and Stamp data. All you have to do is make a request to the following GET endpoint:\nGET /v2/stamps/{scorer_id}/score/{address}\nThis endpoint requires a scorer_id and an address to be passed as path parameters. You can see an example of this in the following cURL request, using a scorer ID, 100; an address, 0x2C1E111d7C3adc823B5fA3af3f07EB62831C3c5; and a placeholder ({your-api-key}) that you need to replace with your API key:\ncurl --request GET \\\n  --url https://api.passport.xyz/v2/stamps/100/score/0x2C1E111d7C3adc823B5fA3af3f07EB62831C3c5 \\\n  --header 'X-API-KEY: {your-api-key}'\nAn example response might look as follows:\n{\n    \"address\": \"0x2C1E111d7C3adc823B5fA3af3f07EB62831C3c5\",\n    \"score\": \"33.538\",\n    \"passing_score\": true,\n    \"last_score_timestamp\": \"2024-11-17T14:46:22.900951+00:00\",\n    \"expiration_timestamp\": \"2025-02-06T14:28:06.879000+00:00\",\n    \"threshold\": \"20\",\n    \"error\": null,\n    \"stamp_scores\": {\n      \"Discord\": \"0.516\",\n      \"Google\": \"0.525\",\n      \"NFT\": \"1.032\",\n      \"SnapshotProposalsProvider\": \"0.839\",\n      \"zkSyncScore#5\": \"1.67\",\n      \"zkSyncScore#20\": \"1.67\",\n      \"zkSyncScore#50\": \"1.67\",\n      \"ZkSyncEra\": \"0.606\",\n      \"Lens\": \"0.93\",\n      \"ETHGasSpent#0.25\": \"1.003\",\n      \"GuildPassportMember\": \"0.54\",\n      \"CivicUniquenessPass\": \"6.005\",\n      \"TrustaLabs\": \"0.511\",\n      \"BinanceBABT\": \"16.021\"\n    }\n}\nThis response indicates that the address was successfully able to prove their humanity with Passport since their score is above the recommended threshold of 20.It's worthwhile to note that you can manually set your own score threshold within your code base based on your ecosystem's unique needs, but a score threshold of 20 is recommended for optimal results.","next-steps#Next Steps":"Review the API Reference to learn more about the available endpoints\nGet support via our Telegram channel"}},"/building-with-passport/passport-api/status-and-error-codes":{"title":"Status and error codes","data":{"http-status-codes#HTTP Status codes":"Code\tTitle\tDescription\t200\tOK\tThe request was successful.\t400\tBad request\tBad request\t401\tUnauthorized\tYour API key is invalid.\t404\tNot found\tThe resource does not exist.\t429\tToo Many Requests\tThe rate limit was exceeded.\t500\tInternal Server Error\tAn error occurred with our API.","error-types#Error types":"All errors are returned in the form of JSON with a detail explaining the error\nExample error response.\n  {\n    \"detail\": \"string\"\n  }\nError Detail\tDescription\tInvalid nonce\tThe nonce used in the submit Passport API request could not be verified\tAddress does not match signature\tThe signer could not be verified\tInvalid limit\tThe page limit of the Passport API request is greater than 1000\tUnable to get score for provided Scorer ID\tUnable to validate that the Scorer ID belongs to the account holding the API key\tUnauthorized\tX-API-Key was not specified in the header or an invalid API key was provided\tInternal Server Error\tSomething went wrong on our end\t\nIf you have questions about the API, please reach out to us in our developer support channel.More detailed information about this API's endpoints can be found in the API reference."}},"/building-with-passport/smart-contracts/attestation-schema":{"title":"Attestation schema","data":{"":"Onchain Passports use Attestations to verify that a particular address owns specific Stamps.\nUltimately, an Attestation is just a piece of data with a cryptographic signature.The data follows a known structure, known as a 'schema'. The  schema is critical because it ensures the signing participant\nknows what they are signing, and provides a uniform data layout that enables users to decode the Attestations.The schema is the layout of information being attested.\nThe signature is the proof that a known, trusted verifier has seen the data and attested that it is truthful.There are two attestations that are issued when users mint their Passports onchain, both of which are described below:\nPassport (Stamp) attestation\nScore attestation","passport-stamp-attestation-schema#Passport (Stamp) attestation schema":"","overview#Overview":"The raw schema looks as follows:\nuint256[] providers, bytes32[] hashes, uint64[] issuanceDates, uint64[] expirationDates, uint16 providerMapVersion\nNotice that the types for all these fields are numerical types or raw bytes.\nThis is because the human-readable information is compressed and encoded before being added to the attestation.You can see an example of a Stamp attestation on the Optimism network by visiting the following link:Example Passport (Stamp) attestation on Optimism","fields#Fields":"The fields are as follows:\nproviders: a u256 that is actually a bitmap where each position maps to a provider name. The mapping is made available offchain.\nhashes: an ordered array of elements, with each element being 32 raw bytes. Each element in the array is a 32-byte hash that maps to a known Stamp. A provider might have multiple Stamps that each have a hash. The mapping is made available offchain.\nissuanceDates: an ordered array of elements, with each element being 32 raw bytes. Each element represents the UNIX timestamp when the Stamp was verified.\nexpirationDates: an ordered array of elements, with each element being 32 raw bytes. Each element represents the UNIX timestamp when the Stamp expires.\nproviderMapVersion: an unsigned integer specifying which version of the providers mapping the Attestation conforms to. This allows updates as providers are added and removed from the canonical set.","score-attestation-schema#Score attestation schema":"The raw schema looks as follows:\nuint256 score, uint32 scorer_id, uint8 score_decimals\nYou can see an example of a score attestation on the Optimism network by visiting the following link:Example score attestation on Optimism","fields-1#Fields":"The fields are as follows:\nscore: the user's Passport score as an unsigned integer\nscorer_id: the ID number for the specific Scorer instance that issued the score\nscore_decimals: number of decimals in score, similar to how ETH is divided into 1e18 Wei.","decoding-attestations#Decoding Attestations":"The schema is used to encode and decode Attestations.\nFrom a raw attestation, you can extract the data that belongs to each field in the schema using an ABI decode method (such as abi.decode in Solidity, abiCoder.decode() in Ethers, etc) as follows:\n// Decode the attestion output\n(providers, hashes, issuanceDates, expirationDates, providerMapVersion) = abi.decode(\n  attestation.data,\n  (uint256[], bytes32[], uint64[], uint64[], uint16)\n);\nYou then need to apply some logic to the decoded data to extract actionable insights.For example, you should extract the position indexes of each 1 value in the providers bitmap, then look up the Providers at those same indexes in the providers mapping, found on the Passport Github.You may also wish to extract each value from hashes and find the matching entry in the Stamps mapping to determine which specific Stamps the Attestation contains.Similarly, you can determine the current time and check whether it is before or after the expirationDates for each Stamp.You can see an example of how to do this in a Nextjs app in our onchain Passports tutorial.Note if you have more questions about the Attestation schema, you can chat in our developer support channel on Telegram."}},"/building-with-passport/smart-contracts/contract-reference":{"title":"Smart contract reference","data":{"":"The Human Passport smart contract stack allows developers to pull Stamp data directly from the blockchain rather than having to make requests to a centralized server. The smart contract stack is built on top of the Ethereum Attestation Service (EAS).This page will outline the Human Passport smart contract stack and provide all the deployment details you need to integrate onchain Stamp data in your app.This page is broken into two sections:\nHow Human Passport adds metadata to the blockchain\nHow to query for onchain Human Passport data\nYou can always chat in our Telegram developer support channel if you have questions about the Human Passport smart contracts.","how-human-passport-adds-data-to-the-blockchain#How Human Passport adds data to the blockchain":"We will not cover this in depth, as it is already documented in our GitHub docs.Human Passport uses a combination of private Passport smart contracts and EAS contracts to create Passport attestations and mint them to the blockchain. This process is triggered when a user opts-in to minting their Passport’s score and Stamps onchain via the Passport app, and ends with two attestations being minted on EAS that can be accessed by third-party developers.During this process, the user is charged a $3 mint fee to write the attestations onchain.","how-to-query-for-onchain-human-passport-data#How to query for onchain Human Passport data":"Human Passport, EAS, and Verax have created several smart contracts that can be used to retrieve users’ Passport attestations. There are a couple of different flows you can follow, but we strongly recommend using the GitcoinDecoder contract.Available flows:\n[Recommended] GitcoinPassportDecoder flow\nGitcoinResolver >> EAS/Verax flow","gitcoinpassportdecoder#GitcoinPassportDecoder":"The decoder is a greatly simplified version of the alternative flow, and delivers all data you would need to integrate with Passport in a human-readable format.Here is a rundown of the GitcoinPassportDecoder flow:\nA request is sent to the GitcoinPassportDecoder contract, passing the user address and method associated with the data you’d like to receive.\nThe smart contract delivers the data associated with the user and method.\nYour integration then either gates access to just those users over a specified score threshold, or displays the Passport data to help prove a users reputation.","github-links#GitHub links":"Smart contract: https://github.com/passportxyz/eas-proxy/blob/main/contracts/GitcoinPassportDecoder.sol\nInterface contract: https://github.com/passportxyz/eas-proxy/blob/main/contracts/IGitcoinPassportDecoder.sol\nABI: https://github.com/passportxyz/eas-proxy/blob/main/deployments/abi/GitcoinPassportDecoder.json","decoder-contract-addresses#Decoder contract addresses":"The decoder is currently deployed to the following networks:\nNetwork\tContract address\tLink\tArbitrum\t0x2050256A91cbABD7C42465aA0d5325115C1dEB43\tArbiscan\tBase\t0xaa24a127d10C68C8F9Ac06199AA606953cD82eE7\tBasescan\tLinea\t0x423cd60ab053F1b63D6F78c8c0c63e20F009d669\tExplorer\tOptimism\t0x5558D441779Eca04A329BcD6b47830D2C6607769\tOptimism Explorer\tOptimism Sepolia\t0xe53C60F8069C2f0c3a84F9B3DB5cf56f3100ba56\tOptimism Explorer\tScroll\t0x8A5820030188346cC9532a1dD9FD2EF8d8F464de\tScrollscan\tScroll Sepolia\t0x2443D22Db6d25D141A1138D80724e3Eee54FD4C2\tScrollscan\tShape\t0x2443D22Db6d25D141A1138D80724e3Eee54FD4C2\tShapescan\tShape Sepolia\t0x2050256A91cbABD7C42465aA0d5325115C1dEB43\tShapescan\tZkSync Era\t0x1166FCDCA3B04311Ba9E2eD5ad2c660E730e1386\tExplorer\tZkSync Sepolia\t0x23AF92Af3b5D6faAD920C3CAA4F9A3d4352D6834\tExplorer\t\nYou can learn more about working with testnets via our guide on Test Mode.","available-methods#Available methods":"Method\tDescription\tgetPassport(userAddress)\tReturns a list of valid credentials for a given ETH address.Example response:tuple[] :  [[Ens,,1704482571,1712258571][ethPossessionsGte#1,,1704482571,1712258571][FirstEthTxnProvider,,1704482571,1712258571][EthGTEOneTxnProvider,,1704482571,1712258571][EthGasProvider,,1704482571,1712258571][NFT,,1704482571,1712258571][GnosisSafe,,1704482571,1712258571][GuildPassportMember,,1704482571,1712258571][TrustaLabs,,1704482571,1712258571]]\tgetScore(userAddress)\tReturns a user’s valid score as a 4-digit value. Divide the value by 100 to get the user’s score. This function will read the user’s score first from the cache in the GitcoinResolver and fall back to reading the score from the EAS score attestation. This method will revert with an error is a valid score is not found.Example response:uint256 :  143890\tisHuman(userAddress)\tReturns a single boolean, indicating if the user’s score is below or above the minimum threshold, which is currently set to 20. It uses getScore() to retrieve the value that is compared against this threshold.Example responses:bool :  falsebool :  true","alternative-method#Alternative method":"Please note that this method only enables you to receive decoded onchain Stamp data, and not score data.\nThis alternative flow represents a subset of the tasks that the decoder contract automatically works thorugh, which is why we don’t recommend using it. It is, however, useful to understand.If you decide to go this route, you will follow this flow:\nA request is sent to the Resolver contract passing the user address\nThe Resolver contract returns a UID\nThe UID is passed to the EAS contract\nThe EAS contract returns an encoded Attestation\nDecode the Attestation and extracts the Stamp data","gitcoinresolver-contract#GitcoinResolver contract":"The GitcoinResolver contract is used to request a UID for an address.The Attestations are stored in a mapping, where the Attestation is stored as raw bytes (allowing Attestations with any schema to be included).In order to ensure the integrity of the data that the contract stores, the resolver smart contract shall only validate and store date from trusted sources:\na trusted EAS contract\na trusted Attester","eas-contract#EAS contract":"The EAS contract is where you can pass the UIDreceived from the GitcoinResolver contract to receive an Attestation.","alternative-flow-contract-addresses#Alternative flow contract addresses":"","arbitrum#Arbitrum":"The Arbitrum chain ID is 42161.\ncontract\taddress\tlink\tissuer\t0x804233b96cbd6d81efeb6517347177ef7bD488ED\tArbiscan\tEAS\t0xbD75f629A22Dc1ceD33dDA0b68c546A1c035c458\tArbiscan\tGitcoinResolver\t0x90E2C4472Df225e8D31f44725B75FFaA244d5D33\tArbiscan\tGitcoinVerifier\t0xc4858e4D177Bf0d14571F91401492d62aa608047\tArbiscan\tGitcoinAttester\t0x7848a3578Ff2E1F134659a23f64A404a4D710475\tArbiscan\t\nEAS Schema\nschema\tuid\tlink\tpassport\t\tEasScan\tscore\t\tEasScan","base#Base":"Contract\tAddress\tLink\tEAS\t0x4200000000000000000000000000000000000021\tBasescan\tEASSchemaRegistry\t0x4200000000000000000000000000000000000020\tBasescan\tGitcoinResolver\t0x90E2C4472Df225e8D31f44725B75FFaA244d5D33\tBasescan\tGitcoinVerifier\t0x16db23c4b99bbC9A6Bf55dF7a787C9AEFD261185\tBasescan\tGitcoinAttester\t0xCc90105D4A2aa067ee768120AdA19886021dF422\tBasescan\t\nEAS Schema\nschema\tuid\tlink\tpassport\t\tEasScan\tscore\t\tEasScan","linea#Linea":"The Linea chain ID is 59144.\ncontract\taddress\tlink\tissuer\t0x4B70C4308ea49d17FD946dDacD6884e8e1e18B56\tLineascan\tEAS\t0xaEF4103A04090071165F78D45D83A0C0782c2B2a\tLineascan\tGitcoinVeraxPortal\t0xCAa9E817f02486cE076560B77A86235Ef91c5d5D\tLineascan\tGitcoinResolver\t0x0a774AECE542a1A819107Eb3a06E9D515C67257a\tLineascan\tGitcoinVerifier\t0xc94aBf0292Ac04AAC18C251d9C8169a8dd2BBbDC\tLineascan\tGitcoinAttester\t0xBC778313E52b1184A15D163b5d3a72AEF8d510A2\tLineascan\t\nVerax schema\nschema\tuid\tpassport\t\tscore\t\t\nEAS Schema\nschema\tuid\tlink\tpassport\t\tEasScan\tscore\t\tEasScan","optimism#Optimism":"The Optimism chain ID is 10.Gitcoin\ncontract\taddress\tlink\tissuer\t0x804233b96cbd6d81efeb6517347177ef7bD488ED\tOptimism Explorer\tEAS\t0x4200000000000000000000000000000000000021\tOptimism Explorer\tGitcoinResolver\t0xc94aBf0292Ac04AAC18C251d9C8169a8dd2BBbDC\tOptimism Explorer\tGitcoinVerifier\t0xa8eD4d2C3f6f98A55cdDEd97C5aE9B932B0633A4\tOptimism Explorer\tGitcoinAttester\t0x843829986e895facd330486a61Ebee9E1f1adB1a\tOptimism Explorer\t\nEAS Schema\nschema\tuid\tlink\tpassport\t\tEasScan\tscore\t\tEasScan","optimism-sepolia#Optimism Sepolia":"The Optimism Sepolia chain ID is 11155420.Gitcoin\ncontract\taddress\tlink\tissuer\t0x4200000000000000000000000000000000000021\tOptimism Explorer\tEAS\t0x4200000000000000000000000000000000000020\tOptimism Explorer\tGitcoinResolver\t0x074761E1Dc6E6cF9cdeE67dd180E01E818716Ce0\tOptimism Explorer\tGitcoinVerifier\t0x8D21C3360dcE1a9EBD3Da4373c4dAB7F81dd7233\tOptimism Explorer\tGitcoinAttester\t0x8B1A76795e3CbadD79C5410d2C4D4827D9C1503a\tOptimism Explorer\t\nEAS Schema\nschema\tuid\tlink\tpassport\t\tEasScan\tscore\t\tEasScan","scroll#Scroll":"The Scroll chain ID is 534352.Gitcoin\ncontract\taddress\tlink\tissuer\t0x804233b96cbd6d81efeb6517347177ef7bD488ED\tScrollscan\tEAS\t0xC47300428b6AD2c7D03BB76D05A176058b47E6B0\tScrollscan\tGitcoinResolver\t0x90E2C4472Df225e8D31f44725B75FFaA244d5D33\tScrollscan\tGitcoinVerifier\t0x16db23c4b99bbC9A6Bf55dF7a787C9AEFD261185\tScrollscan\tGitcoinAttester\t0xCc90105D4A2aa067ee768120AdA19886021dF422\tScrollscan\t\nEAS Schema\nschema\tuid\tlink\tpassport\t\tEasScan\tscore\t\tEasScan","scroll-sepolia#Scroll Sepolia":"The Scroll chain ID is 534351.Gitcoin\ncontract\taddress\tlink\tissuer\t0x5f603Ed913738d9105bAf3BD981AA4750016B167\tScrollscan\tEAS\t0xaEF4103A04090071165F78D45D83A0C0782c2B2a\tScrollscan\tGitcoinResolver\t0x90E2C4472Df225e8D31f44725B75FFaA244d5D33\tScrollscan\tGitcoinVerifier\t0x16db23c4b99bbC9A6Bf55dF7a787C9AEFD261185\tScrollscan\tGitcoinAttester\t0xCc90105D4A2aa067ee768120AdA19886021dF422\tScrollscan\t\nEAS Schema\nschema\tuid\tlink\tpassport\t\tEasScan\tscore\t\tEasScan","shape#Shape":"The Shape chain ID is 360.Gitcoin\ncontract\taddress\tlink\tissuer\t0x804233b96cbd6d81efeb6517347177ef7bD488ED\tShapescan\tEAS\t0x4200000000000000000000000000000000000021\tShapescan\tGitcoinResolver\t0x90E2C4472Df225e8D31f44725B75FFaA244d5D33\tShapescan\tGitcoinVerifier\t0x16db23c4b99bbC9A6Bf55dF7a787C9AEFD261185\tShapescan\tGitcoinAttester\t0xCc90105D4A2aa067ee768120AdA19886021dF422\tShapescan\t\nEAS Schema\nschema\tuid\tpassport\t\tscore\t","shape-sepolia#Shape Sepolia":"The Shape chain ID is 11011.Gitcoin\ncontract\taddress\tlink\tissuer\t0x5f603Ed913738d9105bAf3BD981AA4750016B167\tShapescan\tEAS\t0x4200000000000000000000000000000000000021\tShapescan\tGitcoinResolver\t0x90E2C4472Df225e8D31f44725B75FFaA244d5D33\tShapescan\tGitcoinVerifier\t0x3508ea66D2ccCEcD3aa9215b6471868431CF2AdC\tShapescan\tGitcoinAttester\t0x39571bBD5a4c5d1a5184004c63F45FE426dB85Ea\tShapescan\t\nEAS Schema\nschema\tuid\tpassport\t\tscore\t","zksync-era#ZkSync Era":"The ZkSync chain ID is 324.\ncontract\taddress\tlink\tissuer\t0x804233b96cbd6d81efeb6517347177ef7bD488ED\tExplorer\tEAS\t0x21d8d4eE83b80bc0Cc0f2B7df3117Cf212d02901\tExplorer\tGitcoinResolver\t0x8789129C5968EdcA5Cb392C4a9A9D7EFB590A838\tExplorer\tGitcoinVerifier\t0xfCC2d308FD4De098D08f056c424C969d728912bF\tExplorer\tGitcoinAttester\t0x2B5D97CBE50eA9bf809CbE18A2003E4Cb4D283cC\tExplorer\t\nEAS Schema\nschema\tuid\tlink\tpassport\t\tEasScan\tscore\t\tEasScan","zksync-sepolia#ZkSync Sepolia":"The ZkSync chain ID is 300.\ncontract\taddress\tlink\tissuer\t0x5f603Ed913738d9105bAf3BD981AA4750016B167\tExplorer\tEAS\t0x21d8d4eE83b80bc0Cc0f2B7df3117Cf212d02901\tExplorer\tGitcoinResolver\t0x8789129C5968EdcA5Cb392C4a9A9D7EFB590A838\tExplorer\tGitcoinVerifier\t0xfCC2d308FD4De098D08f056c424C969d728912bF\tExplorer\tGitcoinAttester\t0x2B5D97CBE50eA9bf809CbE18A2003E4Cb4D283cC\tExplorer","attestation-schemas#Attestation Schemas":"We discuss the Passport (Stamp) and score schemas in our Attestation schema guide."}},"/building-with-passport/smart-contracts/onchain-expirations":{"title":"Onchain expirations","data":{"":"Passport Stamps do not stay valid forever. There is an expiration date after which a Stamp must be reverified in order to keep it valid. This is true for onchain and offchain Stamps.","passport-attestations#Passport attestations":"For Passport attestations, there is a key in the schema called Expiration Dates. The value associated with this key is an array of hex-encoded dates, each corresponding to a specific Stamp. There is also an equivalent key, IssuanceDate whose values encode the date when a particular Stamp was verified.New attestations can be issued with updated IssuanceDate and expirationDate values through the Passport app.Here's an example of a Passport attestation","score-attestations#Score attestations":"Onchain scores do not have an explicit expiry date associated with them. If you are an integrator, you could use the attestation transaction time as a proxy for the issuance date if the age of the score is important for your application. As a rule of thumb, we recommend expiring scores 90 days after it was created. Offchain Stamps also expire after 90 days.Here's an example of a score attestation."}},"/building-with-passport/smart-contracts/integrating-onchain-stamp-data":{"title":"Integrating onchain Stamp data","data":{"":"In this tutorial, you'll learn how to show different content to users depending on their Passport data. Here, the Stamp data will be retrieved from the blockchain.Specifically, you will:\nFetch user Stamp data from the blockchain using the Human Passport smart contract stack\nUse Stamp data to generate your own Passport score, using Passport's Stamp weights.\nConditionally display a user's Passport data depending on their onchain data.\nRedirect users to instructions for improving their Passport scores and getting their Stamps onchain.\nYou can learn more about Passport's available smart contracts and the typical developer flow via our contract reference page.","prerequisites#Prerequisites":"To follow this tutorial, you'll need Next.js, Node, and Chakra-UI installed on your machine. You will be using the Optimism Sepolia test network - you will need to import this network into your wallet. Some familiarity with smart contracts is recommended.This app uses a blockchain, rather than Passport's database server, as a backend. This means you do not need an API key or Scorer ID, but you do need to have a browser wallet that can connect to the Optimism Sepolia test network.","app-outline#App outline":"The app we will build will be a webpage where users can connect their wallet to check their onchain credentials.You can find the code from this tutorial in this GitHub repo.The app will work as follows:\nWhen the user visits the sample app, they have access to several tabs - one to welcome them and then more where they can check their onchain data. The second tab shows whether there is any onchain data for the connected user. The third shows what Stamps the user has. The final tab shows the user's Passport score.\nThe user will connect their wallet and Human Passport to the app. Their Stamp data and Passport score will be retrieved from the blockchain and displayed in the UI.\nIf the user does not have any Stamps, the tabs contain information about how to create a Passport, add Stamps and migrate them onchain.\nThis simple example demonstrates the principles you would use to gate a real app using Human Passport onchain.","smart-contract-logic#Smart contract logic":"The Human Passport smart contracts build on top of EAS (Ethereum Attestation Service), using Attestations as the foundational building blocks. You can read the contract reference page for a primer on how the contracts work.The decoder contract exposes an API that allows you to simply pass in an address and retrieve the decoded Stamp and score data, rather than having to retrieve raw Attestations and decode client-side.","setting-up-the-app#Setting up the app":"We'll create an app using Next.js. We can bootstrap using create-next-app. This automatically creates all the necessary subdirectories, configuration and boilerplate code required to get us building as quickly as possible.Start by entering the following command into your terminal:\nnpx create-next-app passport-onchain-app\nThis will create a new directory called passport-app and populate it with several sub-directories and files that form the skeleton of our app. create-next-app will ask for yes/no responses to a series of configuration questions - answer as follows:\nnpx create-next-app passport-onchain-app\n✔ Would you like to use TypeScript? …  Yes\n✔ Would you like to use ESLint? …  Yes\n✔ Would you like to use Tailwind CSS? … No \n✔ Would you like to use `src/` directory? …  Yes\n✔ Would you like to customize the default import alias? … No \nNext, change your working directory to the new my-passport-app directory and install ethers:\nnpm install ethers\nWe also need the Ethereum Attestation Service software development kit:\nnpm install @ethereum-attestation-service/eas-sdk\nFinally, this tutorial will also use Chakra-UI for styling:\nnpm i @chakra-ui/react @emotion/react @emotion/styled framer-motion\nSince the data you will work with is all available on a public blockchain, there is no need to handle any sensitive information such as API keys. You can just get coding!","building-the-app#Building the App":"Now that the app is set up, you can begin building. The code that controls what is rendered in the browser is contained in src/app/page.tsx. When you created your project, create-next-app saved a version of page.tsx with some default code. You can delete all the code in page.tsx and replace it with this boilerplate:\n'use client'\nimport { useState, useEffect } from 'react'\nimport { ethers } from 'ethers'\nimport { ChakraProvider, Flex, Heading, Button } from '@chakra-ui/react'\nimport { TabLayout } from './tab-contents'\nimport { GITCOIN_PASSPORT_WEIGHTS } from './stamp-weights';\nconst decoderContractAddress = \"0xe53C60F8069C2f0c3a84F9B3DB5cf56f3100ba56\";\nconst abi = require('./PassportDecoderABI.json')\ndeclare global {\n  interface Window {\n    ethereum: any\n  }\n}\ndeclare global {\n  var provider: ethers.BrowserProvider\n}\ninterface Stamp {\n  id: number\n  stamp: string\n}\nexport default function Passport() {\n  // here we deal with any local state we need to manage\n  const [address, setAddress] = useState<string>('default')\n  const [connected, setConnected] = useState<boolean>(false)\n  const [hasStamps, setHasStamps] = useState<boolean>(false)\n  const [stamps, setStamps] = useState<Array<Stamp>>([])\n  const [score, setScore] = useState<Number>(0)\n  const [network, setNetwork] = useState<string>('')\n  useEffect(() => {\n    checkConnection()\n    async function checkConnection() {\n      if (connected) {\n        console.log(\"already connected\")\n      } else {\n        const result = await connect()\n        console.log(result)\n      }\n    }\n  }, [address, connected])\n  async function connect() {\n    try {\n      globalThis.provider = new ethers.BrowserProvider(window.ethereum)\n      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })\n      const network = await provider.getNetwork()\n      setAddress(accounts[0])\n      setConnected(true)\n      setNetwork(network.chainId.toString())\n    } catch (err) {\n      console.log('error connecting...')\n    }\n    return true\n  }\n  const styles = {\n    main: {\n      width: '900px',\n      margin: '0 auto',\n      paddingTop: 90\n    }\n  }\n  return (\n    /* this is the UI for the app */\n    <div style={styles.main}>\n      <ChakraProvider>\n        <Flex minWidth='max-content' alignItems='right' gap='2' justifyContent='right'>\n          <Button colorScheme='teal' variant='outline' onClick={connect}>Connect</Button>\n          <Button colorScheme='teal' variant='outline' onClick={queryPassport}>Query Passport</Button>\n        </Flex>\n        <div>\n          {connected && <p>✅ Wallet connected</p>}\n          {connected && network == \"11155420\" && <p>✅ network: Optimism Sepolia</p>}\n          {connected && network != \"11155420\" && <p>🔴 Please switch to Optimism Sepolia network</p>}\n        </div>\n        <br />\n        <br />\n        <br />\n        <br />\n        <Heading as='h1' size='4xl' noOfLines={2}>Onchain Stamp Explorer!</Heading>\n        <br />\n        <br />\n        <TabLayout hasStamps={hasStamps} stamps={stamps} score={score} />\n      </ChakraProvider >\n    </div >\n  )\n}\nNote that you can swap out the contract addresses if you want to run an app on a different network. You can check all the deployed contract addresses on the contract reference pageThere are some parts of this boilerplate code that might look unfamiliar even if you have been through the other tutorials on this site. This is because there is some specific setup required to use smart contracts on the backend.First, the provider field is being assigned as a global variable. The provider is a connection to the blockchain. In this app, the connection is made by inheriting network configuration from your wallet. If you are using Metamask with default settings, your connection will be via Infura to whichever network your wallet is connected to. If you have a wallet pointing to your own node's RPC provider, it will use that. The reason provider is assigned to a global variable is so that it can be captured during the wallet connection but later it can be passed as an argument when you create instances of the smart contracts.The chainID for the network you are connected to is requested from the provider too and the value is stored in the app's state. This is used in the UI to warn the user if they are connected to a network other than  Optimism Sepolia. There are two statuses presented in the UI - one that confirms that the user is connected and one that either confirms the wallet is connected to Optimism Sepolia or warns the user they are connected to the wrong network.Second, there are two contract addresses defined immediately below the import statements:\nconst decoderContractAddress = \"0xe53C60F8069C2f0c3a84F9B3DB5cf56f3100ba56\";\nconst abi = require('./abis.ts')\nThe decoderContractAddress is the address on the Optimism Sepolia blockchain where the decoder contract is stored. The data in abis.ts is a formatted set of function signatures that allow the contract bytecode to be decoded and instantiated in your app (an ABI - Application Binary Interface).The elements imported from tab-contents are components used to build the UI. This file should also be located in the src/app folder, called tab-contents.tsx, and should be populated with the code located in this GitHub file.Otherwise, the create-next-app boilerplate code is quite standard. There is a connect() function that instantiates the provider by grabbing network configuration from your browser wallet (make sure you are connected to Optimism Sepolia) and a checkConnection() function wrapped in useEffect that automatically triggers a connection when the page is first loaded.","getting-passport-data#Getting Passport data":"Getting Passport data requires instantiating the decoder contract and calling its getPassport function. The ethers library provides everything we need to instantiate the contract. Create a contract using new ethers.Contract() passing the contract address, ABI and the provider object as arguments. One complication is that the ABI is divided up into sections specific to each chain where the contract has been deployed, so you actually need to pass a specifier with the hex-encoded chain ID too. Here are the hex-encoded chain IDs for each chain:\nArbitrum: 0xa4b1\nBaseGoerli: 0x1a433\nEthereum: 0x1\nLinea: 0xe704\nOptimism: 0x1a4\nOptimism Sepolia: 0xaa37dc\nScroll: 0x82750\nScroll Sepolia: 0x8274f\nZkSync: 0x144\nZkSync Sepolia: 0x12c\nOnce the contract instance exists, you can simply call getPassport passing in the user address, which is stored in your app's state. If the function call returns some Stamp data, you can set the hasStampData flag to true and return the data.\n/** get passport info from decoder contract */\nasync function getPassportInfo() {\n  console.log(address)\n  const decoderContract: ethers.Contract = new ethers.Contract(decoderContractAddress, new ethers.Interface(abi.DecoderAbi['0xaa37dc']), provider)\n  try {\n    const passportInfo: [] = await decoderContract.getPassport(address)\n    return passportInfo\n  } catch {\n    throw new Error(\"no passport information available\")\n  }\n}","extracting-stamps#Extracting Stamps":"The next step is to write a function to extract the Stamp names from passportData into an array. The following code snippet contains that function - you can paste it into your app:\n/** parse out stamps from passport info object*/\nfunction getStamps(passportInfo: []) {\n  var stamps: Stamp[] = [];\n  for (var i = 0; i < passportInfo.length; i++) {\n    stamps.push({ id: i, stamp: passportInfo[i][0] })\n  }\n  return stamps\n}","retrieving-a-score#Retrieving a score":"Passport scores are calculated by summing weights assigned to each specific Stamp. Passport has defined a list of Stamp weights that are used when scoring is done by the smart contract. The contract exposes a public function, getScore() that returns the Passport score for a given user. You can call the function in the same way as for getPassportInfo().\n/** get poassport score from decoder contract */\nasync function getScore() {\n  const decoderContract: ethers.Contract = new ethers.Contract(decoderContractAddress, new ethers.Interface(abi.DecoderAbi['0xaa37dc']), provider)\n  try {\n    const score = await decoderContract.getScore(address)\n    return score\n  } catch {\n    throw new Error(\"no passport info available\")\n  }\n}\nNow you have implemented all the logic required to retrieve and decode onchain Stamps and calculate a score in your app!","executing-the-functions#Executing the functions":"Now you have all your app functions defined, you need to determine when and how they are executed. You can write a simple wrapper function that calls getPassportInfo() and getScore() and uses the returned values to update the appropriate state variables.\n/** call getPassportInfo and getStamps and set state vars */\nasync function queryPassport() {\n  const passportData = await getPassportInfo();\n  const stamps = getStamps(passportData);\n  if (stamps.length > 1) {\n    setHasStamps(true)\n    setStamps(stamps)\n  }\n  const score = await getScore()\n  setScore(parseInt(score) / 10000)\n}\nNow, all you have to do is call queryPassport() to execute all the necessary logic to retrieve stamps and score.","stamps-and-scores-in-the-ui#Stamps and scores in the UI":"The boilerplate code includes a basic UI that pulls in components from tab-contents.tsx. This will render five tabs to the webpage, each containing different information. This component can take your stamp and score data and render differently depending on their values. This is already handled in the boilerplate UI. What is not yet implemented is a way to trigger the queryPassport() function. You can add a button for this. Right below the existing Button component, inside the Flex tags, you can add the following:\n<Button colorScheme='teal' variant='outline' onClick={queryPassport}>Query Passport</Button>\nYou can browse the contents of tab-contents.tsx to see how the stamp and score data is used to render content. Conceptually, this is what's happening in each tab:\nHome: a general introduction that renders identically for any user\nAbout onchain Stamps: Information about onchain Stamps that renders identically for any user\nAre your Stamps onchain?: If the user has onchain Stamps, has connected their wallet and queried their Passport, the app will render a congratulatory message and confirm that they have onchain Stamps. If the user has not queried their Passport or they don't have any onchain Stamps they see some sad emojis and a message informing them that they have either forgotten to connect or they don't have any onchain Stamps. They are directed to the Passport app to migrate their Stamps.\nBrowse your Stamps: If the user has onchain Stamps, has connected their wallet and queried their Passport, the app will render each Stamp in the browser. If the user has not queried their Passport or they don't have any onchain Stamps they see some sad emojis and a message informing them that they have either forgotten to connect or they don't have any onchain Stamps. They are directed to the Passport app to migrate their Stamps.\nSee your score: If the user has onchain Stamps, has connected their wallet and queried their Passport, the app will render their Passport score. If the user has not queried their Passport or they don't have any onchain Stamps they see some sad emojis and a message informing them that they have either forgotten to connect or they don't have any onchain Stamps. They are directed to the Passport app to migrate their Stamps.","run-the-app#Run the app":"Well done - your app is ready to use! You can run it locally usingnpm run devYou can navigate to localhost:3000 to try it out!The app looks as follows:","summary#Summary":"Congratulations - you have built an app that retrieves user Stamp data from the blockchain, calculates a Passport score and uses that information to conditionally render content to your webpage.Now you can use the principle demonstrated here to build creatively and integrate onchain Stamps into"}},"/building-with-passport/smart-contracts/overview":{"title":"Smart contract overview","data":{"":"Passports onchain functionality enables users to store their verified Stamps and scores onchain, and makes this data available via smart contracts.We also discuss the onchain use cases in the following resources:\nQuick start: Get to \"Hello World\" with the smart contracts\nTutorial: Building an app using onchain Passport data\nReference: Learn about the available smart contracts and typical onchain developer flow","why-onchain#Why onchain?":"In addition to accessing Human Passport data offchain using the Passport API, Passport has also released a smart contract stack that enables developers to access Passport score and Stamp data directly from the blockchain.This onchain Passport data enables partners that want to maintain a decentralized, permissionless backend to engage directly with our smart contracts instead of storing and processing Passport data pulled from our API.","why-not-onchain#Why not onchain?":"Minting Passports onchain is an optional feature for users. Not all users will add their Passports onchain. Also, onchain Passports may not reflect the most up-to-date data for users, since the onchain mint is point-in-time and users could verify more Stamps or Stamps could expire (note that onchain attestations expire).","onchain-passport#Onchain Passport":"Passport data can be converted into onchain attestations that are stored and engaged with via the Ethereum Attestation Service (EAS) or Verax, which make that data accessible to developers via smart contracts. This enables quadratic funding, rewards, governance, access control, and other programs to exist entirely onchain with their Passport integration.A simplified onchain Passport data flow follows this process:\nA user decides to mint their Passport onchain to one of the available networks via the Passport App.\nPassport creates a Stamp (Passport) and score attestation, and mints them onchain to EAS and other attestation registries, depending on which network they choose.\nA developer utilizes our smart contract stack and users’ wallet addresses to request the Passport data from these onchain attestation registries.\nThe developer uses this Passport data in their web3 programs to satisfy their use case.\nOf course, there are some additional complexities to this, including Stamp expirations.","available-networks#Available networks":"This onchain smart contract stack is currently deployed to the following networks:Mainnet\nArbitrum\nBase\nLinea\nOptimism\nScroll\nShape\nZkSync\nTestnet\nBase Goerli\nOptimism Sepolia\nScroll Sepolia\nShape Sepolia\nZkSync Sepolia\nPlease note that you can explore our testnet functionality via the app using Test Mode.","available-registries#Available registries":"Attestations will be minted to one or two different registries, depending on which network the user chose to push their Passport.\nAll onchain Passports will be minted to EAS, regardless of which network the user selects.\nIf the user selects Linea or Linea Goerli, the full attestation will be written to EAS, and a partial attestation will be written to Verax.","why-isnt-passport-onchain-by-default#Why isn't Passport onchain by default?":"Onchain Passports are entirely opt-in. Users can still use Human Passport without migrating your data onchain.While onchain Passports are in their infancy, the offchain Passport is useful as a single source. The offchain infrastructure is also perfectly sufficient for many use cases.","next-steps#Next steps":"Learn more about onchain Passports:\nQuick start\nTutorial\nContract reference\nAttestation schema\nYou can also ask questions about onchain Passports in our developer support channel on Telegram"}},"/building-with-passport/smart-contracts/quick-start-guide":{"title":"Smart contract quick start guide","data":{"":"The Human Passport smart contracts are deployed on several chains, covering both testnets and live networks.\nThere are several contracts that interact with each other to provide the Human Passport backend and API.This quick start will illustrate different ways that you can quickly test pulling data from the Passport decoder contract.","retrieving-data-from-block-explorers#Retrieving data from Block Explorers":"You can use a block explorer to find the Passport smart contracts and query their API directly in the browser, without having to write any code at all.\nNavigate to the decoder contract on a network supported by onchain Passport. In this example, we'll use the decoder deployed to the Optimism Sepolia network.\nMake sure the Read as Proxy tab is open. This is where you can view the methods exposed by the contract.\nOpen the getPassport() or getScore() method.\nEnter a ETH wallet address, click Query, and view the results.\nAvailable methods:\nThe getPassport method will provide the Stamps owned by the given address in the browser.\nThe getScore method will provide the user's score as a 4 digit number. Divide this by 100 to get the user's unique humanity score.\nThere are also several lower level functions that give access to encoded data and intermediate values.\nHere's what a response from getPassport function on the block explorer looks like:","retrieving-data-programmatically#Retrieving data programmatically":"You can also query the API programmatically from the terminal or in an app.The steps are:\ninstantiate a web3 provider\ninstantiate the decoder contract\ncall the contract functions\nHere's a minimal example of how to call the getPassport() and getScore() methods using Web3js in a Javascript app:","instantiate-a-web3-provider#Instantiate a web3 provider":"The provider is your entry point to the blockchain. Ultimately it is the address for a node that exposes a set of methods that allows you to interact with the blockchain.\nIf you run your own node, you can use it as your provider. It is also common to use third party \"RPC\" providers. This is equivalent to using someone else's node.\nIf you are not sure what to use as your provider, your wallet will expose the URLs it is using, and you can copy them into your Javascript application as shown below.To use an RPC provider:\nconst Web3 = require(\"web3\");\nconst rpcUrl = '<your url here>';\nconst web3 = new Web3(new Web3.providers.HttpProvider(rpcUrl));\nTo use a local node (in this case, Geth using IPC):\nvar web3 = new Web3(new Web3.providers.IpcProvider('/Users/myuser/Library/Ethereum/geth.ipc', net))\nNow you have a variable, web3 representing your web3 connection. You can use this to interact with contracts on the blockchain.Note please ensure your web3 provider is connected to the correct network.","instantiate-the-decoder-contract#Instantiate the decoder contract":"Instantiating a contract allows you to interact with a contract deployed on the blockhain as if it were a Javascript object.\nThis requires you to pass the contract ABI (application Binary Interface) and the address on the blockchain where the contract is deployed.\nThe contract ABI can usually be found by querying the contract address on a block explorer, or alternatively it is usually available on a project's Github if the project is open source.\nThe Passport decoder contract ABI can be found on both block explorers and the Passport Github.\nvar Contract = require('web3-eth-contract');\nvar abi = <paste ABI here>\nvar contract = new Contract(jsonInterface, address);\nThe contract variable is a Javascript object exposing the contract methods.","call-the-contract-methods#Call the contract methods":"You can use the contract methods just like Javascript object methods, i.e. contract.method(args).\nTo call the decoder contract's getPassport() method:\nvar passportInfo = contract.getPassport(\"<user-address>\")\nTo call the contract's getScore() method:\nvar score = contract.getScore(\"<user-address>\")","summary#Summary":"This quick start guide demonstrated how to grab information from the Passport decoder contract.\nYou have the option to query the contract using the block explorer UI or programatically using a library such as web3js.\nThere are equivalent libraries in other languages too, such as web3py for Python, web3 for Go,\nand ethers for Rust and Javascript.","next-steps#Next steps":"Explore our contract reference page to find all the details about the various Human Passport contract deployments.\nThen you could try our more advanced smart contract app tutorial.If you have more questions you can chat in our developer support channel on Telegram."}},"/building-with-passport/smart-contracts/test-mode":{"title":"Test mode","data":{"":"As developers, we often want to test our apps and integrations on testnets, where there is nothing of real world value at stake, before we go live on a live public mainnet. You can always deploy the Passport smart contracts to your own local ephemeral blockchain, but it is also recommended to test your integration on a public testnet too, as this more realistically simulates a mainnet environment.For this reason, the Passport team deployed the Human Passport smart contracts on public testnets, including OP Sepolia and Linea Goerli.","test-mode-in-the-passport-app#Test mode in the Passport app":"The Passport app can be run in test mode by visitng URL and following the steps below:https://app.passport.xyz#/testing/dashboardThis enables you to write Passport data and scores to the Human Passport smart contracts on several testnets, meaning you can experiment and get comfortable with the flows before trying it out on Mainnet.When you sign in to the Passport app, you first have to enable Test Mode. There is a button for this at the top of the page. Enabling Test Mode requires an additional signature from your Ethereum account.Once Test Mode is enabled, you can click on Bring Passport onchain towards the bottom of the Passport app to view the supported testnets in a panel that pops out from the right-hand side of the page. The app switches over to whichever network you select by clicking on the preferred network in the panel in the app's UI.Other than the network selection panel, the behavior of the test app is identical to the real, \"live\" Passport app.","test-mode-for-developers#Test mode for developers":"Test mode also gives developers the ability to read and write to Passport smart contracts and also develop and test Passport integrations into their own smart contracts. On test networks, this can be done without spending any real ETH on gas fees and without putting any assets at risk from exploits.Since the Passport contracts are deployed on public testnets as can be used by anyone, there are proper Passport data and many integrations on these testnets that offer a much more realistic test environment than local, ephemeral blockchains and the Passport contracts are already deployed there and managed by the passport team, easing your development process.To work in Test Mode, developers simply have to switch their development environments onto one of the supported test networks and use the appropriate contract addresses for that network.","which-networks-are-supported#Which networks are supported?":"The available test networks are:\nOptimism Sepolia\nLinea Goerli","testing-on-mainnet-forks#Testing on mainnet forks":"The Passport smart contracts may sometimes be upgraded after being deployed. If you are testing on a mainnet fork, you must make sure you fork the blockchain at a block after the latest contract deployment. Otherwise, the contracts stored in your forked blockchains state will be out of date. The block where the latest version of the contract is deployed is known as the latest stable block and you can find out what it is by looking at the contract deployment details on the appropriate block explorer for the network you want to fork. Then, fork the blockchain at a block greater to or equal to the latest stable block.For example, the latest stable block for OP mainnet is 115525426. Your test network must fork off OP mainnet at a block >= 115525426."}},"/community/getting-involved":{"title":"Getting Involved","data":{"identity-providers#Identity Providers":"If you're an identity provider and want to integrate with the Human Passport check out the documentation for Integrating a new stamp into the Passport.Creating a new Stamp","app-builders#App Builders":"If you have an app that has integrated the Passport let us know! We're happy to offer support and would love to hear about your experience building with the Passport API.Come find us in our Human Passport Developers Telegram.","devrel-and-tech-writers#DevRel and Tech Writers":"If you spot some areas to improve our docs visit our Github.We'd love to get your PRs incorporated and help make this documentation as comprehensive and accessible as possible!You can also chat on our developer support channel on Telegram."}},"/community/passport-github-projects":{"title":"Passport GitHub Projects","data":{"production-passport-codebase#Production Passport Codebase":"","ceramic-nodes#Ceramic Nodes":""}},"/community/style-guide":{"title":"Style guide","data":{"":"This style guide lays out the basic standards for the documentation on this site. This is to encourage standardized syntax, tone, grammar and styling across the site. The aim of the style guide is not to stifle individualism, but to empower a diverse set of contributors from across the community by:\nbeing clear about the best practises we want to adhere to\nbeing clear about the criteria by which pull requests will be evaluated\nbeing transparent about the guiding philosophy\nwhile also serving our audience of users and developers by:\nmaintaining a consistent \"voice\" across the site\nlowering barriers to entry by consistentlyusing welcoming and accessible language\nmaking it easy to find the right information","audience-personas#Audience personas":"Our documentation serves two primary personas: users and developers.Users are people interested Human Passport because of the activities it unlocks for them. They are most likely interested in how to use their Passport, but less interested in how it works under the hood. They want to know, for example, how to create a Passport for the first time, or how to maximize their score to access apps. They probably are not interested in seeing code.Developers are people building apps that integrate Human Passport. They might not be users themselves, and they are most interested in understanding how to build Human Passport into their own applications. They are more interested in the mechanics of how Human Passport works and will want to see code snippets, example and reference documentation.These personas are best served separately, so that users are not burdened with uneccessary details and developers can easily find the right information to unlock their building.The documentation on this site is therefore divided into two distinct pathways. One serves users and the other serves developers. It is important to think about which group of users you are serving when you add a new page.","information-architecture#Information architecture":"This site generally aims to conform to the modular documentation specs defined by RedHat. This is because the documentation is user-centric and intended to guide readers to complete specific tasks.Modular documentation generally follows a heirarchy that first separates information into distinct user stories.Each user story is then subdivided into individual self-contained chunks called modules.Each module can be one of three types: concept, procedure or reference.A concept module gives the reader descriptions, explanations and examples that help them understand some aspect of a product. A procedure module explains how to achieve some specific task. A reference module provides useful data or syntax reminders for users so that they don't have to remember them.On this site, we first divide the content according to user persona: users and developers.Then, each subdivision is a specific user story - that is some specific objective the reader might have. For example, Creating a Passport is a user story. It is clear what the intended outcome of this section is: the user should learn how to create a Passport. The individual modules are the sections on the page that explain some particular step the user needs to take to achieve the overall aim of creating a Passport.An example of a procedure module on the Creating a Passport page might be Getting an Ethereum address and it would aim to guide the user through the process of getting an Ethereum address. An example of a concept module on the page could be What is a wallet? - the aim of the module would be to explain the concept of wallets. A reference module on the page could be Useful Links and it would simply list useful links for this user story on the page as a convenience tool.This is the overall information architecture that the site aims to conform to, because it is oriented around helping a reader to achieve specific objectives using Human Passport. If you add pages to the documentation, please take the time to think about how it can fit into this high level philosophy.","global-styles#Global styles":"There are some core principles that serve both users and developers equally well. These should be applied across the entire site.","language-and-tone#Language and tone":"Active voiceUsing active voice, rather than passive voice puts the subject of the sentence first, making the writing more impactful and relatable. It makes the relationship between actor and action very clear.An example of using the active voice over the passive voice is:the developers wrote some coderather thansome code was written by developersThere are occasions when the passive voice is appropriate, such as when there is no clear subject for the sentence or the subject is irrelevant. For example, 100 ETH was added to the account. However, as a general rule, we will try to prioritize using the active voice.Action orientedAction-oriented prose emphasises specific tasks that have some tangible outcome. For example, it is preferable for us to write abouthow to read a Passport scorecompared tousing the scorer API.The former emphasises the benefit the page will have on the user (they will learn how to achieve a specific objective, in this case reading a Passport score) instead of being open-ended and \"feature-oriented\".Second-person narrativesYour writing can feel more accessible and engaging if you refer to the reader directly. This means using the personal pronoun \"you\" and making direct instructions to the reader. It implies that the reader is the main character and that the documentation is made to help them on their journey.For example, use:connect your Passportinstead ofthe passport can be connectedorthe user can connect their passportConscious languageYou should use conscious language as much as possible. This is because the documentation is supposed to be accessible to as many people as possible. We want to create a welcoming, inclusive environment and avoiding trigger words and unneccessarily offensive terminology goes a long way to making people feel valued.JargonYou should try to avoid jargon wherever possible. This helps to create a friendly tone and prevents readers from being intimidated by unfamiliar terminology.AcronymsAcronyms should be spelled out in full on the first use on a page, with the acronym itself in parentheses. Subsequent uses can refer to the acronym only. For example:Ethereum uses a proof-of-stake (PoS) based consensus mechanismCapitalizationYou should start proper nouns with capital letters. This includes capitalizing the word \"Passport\" when it refers to Human Passport. Other examples that occur frequently across these docs include: Ethereum, Gitcoin, Ceramic, DID, Scorer, Mainnet etc.","styling#Styling":"HeadingsHeadings are styled using the hash character (#). The number of hashes preceding the title corresponds to the level of the heading. For example, a single hash creates a top level heading. Two hashes is a second-level heading.In these docs the page title should be a top level (single hash) heading. All other headings should be minimum of second-level (two hashes). Nesting up to 5 hashes is allowed.e.g.\n# Main page title\n## Section One\n  ...\n### Getting started\n  ...\n#### Some more details\n  ...\n##### Really fine detail 1\n  ...\n##### Really fine detail 2\n  ...\n### Moving on\n  ...\n#### Some fine details\n  ...\n## Section 2\n  ...\n### Getting started\n  ...\n#### Details\n  ...\nLinksInline links are fine, but it is best if they are not too frequent. A good rule of thumb is to have fewer than 5 inline links per paragraph. More than that can become distracting for the reader.Link texts should be descriptive. This means linking from, e.g.\"more information in the React documentation\"rather than\"more information here\".In this example the reader expects to be directed to the React documentation before they even click the link, reducing some friction. It is also reassuring from a security perspective (because it is clear to readers where a link is intended to take them) and makes it easier to maintain the site when links are updated later.When linking to internal pages, use relative paths, e.g./devs/getting-startedoverhttps://docs.passport.xyz/devs/getting-started.ImagesImages can be embedded in pages using standard markdown notation:![alt text](path-to-image)You should save the image into the /public folder and use the relative path to it in the link, rather than linking to an external resource. Any images that require aknowledgements must have them included clearly in the image caption or in text immediately beneath the image. Do not add any images that would break copyright.","styles-for-users#Styles for Users":"Users are people that are interesting in using Human Passport to demonstrate their identity/credentials. They are not interested in writing code. Users are a very diverse group of people from a range of backgrounds with a variety of experiences and expertise.This means we should use language that is accessible as possible and avoid using words that are specific to the software industry. Jargon from web3, software development or any other technical industry are likely to be points of friction for at least some of our Users.To be as inclusive as possible, we should use language that as many people as possible can understand without having to look things up.Images and screenshots are helpful because some Users will learn better from visual assets than from text.","styles-for-developers#Styles for Developers":"Developers want to write code that incorporates Human Passport into their applications. This means developers like to see examples in the form of code snippets. In our markdown files, code snippets are wrapped in three \" ` \" characters. The language can be defined in the same line. So, for example:```js\nconsole.log(\"some javascript code\")\n```renders as:\nconsole.log(\"some javascript code\")\nDevelopers probably also appreciate frequent links to external documentation and API references, and links to Github repositories with full application code.","internationalization#Internationalization":"Right now we are an English-language only site. We would prefer to be available in many languages! If you can help us to internationalize our documentation, get in touch through Github or Telegram!"}},"/":{"title":"Human Passport Documentation","data":{"":"The citizenship pass for the decentralized internet.Human Passport is an identity verification application and Sybil resistance protocol.\nIt enables users to collect verifiable credentials, or Stamps, that prove their identity and trustworthiness without exposing personally identifying information. Apps and organizations can then utilize Passport to protect their community and projects from sybil attacks and other bad actors.These developer docs describe the Passport API and smart contract stack you can use to build Passport into your app, as well as the criteria and process of becoming a Stamp partner.","who-are-you#Who are you?":"","passport-user#Passport user":"","developer-building-with-passport#Developer building with Passport":"","stamp-provider#Stamp provider":"","get-involved#Get involved":""}},"/overview/active-integrations":{"title":"Active integrations","data":{"":"This page contains a condensed list of active integrations that have produced guides detailing how to leverage Passport within each ecosystem.To find a complete list of ecosystem partners, please visit the following page:","guildxyz#Guild.xyz":"Guild.xyz is a the infrastructure for platformless access management. Create portable memberships, social structures around on- & off-chain requirements and build unique user journeys across apps.It's a great tool to gate access to Discord roles, Telegram channels, and more.You can use a certain Passport score threshold as a requirement to gain access to your community tools.","galxe#Galxe":"Galxe provides tools to help build Web3 communities. Their tools enable you to build streamlined user onboarding and retention campaigns, and can also gate access to Discord.While a Passport-specific guide hasn't been set up yet, you can learn more about customizing campaigns with Passport at the following link:","snapshot#Snapshot":"Snapshot is a voting platform that allows DAOs, DeFi protocols, or NFT communities to vote easily and without gas fees.Snapshot enables you to use Passport in two different ways: Gate access to submitting proposals, and gate access to voting.Learn more at the following link:","discourse#Discourse":"Discourse is an open source Internet forum system that is used as a governance tool for many web3 organizations.You've got a few different opportunities to use Passport to assign roles and gate access!There are actually two different plugins that you can use with Discourse! We are more impressed with the level of documentation provided by Dappy.lol though.","collabland#Collab.land":"Collab.Land is a community management tool that supports a wide range of projects, including DAOs, NFT communities, brands, and creators of all sizes.As with any community management tool, roles are critical for providing different levels of access. The Collab.Land integration allows you to gate access to roles to just those users who can prove their humanity on Passport!Learn more here:","missing-something#Missing something?":"While we do list our full list of integration partners on our ecosystem page, we want to continue to build out this page with links to partners who have instructions on how to use Passport within their ecosystem.If we missed a partner, please feel free to submit an issue or open up a pull request by clicking the \"Edit this page\" button in the right sidebar!"}},"/overview/key-terms":{"title":"Key terms","data":{"passports#Passports":"The example below shows the JSON data format for a Human Passport. This is an example of a Decentralized Identifier (DID), as defined in the W3c documentation. Each passport contains a field named stamps. This is a array where your Stamps are stored.To see what each Stamp looks like, scroll down to the Stamps section. When you add Stamps to your Passport, they are pushed into this array. The entire Passport (DID) object is stored on the Ceramic network and associated with your Ethereum address.\n{\n\t\"issuanceDate\": null,\n\t\"expiryDate\": null,\n\t\"stamps\": [\n\t]\n}","passport-protocol#Passport Protocol":"The \"Passport Protocol\" refers to the infrastructure that enables web3 citizens to create their own Passport, prove their decentralized identity and access Passport-gated projects. It is all the tooling that enables developers to build Passport gating into their apps.Web3 citizens interface with the Passport Protocol through the Passport holder dApp at app.passport.xyz. Developers can use the Passport API to easily integrate Human Passport into their apps.","passport-gating#Passport-Gating":"\"Passport gating\" means integrating the Passport Protocol into an app for the purpose of screening accounts to keep out bots, bad actors, or simply real people who don't meet a certain threshold of trustworthiness.Usage:\n\"I like how this project gated its community with Human Passport. I'm going to ask the project owner for their gating algorithm, so I can use it for inspiration.\"\n\"Some examples of Passport-gated dApps include: Snapshot, Bankless Academy, and Gitcoin Grants.\"\n\"Because this community is gated with Human Passport, it is able to ask for pieces of proof of not just identity via services like BrightID, but also reputation via services like POAP.\"\nSee our tutorials to learn how to gate your project.","stamps#Stamps":"Stamps are the key identity verification mechanism of Human Passport. A Stamp is a collection of one or more verifiable credentials from an identity provider that is collected in a Passport. Stamps are provided by a variety of web2 and web3 identity authenticators including Google, Facebook, BrightID, ENS, and Proof of Humanity. Custom Stamps for particular communities are under development. Stamps do not store any personally identifiable information, only the verifiable credentials issued by the identity authenticator.Passport aggregates Stamps and assigns each Stamp a different weight according to the needs of a particular community. This weight is used to calculate the cost of forgery of an identity, a score which reflects the credibility of a potential participant’s online identity. For example, a community for developers could assign a greater weight to a Github Stamp, resulting in higher scores for those who have Github Stamps.The code snippet below shows a single Stamp. This particular Stamp proves ownership of a Discord account. The Stamps array in the Human Passport object contains multiple instances of this data structure representing each different passport Stamp. All the Stamps conform to this specific format inherited from https://www.w3.org/2018/credentials/v1.\n{\n    \"provider\": \"Discord\",\n    \"credential\": {\n        \"type\": [\n            \"VerifiableCredential\"\n        ],\n        \"proof\": {\n            \"jws\": \"..Ac4ey_k49EFc--GHQKwSvW-0xzdBA\",\n            \"type\": \"Ed25519Signature2018\",\n            \"created\": \"2023-04-20T12:31:48.468Z\",\n            \"proofPurpose\": \"assertionMethod\",\n            \"verificationMethod\": \"did:key:#zKKkghvGHLobELLhS4LPGJAvz2cRyqmYU5LC\"\n        },\n        \"issuer\": \"did:key:z6MGH1tn2zcRobLEdj1bgJLhS4LPGGAvbMARkghvymqYU5CL\",\n        \"@context\": [\n            \"https://www.w3.org/2018/credentials/v1\"\n        ],\n        \"issuanceDate\": \"2023-04-20T12:31:48.468Z\",\n        \"expirationDate\": \"2023-07-19T12:31:48.468Z\",\n        \"credentialSubject\": {\n            \"id\": \"did:pkh:eip155:1:0x281aa163B9b0927B8B5C68e5A009ddD06a103Eeb\",\n            \"hash\": \"v0.0.0:Hl1gllZWqCCj69w9nmsjbaaahK3QtZthAE7/ku/jN7s=\",\n            \"@context\": [\n                {\n                    \"hash\": \"https://schema.org/Text\",\n                    \"provider\": \"https://schema.org/Text\"\n                }\n            ],\n            \"provider\": \"Discord\"\n        }\n    }\n    }\nStamps are added and removed from the the Passport service as the product evolves. To learn more, please visit our Stamps overview for developers.The weights assigned to individual Stamps in the Passport scoring app can also change if re-weighting is likely to improve the overall Sybil defence efficacy of the Scorer.","verifiable-credentials-vcs#Verifiable credentials (VCs)":"Each Stamp is composed of one or more \"verifiable credential\". These credentials are individual pieces of evidence that can be tested in order to issue a Stamp. For example, the Github Stamp includes VCs for several different properties of a user's Github account, including the Github OAuth (can the user sign in to the account) and the number of followers, forks and stars the user has accumulated. Together, these VCs comprise the Github Passport Stamp.","ethereum#Ethereum":"Ethereum is a blockchain network. It is secured using a proof-of-stake based consensus mechanism and contains an embedded computer that allows apps to be built on top of it. Discrete units of executable code living on the Ethereum blockchain are known as smart contracts. Read more on Ethereum at ethereum.org.","ethereum-address#Ethereum address":"Ethereum users interact with the network using an account. An account is really a pair of keys. One key is known as the 'private key' which is used to sign and send transactions. The other is the 'public key', which is used to create a unique address used to identify a particular user. In Human Passport, users' Ethereum addresses are used to identify which Stamps they own. Their private keys are used to demonstrate ownership of that address.","hash#Hash":"A hash is the result of applying a hash function to some data. A hash function takes some data and returns a unique string of characters of fixed length (the hash). The hash function is deterministic, meaning the same data will always return the same hash, but it is extremely difficult to recover the original data from the hash. This makes the hash useful for efficiently validating data.","duplication-of-stamps#Duplication of Stamps":"The Passport itself does not require a unique underlying account to issue a VC. This means that any number of wallets can create Passports that link to the same underlying identity. While it is fine for an honest user to have multiple Passports, for example to maintain different user profiles (for example \"home\" and \"work\") it is not acceptable to use the same credential multiple times to influence a single outcome. Passport is built to support contextual identity so you can maintain Passports that you use within specific communities. It's also important for recoverability that Stamps are not bound to a single Ethereum address - otherwise losing access to your wallet means losing the ability to prove your identity using the Stamps that had previously been tied to it.To enable users to maintain distinct personas is different communities, but simultaneously prevent dishonest multiplication of Stamps we have added a hash field to the Passport Stamps.This hash is a unique identifier that is generated for all VCs issued by the Passport server. It allows a Stamp to be uniquely identified, so a particular app can check that it has only been used once, while preserving anonymity.As a developer, you don't need to implement any logic for deduplicating Stamps if you use the default scorer. The deduplication is done server-side. However, if you are building a custom scorer you may want to store the hashes and deduplicate Stamps yourself to prevent users from submitting the same set of Stamps in multiple Passports.More details about Passport deduplication can be found on our Deduplicating Stamps page.","streams#Streams":"Passport identity data is stored as a decentralized data stream on Ceramic. Streams are individual instances of state on the Ceramic network. They are mutable and can only be altered after receiving a transaction signed by the account that owns it. These data streams are what allow Passport data to be interoperable and portable across multiple chains and dApps.","scorer#Scorer":"A Scorer is an instance of a scoring algorithm. The Passport API that offers a straightforward way for developers to interact with the Passport Protocol, including adding Passports to a registry and calculating the Passport score using a scoring algorithm.The Scorer assigns a score to a Passport by summing weights assigned to individual Stamps. Please note that the weights assigned to individual Stamps can change over time in order to provide the best Sybil defence. You can also implement your own scoring algorithm using Stamp data.","scoring-mechanisms#Scoring Mechanisms":"To evaluate the unique humanity of users in web3 applications, Human Passport has devised two scoring mechanisms - Gradual Unique Humanity Verification and Boolean Unique Humanity Verification. These mechanisms consider multiple Stamps connected to a Passport holder, such as verified Twitter and Google accounts, possession of GTC or ETH, and previous participation in Gitcoin Grants. Each Stamp is assigned a weight based on its significance in assessing the unique humanity of the Passport holder. These weights are used as inputs to an algorithm that calculates a Passport score for the holder. The weights are defined in the Passport Github.The approach for scoring is designed to focus on interactions across a wide range of technology platforms, where the global maxima for a Passport score is quite high, making it unrealistic for real humans to achieve a perfect score. Nevertheless, these scores can still be used to grant access to partial rights, features, and other benefits to Passport holders based on their score. For instance, developers may offer access to a web app to users with a score above a particular threshold, or provide special features to power users with scores above a certain level.The Gradual Unique Humanity Verification mechanism allows developers to assign partial rights to users based on their unique humanity score. For example, a user with a score of 30/100 may receive 30% of a full testnet ETH faucet payment, while a user with a score of 45/100 may have their votes multiplied by 45/100. Developers can customize the gradual weights in various ways to tailor their application.The Boolean Unique Humanity Verification mechanism is aimed at preventing bot/sybil attacks and safeguarding user privacy. It involves asking users to verify a particular set of Stamps, each with a specific significance in assessing their unique humanity. Users are deemed unique humans if they meet or exceed the predetermined threshold of verified Stamps that reach a combined score above a certain threshold.The algorithm used to calculate Passport scores is transparent and easily auditable. The exact formula used to calculate the score is available in the Passport Scorer code base, and the scoring weight of each Stamp is determined by Human Passport's data scientists based on the identities of users in previous Gitcoin Grants rounds and other Human Passport use cases. By using these scoring mechanisms, developers can ensure that only unique humans are able to participate in their applications while still preserving the privacy of users.","pagination-api#Pagination (API)":"Some API requests might return large amounts of data. For example, the data returned from /registry/stamps returns information about every individual Stamp owned by a given address, possibly including all the associated metadata too. It can be convenient to break this data up into more manageable pieces. The way to do this is using API pagination.By adding a query to the API request, you can receive chunks of the data. Take, for example, the following request to the Stamp registry:\ncurl --request GET 'https://api.scorer.gitcoin.co/registry/stamps/{address}?include_metadata=true'\nThis request could return a large amount of data if the given address owns a lot of Stamps. In this case, it could be useful to paginate the response, which means the API will return a subset of the total data. You can do this by adding &limit=x to the API request, where x is the number of elements (in this example, Stamp objects) to return in each response.More detail, including an explanation of how to navigate paginated responses, is provided in the API reference.","sybil#Sybil":"A Sybil is a fake user. Many applications require confidence that each of their users represents a real human individual rather than a bot or an impersonator. However, users can try to create multiple personas that they use to access a service, gaining more than their fair share or reward or influence. Each of these dishonest personas is known as a Sybil. Take voting for example; if a user can create ten accounts and convince a platform that they are all valid, then they have multiplied their influence over the outcome of the vote by 10x. Human Passport is an anti-Sybil tool because it makes it harder for attackers to convince platforms that these Sybil accounts represent genuine users."}},"/overview/use-cases":{"title":"Use cases","data":{"":"Human Passport's developer platform enables several key use cases:\nProtect access to rewards, governance, communication channels, marketplaces, and developer tools.\nDemonstrate trustworthiness to enable users to make better decisions about their online interaction\nWeigh user activities based on Passport score\nImprove Passport’s user experience","passport-use-cases#Passport use cases":"","protect-access-rewards#Protect access: Rewards":"","sub-use-cases#Sub use cases":"Quadratic funding matching donation pools\nNFTs\nAirdrops\nFaucets\nQuests\nSpecial access","description#Description":"One of the primary reasons why Sybils exist is to take advantage of community rewards programs. Whether you’re offering NFTs, airdrops, faucets, or other incentives programs, you want to make sure that your rewards are going to just those humans that deserve it.By protecting access to Passport holders that have a score over a certain threshold, you are ensuring that your community rewards programs are properly distributed.","active-integrators#Active integrators":"Gitcoin Grants\nBankless Academy\nCyberConnect\nGalxe\nShapeshift\nLinea","protect-access-governance#Protect access: Governance":"","sub-use-cases-1#Sub use cases":"Submitting proposals\nVoting","description-1#Description":"Running a DAO is hard enough without Sybils submitting proposals and influencing a vote in their favor. You can prevent this by protecting access to your governance platforms using Passport.","active-integrators-1#Active integrators":"Discourse\nSnapshot","protect-access-communications#Protect access: Communications":"","sub-use-cases-2#Sub use cases":"Provide specific roles and permissions\nBlock unwanted inbounds","description-2#Description":"Tired of low-quality inbounds or contributions to a communication channel? Protect access to certain channels, roles, or actions within your communications platform to ensure your users have high-quality interactions.","active-integrators-2#Active integrators":"Discourse\nGuild\nCollab.land\nMetaforo","protect-access-marketplace#Protect access: Marketplace":"","sub-use-cases-3#Sub use cases":"NFTs\nConcert tickets\nOther products and services","description-3#Description":"You’ve got a marketplace that is free and open for users to create and sell content. However, you’ve recently had a string of Sybils creating low-quality projects, or trying to unfairly buy all of the inventory for high-quality projects. Let Passport help to protect these. #PassportCanFixThat","prove-reputation#Prove reputation":"","sub-use-cases-4#Sub use cases":"Demonstrate user trustworthiness\nProve user activity on web2/3\nThere are many situations where a user would benefit from being able to judge for themselves whether another user is trustworthy or not. By displaying Passport scores and verified Stamps, you can help your users make better decisions about who they interact with on the web.","active-integrators-3#Active integrators":"{R}elinked\nRarimo\nSismo","weigh-user-activities-according-to-score#Weigh user activities according to score":"","description-4#Description":"You have functionality where users help to select which content or ideas are prioritized on your platform. Let the proven humans with a strong Passport score have a heavier weight in deciding this content.","active-integrators-4#Active integrators":"Gitcoin Grants","improve-the-passport-experience#Improve the Passport experience":"","description-5#Description":"Passport is the premier solution for Sybil defense. Help us further our goals by building solutions that help to improve the user experience for people using or building on top of Passport.","other-community-programs#Other community programs":"We’re very interested in unique use cases that utilize the Passport developer products.Please feel free to reach out to us on our Passport Developer Telegram to bounce new ideas off us! We will also help promote your unique ideas through our marketing channels.","use-cases-by-audience#Use cases by audience":"Who you are\tUse Case\tEvent Organizer\tPassport-gate access to an event, only allowing people with certain Stamps in their Passport to attend. Tutorial\tGrants program manager\tIntegrate Passport into a quadratic funding (QF) program (such as Gitcoin Grants) and only offer matching funds to donors with a Passport score over a certain threshold. Tutorial\tCommunity organizer\tGate a sub-community with Passport, only allowing access to members that have earned a certain set of Stamps through meaningful participation in the community. Tutorial.  Enable community members to prove to other members that they are trustworthy by displaying connected Stamps on their profile. Tutorial\tDeveloper of an online marketplace\tUse Passport to gate their marketplace and only allow access to or distribute funds to trusted users, aiming to reduce fraud on the platform. Tutorial\tAirdrop experience manager\tRequire users to have certain Stamps or a score above a threshold to exclude airdrop farmers. Tutorial\tDeveloper of an online polling service\tUse Passport to gate polls by requiring participants to have a score over a certain threshold to prevent bot manipulation and increase the trustworthiness of your results. Tutorial"}},"/overview/why-passport-xyz":{"title":"Why Human Passport","data":{"":"Human Passport is a Sybil resistance protocol and identity aggregation dApp built on the Ceramic Network. Users can collect various identity attestations, called \"Stamps\", from web2 and web3 authenticators all in one place.Many systems, like Gitcoin Grants, assume each participant is a unique human, and offer rewards for these participants. This makes them vulnerable to sybil attacks, where a bad actor creates a large number of pseudonymous identities to subvert the service’s reputation system, gain a disproportionate amount of influence, and direct rewards towards extractors.Credible identity verification and reputation mechanisms are essential to combat this. Applications liked BrightID, ENS, and POAP each help suggest whether an account is associated with a real human, but they are only truly powerful when they compose with each other.Projects need a way to evaluate these disparate \"identity providers\" altogether.That's where Human Passport comes in.We originally created Passport for Gitcoin's needs: to defend Gitcoin's Grants program from Sybil attacks so that only real people can help decide which projects receive funds from a shared matching pool.One thing we have learned from defending the Gitcoin Grants program is this: Sybil defense is complicated and resource intensive. Yet it is essential for any web3 project that hopes to have longevity, because users will not stick around if your project is filled with scammers.As we developed years of in-house expertise in sybil defense, we saw a responsibility to help other web3 projects protect their communities from bots and bad actors.Because we believe that private identity verification is a public good, we decided to turn Passport into its own product.With dozens of identity providers using Passport to protect their communities, Passport is on track to become the leading, open-source identity verification protocol in the world."}},"/stamps/overview":{"title":"Stamps developer overview","data":{"what-is-a-stamp#What is a Stamp?":"Stamps are the key identity verification mechanism of Passport. A Stamp is a collection of one or more verifiable credentials from an identity provider that is collected in a Passport. Stamps are provided by a variety of web2 and web3 identity authenticators including Google, BrightID, Holonym, Civic, ENS, and more. Stamps do not store any personally identifiable information, only the verifiable credentials issued by the identity authenticator.Passport aggregates Stamps and assigns each Stamp a different weight according to the needs of a particular community. This weight is used to calculate the cost of forgery of an identity, a score which reflects the credibility of a potential participant’s online identity.The Passport team is highly selective about the new Stamps that are added to the platform. To be considered, you can follow the steps outlined in on this page.","stamp-assessment-criteria#Stamp assessment criteria":"When new Stamps are proposed we evaluate them according to some key criteria:\nStrong non-Sybil signalStamps should represent some strong method for identifying Sybils vs non-Sybils so that we can ensure that each Stamp helps to improve the Sybil-defense that Passport offers. We prioritize new signals that are unique or different to the signals we have already have in Passport. It’s ideal if there’s already data, from internal efforts, indicating the effectiveness of the credentials.\nFree (or very cheap)We have heard feedback from end users who are frustrated by the costs of some of the existing Stamps. Where possible we'd like to expand the set of free or very cheap options available to our users.\nEasy to useEnsuring that a user can quickly get set up and verified is important to the overall Passport and partner platform's success. We’ll prioritize those Stamps and credentials that can be included in the existing ‘1-click’ verification flow.\nStrong partnershipWe pass Sybil data back and forth in an aggregate and anonymized way with our strongest partners to help all parties improve Sybil defense. We expect future partners to participate in this program as well.\nSubstantial user baseThe more users you have, the more users we can start offering Sybil defense to. This also helps grow the Passport ecosystem as each new partner helps grow all partners.","what-types-of-stamps-would-we-like-to-see-more-of#What types of Stamps would we like to see more of?":"We are specifically interested in Stamps that are accessible in areas of the world that are currently under-represented, such as Asia, Africa, and Latin America. This is so people in those regions don't find it more difficult to prove themselves to be real users than people from other areas.Similarly, we are interested to see more Stamps that are accessible to new-comers to Web3, but still match our key criteria.","process#Process":"If you believe your Stamp meets the criteria described above, then you should submit your Stamp using this form.We review form submissions periodically and will get back to partners who's Stamps we want to integrate as soon as possible.If we decide to move forward with your Stamp, the next step is to follow the instructions in this guide."}},"/stamps/integrating-a-new-stamp":{"title":"Submitting a Stamp pull request","data":{"":"This guide is reserved for those partners who have been approved by the Human Passport team to submit a pull request.If you haven't been approved yet, please visit the Stamps overview for developers page, and follow the steps there.\nCreating a new Stamp involved defining verification logic and adding configuration details to our existing Stamp infrastructure.We have a standardized format for Stamps and this page will help you to understand all the information you need to provide. The process begins by creating your own copy of our GitHub repository. The instructions on this page will walk you through how to change the codebase to support your Stamp and submit the changes back to the Human Passport team.","1-fork-the-human-passport-github-repository#1. Fork the Human Passport GitHub repository":"Whether you want to create an EVM or a non-EVM Stamp, the process begins by forking the Human Passport GitHub repository. Clone your fork and navigating to the platforms directory.Here is our GitHub repository.This is the platforms directory, located at passport/platforms.","2-create-new-files#2. Create new files":"Adding a Stamp requires you to create some new files inside the platforms/src directory. Inside platforms/src create a new directory and name it according to your Stamp. In the test here we will use the word example.For example, the following would be an appropriate command for a bash user:\ncd platforms/src && mkdir example\nInside example,  create the following subdirectories and files:\n# files to create inside platforms/src/example:\n  __tests__\n      |-- example.test.ts\n  Providers\n      |-- example.ts\n  App-Bindings.ts\n  index.ts\n  Providers-config.ts\nEach of the files you just created has a distinct purpose, as described in the following table:\nfile\tpurpose\t__tests__/example.test.ts\tincludes thorough test cases for the Stamp\tProviders/example.ts\tincludes a verify() function that receives a proof and verifies it.\tApp-bindings.ts\tCollects all the Stamp data and formats for communication with the Human Passport server\tProviders-config.ts\tCollects Stamp metadata. For example, icon image, name and description, provider settings\tindex.ts\tExports the providers, config and app bindings\t\t\t\nYou will also need to update some information in existing files in platforms/src but for now we can focus on adding the right information to these newly created files. For the App-bindings.ts file specifically, the instructions are slightly different for EVM and non-EVM Stamps.","app-bindingsts#App-bindings.ts":"Updating App-bindings.ts is slightly different depending upon whether you are creating an EVM Stamp or a non-EVM Stamp.What is an EVM Stamp?Some Stamps rely upon the Ethereum Virtual Machine (EVM) while some rely upon OAuth to determine ownership. If your Stamp represents some web3 native credential such as ownership of a digital asset (for example, ETH, some ERC20 token, NFT or POAP) or onchain activity (for example, certain transaction) that can be verified by querying the blockchain, then your Stamp is an EVM Stamp. If your Stamp relies on ownership of some web2 account that your users login to, then it is a non-EVM Stamp.","evm-stamps#EVM Stamps":"Copy the following code into the file, replacing <EXAMPLE> with your Stamp name. Note that for EVM Stamps the AppContext and ProviderPayload types are imported from \"../types\" and thePlatform class is imported from \"../utils/platform\".The new Stamp is exported as a class extending the Platform class.\n//App-bindings.ts - EVM\nimport \\{ AppContext, ProviderPayload } from \"../types\";\nimport \\{ Platform } from \"../utils/platform\";\nexport class <EXAMPLE> extends Platform \\{\n    platformId = \"<EXAMPLE>\";\n    path = \"<EXAMPLE>\";\n    clientId: string = null;\n    redirectUri: string = null;\n    isEVM = true;\n    // if the Stamp requires extra information to be displayed to the user, add\n    // here\n    banner = \\{\n        heading:\n        \"Your Stamp heading here\"\n    };\n    async getProviderPayload(appContext: AppContext): Promise<ProviderPayload> \\{\n        const result = await Promise.resolve(\\{});\n        return result;\n    }\n}","non-evm-stamps#Non-EVM Stamps":"Copy the following code into the file, replacing <EXAMPLE> with your Stamp name. Note that for non-EVM Stamps the PlatformOptions type is imported from \"../types\" and the Platform class is imported from \"../utils/platform\".The new Stamp is exported as a class extending the Platform class.\n//App-bindings.ts - OAuth\nimport \\{ PlatformOptions } from \"../types\";\nimport \\{ Platform } from \"../utils/platform\";\nexport class <EXAMPLE> extends Platform \\{\n    platformId = \"<EXAMPLE>\";\n    path = \"<EXAMPLE>\";\n    clientId: string = null;\n    redirectUri: string = null;\nconstructor(options: platformOptions = \\{}) \\{\n    super();\n    this.clientId = options.clientId as string;\n    this.redirectUri = options.redirectUri as string;\n}\nasync getOauthUrl(state: string): Promise<string> \\{\n    const <EXAMPLE>Url = await Promise.resolve(\n        `<EXAMPLE> URL`\n    );\n    return <EXAMPLE>Url;\n    }\n}","providers-configts#Providers-config.ts":"Copy the following code into Providers-config.ts replacing <EXAMPLE> with your Stamp name. This file imports the PlatformSpec and PlatformGroupSpec from \"../types\" and exports the Stamp details and provider config data.\n//Providers-config.ts\nimport \\{ PlatformSpec, PlatformGroupSpec, Provider } from \"../types\";\nimport \\{ <EXAMPLE>Provider } from <ProviderFile>\nexport const PlatformDetails: PlatformSpec = \\{\n    icon: \"./assets/<EXAMPLE>StampIcon.svg\",\n    platform: \"<EXAMPLE>\",\n    name: \"<EXAMPLE>\",\n    description: \"Description to user about how they're going to use the Stamp\",\n    connectMessage: \"Connect Account\",\n    };\n    \nexport const ProviderConfig: PlatformGroupSpec[] = [\n    \\{\n    platformGroup: \"Name of the Stamp platform group\",\n    providers: [\n        \\{\n        title: \"Title of the provider\",\n        name: \"<EXAMPLE>\",\n        },\n    ]\n    },\n];\nexport const providers: Provider[] = [new <ProviderClass>()]","indexts#index.ts":"Copy and paste the following code into index.ts replacing <EXAMPLE> with your Stamp name. This code is used to export the providers, provider config data and app bindings.\n//index.ts\nexport \\{ <EXAMPLE>Platform } from \"./App-Bindings\";\nexport \\{ ProviderConfig, PlatformDetails, providers } from \"./Providers-config\";\nexport \\{ <EXAMPLE>Provider }","providersexamplets#Providers/example.ts":"Remember your file name will not be \"example.ts\" - it will be your stamp name. Some existing examples include \"google.ts\", \"EthErc20Possession.ts\" and \"github.ts\"._\nThis is where the hard work is done, because it is in this file that you will define your custom verification logic. The code will vary between applications depending on precisely what information is being verified. The verification could include communication with API servers, blockchain nodes or RPC providers, smart contracts or other external resources. We can walk through an example here, but bear in mind that you will have to adapt to your specific use case.Let's look at the Ethereum activity Stamp. This is an EVM Stamp that checks whether a user owns a certain threshold amount of ETH or ERC-20 tokens.  \n// EthErc20Possession.ts\n// ----- Types\nimport type \\{ Provider, ProviderOptions } from \"../../types\";\nimport type \\{ RequestPayload, VerifiedPayload } from \"@gitcoin/passport-types\";\n// ----- Ethers library\nimport \\{ Contract } from \"ethers\";\nimport \\{ formatUnits } from \"@ethersproject/units\";\n// ----- RPC Getter\nimport \\{ getRPCProvider } from \"../../utils/signer\";\n/*\nEth ERC20 Possession Provider can be used to check a greater than balance for ethereum or any other EVM token (ERC20).\nBy default this will verify the ethereum balance for the address in the parameter. To customize the\ntoken set the contract_address or decimal number in the options passed to the class. The default decimal number for formatting\nis 18.\n*/\n// define ERC20 contract ABI here\n// set the network rpc url based on env\nexport const RPC_URL = process.env.RPC_URL;\nexport async function getTokenBalance(\n  address: string,\n  tokenContractAddress: string,\n  decimalNumber: number,\n  payload: RequestPayload\n): Promise<number> \\{\n  // define a provider using the rpc url\n  const staticProvider = getRPCProvider(payload);\n  // load Token contract\n  const readContract = new Contract(tokenContractAddress, ERC20_ABI, staticProvider);\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\n  const tokenBalance: string = await readContract?.balanceOf(address);\n  const balanceFormatted: string = formatUnits(tokenBalance, decimalNumber);\n  return parseFloat(balanceFormatted);\n}\nexport async function getEthBalance(address: string, payload: RequestPayload): Promise<number> \\{\n  // define a provider using the rpc url\n  const staticProvider = getRPCProvider(payload);\n  const ethBalance = await staticProvider?.getBalance(address);\n  // convert a currency unit from wei to ether\n  const balanceFormatted: string = formatUnits(ethBalance, 18);\n  return parseFloat(balanceFormatted);\n}\nexport type ethErc20PossessionProviderOptions = \\{\n  threshold: number;\n  recordAttribute: string;\n  contractAddress: string;\n  decimalNumber: number;\n  error: string;\n};\n// Export an Eth ERC20 Possessions Provider. This is intended to be a generic implementation that should be extended\nexport class EthErc20PossessionProvider implements Provider \\{\n  // The type will be determined dynamically, from the options passed in to the constructor\n  type = \"\";\n  // Options can be set here and/or via the constructor\n  _options: ethErc20PossessionProviderOptions = \\{\n    threshold: 1,\n    recordAttribute: \"\",\n    contractAddress: \"\",\n    decimalNumber: 18,\n    error: \"Coin Possession Provider Error\",\n  };\n  // construct the provider instance with supplied options\n  constructor(options: ProviderOptions = \\{}) \\{\n    this._options = \\{ ...this._options, ...options };\n    this.type = `$\\{this._options.recordAttribute}#$\\{this._options.threshold}`;\n  }\n  // verify that the proof object contains valid === \"true\"\n  async verify(payload: RequestPayload): Promise<VerifiedPayload> \\{\n    const \\{ address } = payload;\n    let valid = false;\n    let amount = 0;\n    try \\{\n      if (this._options.contractAddress.length > 0) \\{\n        amount = await getTokenBalance(address, this._options.contractAddress, this._options.decimalNumber, payload);\n      } else \\{\n        amount = await getEthBalance(address, payload);\n      }\n    } catch (e) \\{\n      return \\{\n        valid: false,\n        error: [this._options.error],\n      };\n    } finally \\{\n      valid = amount >= this._options.threshold;\n    }\n    return \\{\n      valid,\n      record: valid\n        ? \\{\n            // store the address into the proof records\n            address,\n            [this._options.recordAttribute]: `$\\{this._options.threshold}`,\n          }\n        : \\{},\n    };\n  }\n}\nThere is a lot going on in this file, but we can break it down to make it easier to digest. The first thing to notice is that this contract requires information from the Ethereum blockchain, which requires access to a node or an RPC (remote procedure call) provider - these enable requests to be made to Ethereum, roughly equivalent to getting access to an API server in the Web2 world. In the code above, the following line instantiates an RPC provider.\n// set the network rpc url based on env\nexport const RPC_URL = process.env.RPC_URL;\nThis grabs an RPC endpoint from the environment variables. You can set this to your own node's RPC or use a third party RPC service. Either way, this is your code's entry point to the Ethereum network. This step is common to any verification method that relies on Ethereum blockchain data.Next there are two function definitions: getEthBalance() and getTokenBalance(). The getEthBalance() function calls the getBalance() function, which is part of the standard Ethereum JSON-RPC API, passing the user's address. The amount of ETH they own is returned. The getTokenBalance() function is slightly more complicated because it interacts with a smart contract rather than using the result of a JSON-RPC API request directly. Instead of token accounts and balances being stored directly in Ethereum's state trie, they are stored in the contract's storage. The values are accessed using contract functions, rather than using the JSON-RPC API directly.The ERC-20 token contract includes a function balanceOf() that returns the token balance for a given address. This function is common to all contracts that conform to the ERC-20 token standard. It is also necessary to specify which specific token you are interested, by providing the contract address. This is why getEthBalance() only takes the user address as an argument, whereas getTokenBalance() also takes a contract address (and a decimal number which is used to ensure the correct precision for token balances). Both functions take a requestPayload argument that is used to pass user-defined values from the client into the verification logic. Every Stamp has to have a verify() function that returns a boolean (true/false) indicating whether or not the verification was successful and some proof details. In this example, the verify() function is quite simple. It checks whether a contract address has been provided. If so, it calls getTokenBalance() and assigns the return value to amount. If no contract address was provided, it calls  getEthBalance()instead and assigns that return value to amount.  The value of amount is then compared to the user-defined threshold. If amount exceeds the threshold then the verification is successful, valid is set to true and verify() returns the user address along with some basic details about the verification (name and threshold value). Otherwise, verify() returns an empty object.For a new Stamp, you will need to extend the logic explained here to your precise use case. For EVM Stamps you will likely have some specific contract to call that may or may not conform to the ERC-20 standard. For non-EVM Stamps you probably want to make API calls to some server for verification information instead of interacting with Ethereum. You can browse the verification logic for all the existing EVM and non-EVM Stamps on the Passport Github repository.","__tests__exampletestts#__tests__/example.test.ts":"This is where you will add tests for your verification logic. Precisely how the tests are organized is up to you, as the tests will be specific to the individual Stamp. A standard pattern is to mock endpoints that return a range of responses that could be expected from your real external server and design tests to ensure your verification logic handles them all well. You should mock all possible responses to ensure complete test coverage.As an example, see the tests for the ETH transaction credential.","3-update-existing-files#3. Update existing files":"You have now created all the new files you need to create a new Stamp. The remaining steps all focus on pulling the new information you created into the existing Passport infrastructure, so that Passport can recognize and handle your new Stamp.You will need to navigate up a level, out of your newly created files and into platforms/src to find the relevant files to update.","platformsts#platforms.ts":"First, you will need to import the newly created platforms from the folders you just created, and export the instances from a single central location. platforms/src/platforms.ts acts as that central location. This file already contains the relevant code for the existing platforms, so you just need to follow the syntax for adding your own. The code snippet below shows what code you need to add. Just bear in mind that many lines of code referring to existing platforms have been removed from this example for clarity - your real file will have much more code in it!Remember to replace EXAMPLE with your platform name!\n//platforms.ts\n...\nimport * as Twitter from \"./Twitter\";\nimport * as Ens from \"./Ens\";\nimport * as <EXAMPLE> from \"./<EXAMPLE>\";\n...\n// Order of this array determines order in the Passport UI\nconst platforms: Record<string, PlatformConfig> = \\{\n  Twitter,\n  Ens,\n  <EXAMPLE>,\n  ...\n};\nexport default platforms;\nNext navigate into types. The file you need to update is types/src/index.d.ts. You will add the new Stamp's Platform ID and Provider ID to the bottom of their respective union types (PLATFORM_ID and PROVIDER_ID).\n//index.d.ts\nexport type PLATFORM_ID =\n| \"Google\"\n| \"Ens\"\n...\n| \"<EXAMPLE>\";\nexport type PROVIDER_ID =\n| \"Twitter\"\n| \"TwitterTweetGT10\"\n...\n| \"<EXAMPLE>\"\n| \"<EXAMPLE>\";","appcontextceramiccontexttsx#app/context/ceramicContext.tsx":"In this file you will import the Stamp from @gitcoin/passport-platforms again. Then create and add the Stamp to the platforms map by adding it to the bottom of the existing list of platforms.\n//ceramicContext.tsx\n...\nimport \\{\nBrightid,\nCoinbase,\n...,\n<EXAMPLE>,\n} = stampPlatforms;\nexport const platforms = new Map<PLATFORM_ID, PlatformProps>();\n...\nplatforms.set(\"<EXAMPLE>\", \\{\nplatform: new <EXAMPLE>.<EXAMPLE>Platform() \\,\nplatformGroupSpec: <EXAMPLE>.ProviderConfig,\n});\nThe final thing to do in the app package is to save a copy of your Stamp's icon, in .svg format, to the app/public/assets directory.The rest of the files only need to be updated if your app has new environment variables that need to be added to the infrastructure, app or iam packages. If, for example, your Stamp can be verified using the Etherscan or Alchemy keys that are already made available through Passport, then you can skip straight past these updates.The next few files to update live in the app package:","env-exampleenv#.env-example.env":"First, add the new Stamp's client ID, callback URL and any other environment variables that are necessary for your new Stamp to .env-example.env. This is an example file that contains dummy variables to avoid exposing sensitive data on the public Github repository. Please DO NOT add any real values to .env-example.env or they will be exposed publicly! Add the relevant fields for your new Stamp and then add DUMMY values that are not the same as your real values!\nNEXT_PUBLIC_PASSPORT_<EXAMPLE>_CLIENT_ID=<EXAMPLE>DUMMY_CLIENT\n_ID\nNEXT_PUBLIC_PASSPORT_<EXAMPLE>_CALLBACK=http://localhost:300\n0/","env#.env":"Now add the real values for your Stamp's environment variables to your local .env file.\nNEXT_PUBLIC_PASSPORT_<STAMP_PLATFORM_NAME>_CLIENT_ID=<EXAMPLE>_CLIENT\n_ID\nNEXT_PUBLIC_PASSPORT_<EXAMPLE>_CALLBACK=http://localhost:300\n0/\nNet we will update some files in the iam package. This is where the IAM authority is configured which is responsible for issuing verifiableCredentials. These verifiable credentials are issued based on a successful response from the verify() function for each Stamp. You defined your verification logic in a verify() function in this earlier step.All you need to do in the iam package is update the environment variables so that the necessary data for your Stamp is available. In the next section we will configure the infra package so that these environment variables, and those created earlier, are instantiated and provided as context to a remote server responsible for doing the actual Stamp issuance.","iamenv-exampleenv#iam/.env-example.env":"Add your dummy environment variables to .env-example.env.\n<EXAMPLE>_CLIENT_ID=EXAMPLE_CLIENT_ID\n<EXAMPLE>_CLIENT_SECRET=EXAMPLE_CLIENT_SECRET\n<EXAMPLE>_CALLBACK=http://localhost:3000/","iamenv#iam/.env":"Add your real environment variables to .env.\n<EXAMPLE>_CLIENT_ID=123456abcdef\n<EXAMPLE>_CLIENT_SECRET=123456abcdef\n<EXAMPLE>_CALLBACK=http://localhost:3000/\nNow we can leave the iam package and update a few files in the infra package. This is where we configure the remote server to issue Stamps based on your Stamp details and verification logic.","infrareviewindexts#infra/review/index.ts":"Here you will add secrets objects for each of the environment variables you added to your .env files. This allows your secrets to be transmitted securely to the remote server so your Stamp verification logic can be executed without having to expose any keys or other sensitive information on the public repository.In this file you will find an instance of the Fargate service assigned to the variable service . In there, you will find an array named secrets nested inside several other objects. You need to add a secrets object to this array for each of your environment variables.\n//index.ts\nconst service = new awsx.ecs.FargateService(\"dpopp-iam\", \\{\n  cluster,\n  ...,\n  taskDefinitionArgs: \\{\n    containers: \\{\n      iam: \\{\n      ...,\n      secrets: [\n        \\{\n          name: \" <EXAMPLE>_CLIENT_ID \",\n          valueFrom:\n          `$\\{IAM_SERVER_SSM_ARN}: <EXAMPLE>_CLIENT_ID:: `,\n        },\n        \\{\n          name: \" <EXAMPLE>_CLIENT_SECRET \",\n          valueFrom:\n          `$\\{IAM_SERVER_SSM_ARN}: <EXAMPLE>_CLIENT_SECRET:: `,\n        },\n        \\{\n          name: \" <EXAMPLE>_CALLBACK \",\n          valueFrom:\n          `$\\{IAM_SERVER_SSM_ARN}: <EXAMPLE>_CALLBACK:: `,\n        },\n      ],\n    }\n  }\n}\n});\nThis step should then be repeated identically for the staging and production versions of this file. To be clear, update infra/staging/index.tsand infra/production/index.ts in exactly the same way as you just updated infra/review/index.ts.","4-further-customization#4. Further customization":"You may need additional procedures for your Stamp. You can create a procedures folder inside of the Stamp folder to hold any additional verification, auth, etc. you may need. Every Stamp is slightly different and will require different materials in order to function correctly - since the design space is so large, it's up to you to know what you need for your specific purpose!","5-build-and-run-the-services#5. Build and run the services":"You will need to have Node (v16 LTS), Yarn and Git installed in order to follow these steps.Now you have updated your local copy of the Human Passport repository, you can build and run it. You can do this by navigating to the top level project directory (passport) and running:\nnpm install --global lerna\nlerna init\nlerna bootstrap\nNext, you can start the iam app and ceramic services concurrently. This step will only work if you have created your environment variables as explained in the previous steps on this page.\nyarn start","6-raise-a-pull-request#6. Raise a Pull Request":"Finally, having seen your app running successfully, you can raise a pull request against the Human Passport GitHub repository. This will make the changes you have made to support your app part of the canonical public Stamp repository. However, before this happens your changes will be reviewed by the Human Passport team who may request changes.When you raise a pull request, it is important to include the following checklist. This helps you to verify that all the necessary steps have been taken to create your Stamp, and also helps the reviewers of the pull request check your work and merge it faster.\n## Stamp Provider <provider name here>\n- [ ] The Stamp provider name is globally unique (and should not have been used previously). This is because the provider name will be included in the record used  to create the Stamp hash:\n- [ ] The implementation has been unit tested\n- [ ] Verification payload\n    json\n    valid: true / false,\n    record: \\{\n       ... // Unique payload identifying user\n    }\n<strong>- [ ] The attribute `valid` is false if the Stamp verification fails\n</strong>- [ ] The record must contain the following attributes:\n    - 1 or more attributes uniquely identifying the user:\n        - An ETH address - it should always be lower case (not checksummed)\n        - An email (in case of Google for example)\n        - The users unique ID (like for Facebook, Twitter, Github)        \n- [ ] The payload should never contain a field named `pii`\n    - This field is reserved for internal use\n</code></pre>\nYou can use the code snippet above as a template - copy and paste it into your pull request and tick the boxes to show that each item has been completed.The following is an example of a pull request that uses a similar checklist: Integrate Phi Stamp in Passport","7-note-on-context-and-cache#7. Note on context and cache":"It is important to understand the difference between context and cache, and for you to use them appropriately when developing your Stamp. They both refer to holding information in memory. Context is used to pass the results of expensive operations performed during the verification process for a specific Stamp between calls to verify within each provider. This is the expected way for Stamps to handle their data. Context should be used wherever possible, in preference to using the cache. The cache exists to support unusual or complex authentication mechanisms that cannot work within thecontext logic. The cache is used to store data between multiple HTTP requests, for example if data stored in the App-bindings request needs to be referenced in a /verify request. This may occur when objects need to be shared across multiple Providers. In this case, the caching must be done using the caching mechanism defined in platforms/src/utils/cache.ts.If the cache is used, its payload should be moved to context and then the cache should be explicitly cleared.The following example shows the cache mechanism being used correctly.  \nconst loadTwitterCache = (token: string): TwitterCache => loadCacheSession(token, \"Twitter\");\n// retrieve the instantiated Client shared between Providers\nexport const getAuthClient = async (sessionKey: string, code: string, context: TwitterContext): Promise<Client> => \\{\n  if (!context.twitter?.authClient) \\{\n    const session = loadTwitterCache(sessionKey);\n    const \\{ oauthUser } = session;\n    if (!context.twitter) context.twitter = \\{};\n    context.twitter.authClient = new Client(oauthUser);\n    clearCacheSession(sessionKey, \"Twitter\");\n  }\n  return context.twitter.authClient;\n};","8-see-some-examples#8. See some examples":"It might be helpful to look at some past examples of pull requests that add Stamps to the Human Passport GitHub repository. Browse the examples below to see exactly how others have gone about it:\nHypercert Stamp\nGuildxyz Stamp\nCoinbase Stamp\nPhi Stamp\nYou can also ask questions in our developer support channel on Telegram."}}}
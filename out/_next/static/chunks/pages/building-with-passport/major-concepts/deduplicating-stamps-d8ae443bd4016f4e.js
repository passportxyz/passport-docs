(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7011],{8774:function(e,t,s){"use strict";s.r(t),s.d(t,{useTOC:function(){return useTOC}});var n=s(4175),i=s(4859),a=s(601),o=s(2816),r=s(1527);function ownKeys(e,t){var s=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),s.push.apply(s,n)}return s}function _objectSpread(e){for(var t=1;t<arguments.length;t++){var s=null!=arguments[t]?arguments[t]:{};t%2?ownKeys(Object(s),!0).forEach(function(t){(0,n.Z)(e,t,s[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(s)):ownKeys(Object(s)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(s,t))})}return e}function useTOC(e){return[{value:"Why is deduplication necessary?",id:"why-is-deduplication-necessary",depth:3},{value:"Do you need to handle deduplication in your app?",id:"do-you-need-to-handle-deduplication-in-your-app",depth:3},{value:"How does Human Passport handle duplicate Stamps?",id:"how-does-human-passport-handle-duplicate-stamps",depth:3},{value:"Things to note",id:"things-to-note",depth:3},{value:"Summary",id:"summary",depth:3}]}function MDXLayout(e){var t=e.toc,s=void 0===t?useTOC(e):t,n=_objectSpread(_objectSpread({code:"code",em:"em",h1:"h1",h3:"h3",p:"p",strong:"strong"},(0,o.a)()),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{children:"Deduplicating Stamps"}),"\n",(0,r.jsx)(n.h3,{id:s[0].id,children:s[0].value}),"\n",(0,r.jsx)(n.p,{children:"Stamp deduplication is a crucial feature that prevents users from amplifying their influence over some specific outcome by submitting the same Stamps across multiple Passports."}),"\n",(0,r.jsx)(n.p,{children:"It is important for users to be able to hold multiple Passports representing different user profiles that might be used to as identification in specific communities. However, without deduplication logic, this could allow users to repeatedly attach the same Stamps to multiple Passports, fooling an app into treating each Passport as a real, verified human."}),"\n",(0,r.jsx)(n.p,{children:"Deduplication ensures that a user can only associate an individual Stamp to one single identity within a specific context."}),"\n",(0,r.jsx)(n.h3,{id:s[1].id,children:s[1].value}),"\n",(0,r.jsx)(n.p,{children:"If your app uses a Passport default Scorer, then deduplication is already handled server-side. When you request a score through the API, we calculate scores after already deduplicating Stamps, meaning you don’t have to implement any deduplication logic yourself."}),"\n",(0,r.jsxs)(n.p,{children:["However, if you are using your own custom scoring mechanism based on Stamp data, you will have to implement deduplication for yourself. Each Stamp has a ",(0,r.jsx)(n.code,{children:"hash"})," field that can be used as a unique identifer. You can store hashes and compare them across all your users’ Passports to ensure they are not being used multiple times. Our Scorer uses a Last-In-First-Out mechanism to handle duplicates, but you might want to use your own algorithm in your custom Scorer."]}),"\n",(0,r.jsx)(n.h3,{id:s[2].id,children:s[2].value}),"\n",(0,r.jsx)(n.p,{children:"Human Passport handles the issue of Stamp duplication by automatically identifying and eliminating duplicate Stamps. This prevents users from using the same credentials to verify their Stamps and identity across multiple Passports. This ensures that each user in an application has a unique and consistent digital identity."}),"\n",(0,r.jsxs)(n.p,{children:["By default, the Human Passport API uses a ",(0,r.jsx)(n.strong,{children:"Last In, First Out (LIFO)"})," Stamp deduplication method."]}),"\n",(0,r.jsxs)(n.p,{children:["This means that, in a given scoring instance, if a Passport holder submits a Stamp that has already been submitted by another user, the ",(0,r.jsx)(n.em,{children:"duplicate"})," Stamp is ignored and not counted towards the score."]}),"\n",(0,r.jsx)(n.p,{children:"For example, let’s say you build an application that uses the Human Passport API to verify the unique humanity of your users. Two Passports, “Passport A” and “Passport B,” present the same Stamp based on the same Twitter account. In this scenario, the Last-in-First-out deduplication method would only count the Stamp instance that was submitted earliest, ignoring the one that was submitted later."}),"\n",(0,r.jsx)(n.p,{children:"For example, if Passport A submitted the Twitter Stamp first, followed by Passport B, your app would only count the instance of the Twitter Stamp submitted by Passport A. The same rule applies to any subsequent instances of the Stamp."}),"\n",(0,r.jsx)(n.p,{children:"This LIFO method ensures that each Passport’s score accurately reflects the unique identity of its holder. This prevents duplicate Stamps from skewing the verification process and prevents users from re-using evidence of personhood across multiple Passports within an application."}),"\n",(0,r.jsx)(n.h3,{id:s[3].id,children:s[3].value}),"\n",(0,r.jsx)(n.p,{children:"Stamps are unique to scoring instances. For example, one user uses Passport holder A with one Twitter account in an application that uses scoring instance X, and another user uses the same Twitter account in a distinct Passport in an independent scoring instance Y. In this case, both users will get scored for the Twitter account. As long as the scoring instances are independent, there is no concern for double counting or interference between instances. This allows users to create multiple personas that they use in different contexts but prevents double-counting of their credentials within a context."}),"\n",(0,r.jsx)(n.p,{children:"The scores assigned to Passports will not change once they are issued. This means that there is no need to recalculate Passport scores or synchronize them again in case of duplicate Stamp submissions. Once a score is assigned to a Passport, it remains fixed and can be relied upon for future verifications, even if a duplicate Stamp is submitted by a new Passport. This makes the scoring process more efficient and streamlined, which is particularly important for large and complex applications that score a high volume of verifiable credentials."}),"\n",(0,r.jsxs)(n.p,{children:["Also note that because Stamp deduplication is achieved using a ‘last in, first out’ model, it is possible for Passports with identical Stamps to return different scores from different Scorers. The reason is that if the identical passports A and B are submitted to Scorer 1 in the order ",(0,r.jsx)(n.code,{children:"A,B"}),", the returned score could be different to the same Passports submitted to Scorer 2 in the order ",(0,r.jsx)(n.code,{children:"B,A"}),", because different instances of duplicate Stamps would be removed."]}),"\n",(0,r.jsx)(n.h3,{id:s[4].id,children:s[4].value}),"\n",(0,r.jsx)(n.p,{children:"The LIFO deduplication strategy has several benefits for Passport holders and developers. It ensures that each Passport holder (in other words, Ethereum address) is assessed based on their unique set of Stamps, and that no one receives an unfair advantage due to having the same Stamp as another Passport holder within a given scoring instance. This means that for applications using the Human Passport API, there will be no double-counting of Stamps within the app, ensuring a fair and accurate assessment of each user’s unique identity."})]})}t.default=(0,i.c)(MDXLayout,"/building-with-passport/major-concepts/deduplicating-stamps",{filePath:"pages/building-with-passport/major-concepts/deduplicating-stamps.mdx",timestamp:1742593489e3,pageMap:a.v,frontMatter:{title:"Deduplicating Stamps",description:"Stamp deduplication is important for preventing users from using the same Stamps across multiple Passports to influence some specific outcome."},title:"Deduplicating Stamps"},"undefined"==typeof RemoteContent?useTOC:RemoteContent.useTOC)},8753:function(e,t,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/building-with-passport/major-concepts/deduplicating-stamps",function(){return s(8774)}])}},function(e){e.O(0,[4859,601,9774,2888,179],function(){return e(e.s=8753)}),_N_E=e.O()}]);